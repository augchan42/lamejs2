{"version":3,"sources":["../src/index.ts","../src/core/MPEGMode.ts","../src/lib/Version.js","../src/lib/common.js","../src/lib/NewMDCT.js","../src/lib/III_psy_xmin.js","../src/lib/III_psy_ratio.js","../src/lib/MPEGMode.js","../src/lib/L3Side.js","../src/lib/Encoder.js","../src/lib/Tables.js","../src/lib/GrInfo.js","../src/lib/ScaleFac.js","../src/lib/MeanBits.js","../src/lib/IIISideInfo.js","../src/lib/NsPsy.js","../src/lib/VBRSeekInfo.js","../src/lib/LameInternalFlags.js","../src/lib/QuantizePVT.js","../src/lib/Takehiro.js","../src/lib/FFT.js","../src/lib/PsyModel.js","../src/lib/LameGlobalFlags.js","../src/lib/ATH.js","../src/lib/GainAnalysis.js","../src/lib/ReplayGain.js","../src/lib/CBRNewIterationLoop.js","../src/lib/Lame.js","../src/lib/BitStream.js","../src/lib/VBRQuantize.js","../src/lib/CalcNoiseResult.js","../src/lib/CalcNoiseData.js","../src/lib/Quantize.js","../src/lib/VBRTag.js","../src/lib/ID3TagSpec.js","../src/lib/Reservoir.js","../src/lib/Presets.js","../src/core/LameContext.ts","../src/core/Mp3Encoder.ts"],"sourcesContent":["export { Mp3Encoder } from './core/Mp3Encoder.js';\nexport { MPEGMode } from './core/MPEGMode.js';\nexport type { Mp3Config, EncodedChunk, WavHeader } from './core/types.js'; ","// Define the enum\nexport const enum MPEGMode {\n  STEREO = 0,\n  JOINT_STEREO = 1,\n  DUAL_CHANNEL = 2,\n  MONO = 3,\n  NOT_SET = 4\n}\n\n// Define the type for mode values\ntype ModeValue = {\n  value: number;\n  ordinal: () => number;\n};\n\n// Create a mapping from enum to mode values\nexport const MPEGModeValues: Record<keyof typeof MPEGMode, ModeValue> = {\n  STEREO: { value: 0, ordinal: () => 0 },\n  JOINT_STEREO: { value: 1, ordinal: () => 1 },\n  DUAL_CHANNEL: { value: 2, ordinal: () => 2 },\n  MONO: { value: 3, ordinal: () => 3 },\n  NOT_SET: { value: 4, ordinal: () => 4 }\n} as const; ","class Version {\n    constructor(context) {\n        this.context = context;\n    }\n\n    // Move all methods to the class definition\n    getLameShortVersion() {\n        return \"3.100\";\n    }\n\n    getLameVersion() {\n        return \"3.100\";\n    }\n\n    getLameVeryShortVersion() {\n        return \"LAME3.100\";\n    }\n\n    getPsyVersion() {\n        return \"0.93\";\n    }\n\n    getLameUrl() {\n        return \"http://www.mp3dev.org/\";\n    }\n\n    getLameOsBitness() {\n        return \"32bits\";\n    }\n}\n\nexport { Version };\n","function new_byte(count) {\n    return new Int8Array(count);\n}\n\nfunction new_short(count) {\n    return new Int16Array(count);\n}\n\nfunction new_int(count) {\n    return new Int32Array(count);\n}\n\nfunction new_float(count) {\n    return new Float32Array(count);\n}\n\nfunction new_double(count) {\n    return new Float64Array(count);\n}\n\nfunction new_float_n(args) {\n    if (args.length == 1) {\n        return new_float(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_float_n(args));\n    }\n    return A;\n}\nfunction new_int_n(args) {\n    if (args.length == 1) {\n        return new_int(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_int_n(args));\n    }\n    return A;\n}\n\nfunction new_short_n(args) {\n    if (args.length == 1) {\n        return new_short(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_short_n(args));\n    }\n    return A;\n}\n\nfunction new_array_n(args) {\n    if (args.length == 1) {\n        return new Array(args[0]);\n    }\n    var sz = args[0];\n    args = args.slice(1);\n    var A = [];\n    for (var i = 0; i < sz; i++) {\n        A.push(new_array_n(args));\n    }\n    return A;\n}\n\n\nvar Arrays = {};\n\nArrays.fill = function (a, fromIndex, toIndex, val) {\n    if (arguments.length == 2) {\n        for (var i = 0; i < a.length; i++) {\n            a[i] = arguments[1];\n        }\n    } else {\n        for (var i = fromIndex; i < toIndex; i++) {\n            a[i] = val;\n        }\n    }\n};\n\nvar System = {};\n\nSystem.arraycopy = function (src, srcPos, dest, destPos, length) {\n    var srcEnd = srcPos + length;\n    while (srcPos < srcEnd)\n        dest[destPos++] = src[srcPos++];\n};\n\nSystem.out = {};\nSystem.out.println = function (message) {\n    console.log(message);\n}\n\nSystem.out.printf = function () {\n    console.log.apply(console, arguments);\n}\n\n\nvar Util = {};\nUtil.SQRT2 = 1.41421356237309504880;\nUtil.FAST_LOG10 = function (x) {\n    return Math.log10(x);\n};\n\nUtil.FAST_LOG10_X = function (x, y) {\n    return Math.log10(x) * y;\n};\n\nfunction ShortBlock(ordinal) {\n    this.ordinal = ordinal;\n}\n/**\n * LAME may use them, even different block types for L/R.\n */\nShortBlock.short_block_allowed = new ShortBlock(0);\n/**\n * LAME may use them, but always same block types in L/R.\n */\nShortBlock.short_block_coupled = new ShortBlock(1);\n/**\n * LAME will not use short blocks, long blocks only.\n */\nShortBlock.short_block_dispensed = new ShortBlock(2);\n/**\n * LAME will not use long blocks, short blocks only.\n */\nShortBlock.short_block_forced = new ShortBlock(3);\n\nvar Float = {};\nFloat.MAX_VALUE = 3.4028235e+38;\n\nfunction VbrMode(ordinal) {\n    this.ordinal = ordinal;\n}\nVbrMode.vbr_off = new VbrMode(0);\nVbrMode.vbr_mt = new VbrMode(1);\nVbrMode.vbr_rh = new VbrMode(2);\nVbrMode.vbr_abr = new VbrMode(3);\nVbrMode.vbr_mtrh = new VbrMode(4);\nVbrMode.vbr_default = VbrMode.vbr_mtrh;\n\nvar assert = function (x) {\n    //console.assert(x);\n};\n\nexport {\n    System,\n    VbrMode,\n    Float,\n    ShortBlock,\n    Util,\n    Arrays,\n    new_array_n,\n    new_byte,\n    new_double,\n    new_float,\n    new_float_n,\n    new_int,\n    new_int_n,\n    new_short,\n    new_short_n,\n    assert\n};\n","/*\n *      MP3 window subband -> subband filtering -> mdct routine\n *\n *      Copyright (c) 1999-2000 Takehiro Tominaga\n *\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n/*\n *         Special Thanks to Patrick De Smet for your advices.\n */\n\n/* $Id: NewMDCT.java,v 1.11 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nimport * as common from './common.js';\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nimport { Encoder } from './Encoder.js';\n\n\nfunction NewMDCT() {\n\n\tvar enwindow = [\n\t\t\t-4.77e-07 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.03951e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.53674e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.841473e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.5758972e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t3.401756e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.83715e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.740951125354959 / 2.384e-06, /* 15 */\n\t\t\t1.2398e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.91212e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t2.283096e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t1.6994476e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.8756866e-02 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.630711e-03 * 0.740951125354959 / 2.384e-06,\n\t\t\t-2.47478e-04 * 0.740951125354959 / 2.384e-06,\n\t\t\t-1.4782e-05 * 0.740951125354959 / 2.384e-06,\n\t\t\t9.063471690191471e-01, 1.960342806591213e-01,\n\n\t\t\t-4.77e-07 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.05858e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.30786e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.521515e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.5694122e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t3.643036e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.91821e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t9.6321e-05 * 0.773010453362737 / 2.384e-06, /* 14 */\n\t\t\t1.1444e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.65462e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t2.110004e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t1.6112804e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.9634247e-02 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.803326e-03 * 0.773010453362737 / 2.384e-06,\n\t\t\t-2.77042e-04 * 0.773010453362737 / 2.384e-06,\n\t\t\t-1.6689e-05 * 0.773010453362737 / 2.384e-06,\n\t\t\t8.206787908286602e-01, 3.901806440322567e-01,\n\n\t\t\t-4.77e-07 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.07288e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.02653e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t2.174854e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.5586357e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t3.858566e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.95159e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t9.3460e-05 * 0.803207531480645 / 2.384e-06, /* 13 */\n\t\t\t1.0014e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.40190e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.937389e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t1.5233517e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.0506859e-02 * 0.803207531480645 / 2.384e-06,\n\t\t\t-2.974033e-03 * 0.803207531480645 / 2.384e-06,\n\t\t\t-3.07560e-04 * 0.803207531480645 / 2.384e-06,\n\t\t\t-1.8120e-05 * 0.803207531480645 / 2.384e-06,\n\t\t\t7.416505462720353e-01, 5.805693545089249e-01,\n\n\t\t\t-4.77e-07 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t8.68797e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.800537e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t3.5435200e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t4.049301e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.94205e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t9.0599e-05 * 0.831469612302545 / 2.384e-06, /* 12 */\n\t\t\t9.060e-06 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.16348e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.766682e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t1.4358521e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-2.1372318e-02 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.14188e-03 * 0.831469612302545 / 2.384e-06,\n\t\t\t-3.39031e-04 * 0.831469612302545 / 2.384e-06,\n\t\t\t-1.9550e-05 * 0.831469612302545 / 2.384e-06,\n\t\t\t6.681786379192989e-01, 7.653668647301797e-01,\n\n\t\t\t-4.77e-07 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.29220e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.399517e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t3.5242081e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t4.215240e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.89437e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t8.7261e-05 * 0.857728610000272 / 2.384e-06, /* 11 */\n\t\t\t8.106e-06 * 0.857728610000272 / 2.384e-06,\n\t\t\t9.3937e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.597881e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t1.3489246e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.2228718e-02 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.306866e-03 * 0.857728610000272 / 2.384e-06,\n\t\t\t-3.71456e-04 * 0.857728610000272 / 2.384e-06,\n\t\t\t-2.1458e-05 * 0.857728610000272 / 2.384e-06,\n\t\t\t5.993769336819237e-01, 9.427934736519954e-01,\n\n\t\t\t-4.77e-07 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.08719e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.8392e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.71317e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t3.5007000e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t4.357815e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t9.80854e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t8.3923e-05 * 0.881921264348355 / 2.384e-06, /* 10 */\n\t\t\t7.629e-06 * 0.881921264348355 / 2.384e-06,\n\t\t\t7.2956e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.432419e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t1.2627602e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3074150e-02 * 0.881921264348355 / 2.384e-06,\n\t\t\t-3.467083e-03 * 0.881921264348355 / 2.384e-06,\n\t\t\t-4.04358e-04 * 0.881921264348355 / 2.384e-06,\n\t\t\t-2.3365e-05 * 0.881921264348355 / 2.384e-06,\n\t\t\t5.345111359507916e-01, 1.111140466039205e+00,\n\n\t\t\t-9.54e-07 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.08242e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t7.31945e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.15938e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t3.4730434e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.477024e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t9.68933e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t8.0585e-05 * 0.903989293123443 / 2.384e-06, /* 9 */\n\t\t\t6.676e-06 * 0.903989293123443 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.269817e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t1.1775017e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.3907185e-02 * 0.903989293123443 / 2.384e-06,\n\t\t\t-3.622532e-03 * 0.903989293123443 / 2.384e-06,\n\t\t\t-4.38213e-04 * 0.903989293123443 / 2.384e-06,\n\t\t\t-2.5272e-05 * 0.903989293123443 / 2.384e-06,\n\t\t\t4.729647758913199e-01, 1.268786568327291e+00,\n\n\t\t\t-9.54e-07 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.06812e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.74248e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.3379e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4412861e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.573822e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t9.54151e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t7.6771e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t6.199e-06 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t3.4332e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.111031e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t1.0933399e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.4725437e-02 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-3.771782e-03 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-4.72546e-04 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t-2.7657e-05 * 0.92387953251128675613 / 2.384e-06,\n\t\t\t4.1421356237309504879e-01, /* tan(PI/8) */\n\t\t\t1.414213562373095e+00,\n\n\t\t\t-9.54e-07 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.05381e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t6.10352e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-4.75883e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.4055710e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t4.649162e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.35555e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t7.3433e-05 * 0.941544065183021 / 2.384e-06, /* 7 */\n\t\t\t5.245e-06 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.7166e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t9.56535e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t1.0103703e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-2.5527000e-02 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.914356e-03 * 0.941544065183021 / 2.384e-06,\n\t\t\t-5.07355e-04 * 0.941544065183021 / 2.384e-06,\n\t\t\t-3.0041e-05 * 0.941544065183021 / 2.384e-06,\n\t\t\t3.578057213145241e-01, 1.546020906725474e+00,\n\n\t\t\t-9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t1.02520e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t5.39303e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-1.011848e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.3659935e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t4.703045e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.15051e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t7.0095e-05 * 0.956940335732209 / 2.384e-06, /* 6 */\n\t\t\t4.768e-06 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.54e-07 * 0.956940335732209 / 2.384e-06,\n\t\t\t8.06808e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t9.287834e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-2.6310921e-02 * 0.956940335732209 / 2.384e-06,\n\t\t\t-4.048824e-03 * 0.956940335732209 / 2.384e-06,\n\t\t\t-5.42164e-04 * 0.956940335732209 / 2.384e-06,\n\t\t\t-3.2425e-05 * 0.956940335732209 / 2.384e-06,\n\t\t\t3.033466836073424e-01, 1.662939224605090e+00,\n\n\t\t\t-1.431e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t9.9182e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.62532e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.573563e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t3.3225536e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t4.737377e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.91685e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.6280e-05 * 0.970031253194544 / 2.384e-06, /* 5 */\n\t\t\t4.292e-06 * 0.970031253194544 / 2.384e-06,\n\t\t\t-1.3828e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t6.61850e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t8.487225e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-2.7073860e-02 * 0.970031253194544 / 2.384e-06,\n\t\t\t-4.174709e-03 * 0.970031253194544 / 2.384e-06,\n\t\t\t-5.76973e-04 * 0.970031253194544 / 2.384e-06,\n\t\t\t-3.4809e-05 * 0.970031253194544 / 2.384e-06,\n\t\t\t2.504869601913055e-01, 1.763842528696710e+00,\n\n\t\t\t-1.431e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t9.5367e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.78609e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.161503e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t3.2754898e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t4.752159e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t8.66413e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t6.2943e-05 * 0.98078528040323 / 2.384e-06, /* 4 */\n\t\t\t3.815e-06 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.718e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t5.22137e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t7.703304e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-2.7815342e-02 * 0.98078528040323 / 2.384e-06,\n\t\t\t-4.290581e-03 * 0.98078528040323 / 2.384e-06,\n\t\t\t-6.11782e-04 * 0.98078528040323 / 2.384e-06,\n\t\t\t-3.7670e-05 * 0.98078528040323 / 2.384e-06,\n\t\t\t1.989123673796580e-01, 1.847759065022573e+00,\n\n\t\t\t-1.907e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t9.0122e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t2.88486e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.774239e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.2248020e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t4.748821e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t8.38757e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t5.9605e-05 * 0.989176509964781 / 2.384e-06, /* 3 */\n\t\t\t3.338e-06 * 0.989176509964781 / 2.384e-06,\n\t\t\t-3.9577e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t3.88145e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t6.937027e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-2.8532982e-02 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.395962e-03 * 0.989176509964781 / 2.384e-06,\n\t\t\t-6.46591e-04 * 0.989176509964781 / 2.384e-06,\n\t\t\t-4.0531e-05 * 0.989176509964781 / 2.384e-06,\n\t\t\t1.483359875383474e-01, 1.913880671464418e+00,\n\n\t\t\t-1.907e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.4400e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t1.91689e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-3.411293e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.1706810e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t4.728317e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t8.09669e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t5.579e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t3.338e-06 * 0.995184726672197 / 2.384e-06,\n\t\t\t-5.0545e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t2.59876e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t6.189346e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-2.9224873e-02 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.489899e-03 * 0.995184726672197 / 2.384e-06,\n\t\t\t-6.80923e-04 * 0.995184726672197 / 2.384e-06,\n\t\t\t-4.3392e-05 * 0.995184726672197 / 2.384e-06,\n\t\t\t9.849140335716425e-02, 1.961570560806461e+00,\n\n\t\t\t-2.384e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.7724e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t8.8215e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.072189e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t3.1132698e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.691124e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t7.79152e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.2929e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t2.861e-06 * 0.998795456205172 / 2.384e-06,\n\t\t\t-6.0558e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t1.37329e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t5.462170e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-2.9890060e-02 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.570484e-03 * 0.998795456205172 / 2.384e-06,\n\t\t\t-7.14302e-04 * 0.998795456205172 / 2.384e-06,\n\t\t\t-4.6253e-05 * 0.998795456205172 / 2.384e-06,\n\t\t\t4.912684976946725e-02, 1.990369453344394e+00,\n\n\t\t\t3.5780907e-02 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.7876148e-02 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t3.134727e-03 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.457142e-03 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t9.71317e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t2.18868e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.01566e-04 * Util.SQRT2 * 0.5 / 2.384e-06,\n\t\t\t1.3828e-05 * Util.SQRT2 * 0.5 / 2.384e-06,\n\n\t\t\t3.0526638e-02 / 2.384e-06, 4.638195e-03 / 2.384e-06,\n\t\t\t7.47204e-04 / 2.384e-06, 4.9591e-05 / 2.384e-06,\n\t\t\t4.756451e-03 / 2.384e-06, 2.1458e-05 / 2.384e-06,\n\t\t\t-6.9618e-05 / 2.384e-06, /* 2.384e-06/2.384e-06 */\n\t];\n\n\tvar NS = 12;\n\tvar NL = 36;\n\n\tvar win = [\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049690e-13,\n\t     6.423305872147839e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943412e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758252e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558783e-12,\n\t     8.371015190102974e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.456116108943412e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758252e-12,\n\t     -2.858043359288076e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558783e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347923e-13,\n\t     -6.423305872147843e-13,\n\t     -9.400849094049696e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049694e-13,\n\t     -6.423305872147840e-13,\n\t     -2.382191739347918e-13,\n\t     ],\n\t    [\n\t     2.382191739347913e-13,\n\t     6.423305872147834e-13,\n\t     9.400849094049688e-13,\n\t     1.122435026096556e-12,\n\t     1.183840321267481e-12,\n\t     1.122435026096556e-12,\n\t     9.400849094049688e-13,\n\t     6.423305872147841e-13,\n\t     2.382191739347918e-13,\n\n\t     5.456116108943413e-12,\n\t     4.878985199565852e-12,\n\t     4.240448995017367e-12,\n\t     3.559909094758253e-12,\n\t     2.858043359288075e-12,\n\t     2.156177623817898e-12,\n\t     1.475637723558782e-12,\n\t     8.371015190102975e-13,\n\t     2.599706096327376e-13,\n\n\t     -5.461314069809755e-12,\n\t     -4.921085770524055e-12,\n\t     -4.343405037091838e-12,\n\t     -3.732668368707687e-12,\n\t     -3.093523840190885e-12,\n\t     -2.430835727329465e-12,\n\t     -1.734679010007751e-12,\n\t     -9.748253656609281e-13,\n\t     -2.797435120168326e-13,\n\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     -2.283748241799531e-13,\n\t     -4.037858874020686e-13,\n\t     -2.146547464825323e-13,\n\t     ],\n\t    [\n\t     1.316524975873958e-01, /* win[SHORT_TYPE] */\n\t     4.142135623730950e-01,\n\t     7.673269879789602e-01,\n\n\t     1.091308501069271e+00, /* tantab_l */\n\t     1.303225372841206e+00,\n\t     1.569685577117490e+00,\n\t     1.920982126971166e+00,\n\t     2.414213562373094e+00,\n\t     3.171594802363212e+00,\n\t     4.510708503662055e+00,\n\t     7.595754112725146e+00,\n\t     2.290376554843115e+01,\n\n\t     0.98480775301220802032, /* cx */\n\t     0.64278760968653936292,\n\t     0.34202014332566882393,\n\t     0.93969262078590842791,\n\t     -0.17364817766693030343,\n\t     -0.76604444311897790243,\n\t     0.86602540378443870761,\n\t     0.500000000000000e+00,\n\n\t     -5.144957554275265e-01, /* ca */\n\t     -4.717319685649723e-01,\n\t     -3.133774542039019e-01,\n\t     -1.819131996109812e-01,\n\t     -9.457419252642064e-02,\n\t     -4.096558288530405e-02,\n\t     -1.419856857247115e-02,\n\t     -3.699974673760037e-03,\n\n\t     8.574929257125442e-01, /* cs */\n\t     8.817419973177052e-01,\n\t     9.496286491027329e-01,\n\t     9.833145924917901e-01,\n\t     9.955178160675857e-01,\n\t     9.991605581781475e-01,\n\t     9.998991952444470e-01,\n\t     9.999931550702802e-01,\n\t     ],\n\t    [\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     0.000000000000000e+00,\n\t     2.283748241799531e-13,\n\t     4.037858874020686e-13,\n\t     2.146547464825323e-13,\n\n\t     5.461314069809755e-12,\n\t     4.921085770524055e-12,\n\t     4.343405037091838e-12,\n\t     3.732668368707687e-12,\n\t     3.093523840190885e-12,\n\t     2.430835727329466e-12,\n\t     1.734679010007751e-12,\n\t     9.748253656609281e-13,\n\t     2.797435120168326e-13,\n\n\t     -5.456116108943413e-12,\n\t     -4.878985199565852e-12,\n\t     -4.240448995017367e-12,\n\t     -3.559909094758253e-12,\n\t     -2.858043359288075e-12,\n\t     -2.156177623817898e-12,\n\t     -1.475637723558782e-12,\n\t     -8.371015190102975e-13,\n\t     -2.599706096327376e-13,\n\n\t     -2.382191739347913e-13,\n\t     -6.423305872147834e-13,\n\t     -9.400849094049688e-13,\n\t     -1.122435026096556e-12,\n\t     -1.183840321267481e-12,\n\t     -1.122435026096556e-12,\n\t     -9.400849094049688e-13,\n\t     -6.423305872147841e-13,\n\t     -2.382191739347918e-13,\n\t     ]\n\t];\n\n\tvar tantab_l = win[Encoder.SHORT_TYPE];\n\tvar cx = win[Encoder.SHORT_TYPE];\n\tvar ca = win[Encoder.SHORT_TYPE];\n\tvar cs = win[Encoder.SHORT_TYPE];\n\n\t/**\n\t * new IDCT routine written by Takehiro TOMINAGA\n\t *\n\t * PURPOSE: Overlapping window on PCM samples<BR>\n\t *\n\t * SEMANTICS:<BR>\n\t * 32 16-bit pcm samples are scaled to fractional 2's complement and\n\t * concatenated to the end of the window buffer #x#. The updated window\n\t * buffer #x# is then windowed by the analysis window #c# to produce the\n\t * windowed sample #z#\n\t */\n\tvar order = [\n\t    0, 1, 16, 17, 8, 9, 24, 25, 4, 5, 20, 21, 12, 13, 28, 29,\n\t    2, 3, 18, 19, 10, 11, 26, 27, 6, 7, 22, 23, 14, 15, 30, 31\n\t];\n\n\t/**\n\t * returns sum_j=0^31 a[j]*cos(PI*j*(k+1/2)/32), 0<=k<32\n\t */\n\tfunction window_subband(x1, x1Pos, a) {\n\t\tvar wp = 10;\n\n\t\tvar x2 = x1Pos + 238 - 14 - 286;\n\n\t\tfor (var i = -15; i < 0; i++) {\n\t\t\tvar w, s, t;\n\n\t\t\tw = enwindow[wp + -10];\n\t\t\ts = x1[x2 + -224] * w;\n\t\t\tt = x1[x1Pos + 224] * w;\n\t\t\tw = enwindow[wp + -9];\n\t\t\ts += x1[x2 + -160] * w;\n\t\t\tt += x1[x1Pos + 160] * w;\n\t\t\tw = enwindow[wp + -8];\n\t\t\ts += x1[x2 + -96] * w;\n\t\t\tt += x1[x1Pos + 96] * w;\n\t\t\tw = enwindow[wp + -7];\n\t\t\ts += x1[x2 + -32] * w;\n\t\t\tt += x1[x1Pos + 32] * w;\n\t\t\tw = enwindow[wp + -6];\n\t\t\ts += x1[x2 + 32] * w;\n\t\t\tt += x1[x1Pos + -32] * w;\n\t\t\tw = enwindow[wp + -5];\n\t\t\ts += x1[x2 + 96] * w;\n\t\t\tt += x1[x1Pos + -96] * w;\n\t\t\tw = enwindow[wp + -4];\n\t\t\ts += x1[x2 + 160] * w;\n\t\t\tt += x1[x1Pos + -160] * w;\n\t\t\tw = enwindow[wp + -3];\n\t\t\ts += x1[x2 + 224] * w;\n\t\t\tt += x1[x1Pos + -224] * w;\n\n\t\t\tw = enwindow[wp + -2];\n\t\t\ts += x1[x1Pos + -256] * w;\n\t\t\tt -= x1[x2 + 256] * w;\n\t\t\tw = enwindow[wp + -1];\n\t\t\ts += x1[x1Pos + -192] * w;\n\t\t\tt -= x1[x2 + 192] * w;\n\t\t\tw = enwindow[wp + 0];\n\t\t\ts += x1[x1Pos + -128] * w;\n\t\t\tt -= x1[x2 + 128] * w;\n\t\t\tw = enwindow[wp + 1];\n\t\t\ts += x1[x1Pos + -64] * w;\n\t\t\tt -= x1[x2 + 64] * w;\n\t\t\tw = enwindow[wp + 2];\n\t\t\ts += x1[x1Pos + 0] * w;\n\t\t\tt -= x1[x2 + 0] * w;\n\t\t\tw = enwindow[wp + 3];\n\t\t\ts += x1[x1Pos + 64] * w;\n\t\t\tt -= x1[x2 + -64] * w;\n\t\t\tw = enwindow[wp + 4];\n\t\t\ts += x1[x1Pos + 128] * w;\n\t\t\tt -= x1[x2 + -128] * w;\n\t\t\tw = enwindow[wp + 5];\n\t\t\ts += x1[x1Pos + 192] * w;\n\t\t\tt -= x1[x2 + -192] * w;\n\n\t\t\t/*\n\t\t\t * this multiplyer could be removed, but it needs more 256 FLOAT\n\t\t\t * data. thinking about the data cache performance, I think we\n\t\t\t * should not use such a huge table. tt 2000/Oct/25\n\t\t\t */\n\t\t\ts *= enwindow[wp + 6];\n\t\t\tw = t - s;\n\t\t\ta[30 + i * 2] = t + s;\n\t\t\ta[31 + i * 2] = enwindow[wp + 7] * w;\n\t\t\twp += 18;\n\t\t\tx1Pos--;\n\t\t\tx2++;\n\t\t}\n\t\t{\n\t\t\tvar s, t, u, v;\n\t\t\tt = x1[x1Pos + -16] * enwindow[wp + -10];\n\t\t\ts = x1[x1Pos + -32] * enwindow[wp + -2];\n\t\t\tt += (x1[x1Pos + -48] - x1[x1Pos + 16]) * enwindow[wp + -9];\n\t\t\ts += x1[x1Pos + -96] * enwindow[wp + -1];\n\t\t\tt += (x1[x1Pos + -80] + x1[x1Pos + 48]) * enwindow[wp + -8];\n\t\t\ts += x1[x1Pos + -160] * enwindow[wp + 0];\n\t\t\tt += (x1[x1Pos + -112] - x1[x1Pos + 80]) * enwindow[wp + -7];\n\t\t\ts += x1[x1Pos + -224] * enwindow[wp + 1];\n\t\t\tt += (x1[x1Pos + -144] + x1[x1Pos + 112]) * enwindow[wp + -6];\n\t\t\ts -= x1[x1Pos + 32] * enwindow[wp + 2];\n\t\t\tt += (x1[x1Pos + -176] - x1[x1Pos + 144]) * enwindow[wp + -5];\n\t\t\ts -= x1[x1Pos + 96] * enwindow[wp + 3];\n\t\t\tt += (x1[x1Pos + -208] + x1[x1Pos + 176]) * enwindow[wp + -4];\n\t\t\ts -= x1[x1Pos + 160] * enwindow[wp + 4];\n\t\t\tt += (x1[x1Pos + -240] - x1[x1Pos + 208]) * enwindow[wp + -3];\n\t\t\ts -= x1[x1Pos + 224];\n\n\t\t\tu = s - t;\n\t\t\tv = s + t;\n\n\t\t\tt = a[14];\n\t\t\ts = a[15] - t;\n\n\t\t\ta[31] = v + t; /* A0 */\n\t\t\ta[30] = u + s; /* A1 */\n\t\t\ta[15] = u - s; /* A2 */\n\t\t\ta[14] = v - t; /* A3 */\n\t\t}\n\t\t{\n\t\t\tvar xr;\n\t\t\txr = a[28] - a[0];\n\t\t\ta[0] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -2 * 18 + 7];\n\t\t\txr = a[29] - a[1];\n\t\t\ta[1] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -2 * 18 + 7];\n\n\t\t\txr = a[26] - a[2];\n\t\t\ta[2] += a[26];\n\t\t\ta[26] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[27] - a[3];\n\t\t\ta[3] += a[27];\n\t\t\ta[27] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = a[24] - a[4];\n\t\t\ta[4] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -6 * 18 + 7];\n\t\t\txr = a[25] - a[5];\n\t\t\ta[5] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -6 * 18 + 7];\n\n\t\t\txr = a[22] - a[6];\n\t\t\ta[6] += a[22];\n\t\t\ta[22] = xr * Util.SQRT2;\n\t\t\txr = a[23] - a[7];\n\t\t\ta[7] += a[23];\n\t\t\ta[23] = xr * Util.SQRT2 - a[7];\n\t\t\ta[7] -= a[6];\n\t\t\ta[22] -= a[7];\n\t\t\ta[23] -= a[22];\n\n\t\t\txr = a[6];\n\t\t\ta[6] = a[31] - xr;\n\t\t\ta[31] = a[31] + xr;\n\t\t\txr = a[7];\n\t\t\ta[7] = a[30] - xr;\n\t\t\ta[30] = a[30] + xr;\n\t\t\txr = a[22];\n\t\t\ta[22] = a[15] - xr;\n\t\t\ta[15] = a[15] + xr;\n\t\t\txr = a[23];\n\t\t\ta[23] = a[14] - xr;\n\t\t\ta[14] = a[14] + xr;\n\n\t\t\txr = a[20] - a[8];\n\t\t\ta[8] += a[20];\n\t\t\ta[20] = xr * enwindow[wp + -10 * 18 + 7];\n\t\t\txr = a[21] - a[9];\n\t\t\ta[9] += a[21];\n\t\t\ta[21] = xr * enwindow[wp + -10 * 18 + 7];\n\n\t\t\txr = a[18] - a[10];\n\t\t\ta[10] += a[18];\n\t\t\ta[18] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[19] - a[11];\n\t\t\ta[11] += a[19];\n\t\t\ta[19] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[16] - a[12];\n\t\t\ta[12] += a[16];\n\t\t\ta[16] = xr * enwindow[wp + -14 * 18 + 7];\n\t\t\txr = a[17] - a[13];\n\t\t\ta[13] += a[17];\n\t\t\ta[17] = xr * enwindow[wp + -14 * 18 + 7];\n\n\t\t\txr = -a[20] + a[24];\n\t\t\ta[20] += a[24];\n\t\t\ta[24] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = -a[21] + a[25];\n\t\t\ta[21] += a[25];\n\t\t\ta[25] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[4] - a[8];\n\t\t\ta[4] += a[8];\n\t\t\ta[8] = xr * enwindow[wp + -12 * 18 + 7];\n\t\t\txr = a[5] - a[9];\n\t\t\ta[5] += a[9];\n\t\t\ta[9] = xr * enwindow[wp + -12 * 18 + 7];\n\n\t\t\txr = a[0] - a[12];\n\t\t\ta[0] += a[12];\n\t\t\ta[12] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[1] - a[13];\n\t\t\ta[1] += a[13];\n\t\t\ta[13] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = a[16] - a[28];\n\t\t\ta[16] += a[28];\n\t\t\ta[28] = xr * enwindow[wp + -4 * 18 + 7];\n\t\t\txr = -a[17] + a[29];\n\t\t\ta[17] += a[29];\n\t\t\ta[29] = xr * enwindow[wp + -4 * 18 + 7];\n\n\t\t\txr = Util.SQRT2 * (a[2] - a[10]);\n\t\t\ta[2] += a[10];\n\t\t\ta[10] = xr;\n\t\t\txr = Util.SQRT2 * (a[3] - a[11]);\n\t\t\ta[3] += a[11];\n\t\t\ta[11] = xr;\n\t\t\txr = Util.SQRT2 * (-a[18] + a[26]);\n\t\t\ta[18] += a[26];\n\t\t\ta[26] = xr - a[18];\n\t\t\txr = Util.SQRT2 * (-a[19] + a[27]);\n\t\t\ta[19] += a[27];\n\t\t\ta[27] = xr - a[19];\n\n\t\t\txr = a[2];\n\t\t\ta[19] -= a[3];\n\t\t\ta[3] -= xr;\n\t\t\ta[2] = a[31] - xr;\n\t\t\ta[31] += xr;\n\t\t\txr = a[3];\n\t\t\ta[11] -= a[19];\n\t\t\ta[18] -= xr;\n\t\t\ta[3] = a[30] - xr;\n\t\t\ta[30] += xr;\n\t\t\txr = a[18];\n\t\t\ta[27] -= a[11];\n\t\t\ta[19] -= xr;\n\t\t\ta[18] = a[15] - xr;\n\t\t\ta[15] += xr;\n\n\t\t\txr = a[19];\n\t\t\ta[10] -= xr;\n\t\t\ta[19] = a[14] - xr;\n\t\t\ta[14] += xr;\n\t\t\txr = a[10];\n\t\t\ta[11] -= xr;\n\t\t\ta[10] = a[23] - xr;\n\t\t\ta[23] += xr;\n\t\t\txr = a[11];\n\t\t\ta[26] -= xr;\n\t\t\ta[11] = a[22] - xr;\n\t\t\ta[22] += xr;\n\t\t\txr = a[26];\n\t\t\ta[27] -= xr;\n\t\t\ta[26] = a[7] - xr;\n\t\t\ta[7] += xr;\n\n\t\t\txr = a[27];\n\t\t\ta[27] = a[6] - xr;\n\t\t\ta[6] += xr;\n\n\t\t\txr = Util.SQRT2 * (a[0] - a[4]);\n\t\t\ta[0] += a[4];\n\t\t\ta[4] = xr;\n\t\t\txr = Util.SQRT2 * (a[1] - a[5]);\n\t\t\ta[1] += a[5];\n\t\t\ta[5] = xr;\n\t\t\txr = Util.SQRT2 * (a[16] - a[20]);\n\t\t\ta[16] += a[20];\n\t\t\ta[20] = xr;\n\t\t\txr = Util.SQRT2 * (a[17] - a[21]);\n\t\t\ta[17] += a[21];\n\t\t\ta[21] = xr;\n\n\t\t\txr = -Util.SQRT2 * (a[8] - a[12]);\n\t\t\ta[8] += a[12];\n\t\t\ta[12] = xr - a[8];\n\t\t\txr = -Util.SQRT2 * (a[9] - a[13]);\n\t\t\ta[9] += a[13];\n\t\t\ta[13] = xr - a[9];\n\t\t\txr = -Util.SQRT2 * (a[25] - a[29]);\n\t\t\ta[25] += a[29];\n\t\t\ta[29] = xr - a[25];\n\t\t\txr = -Util.SQRT2 * (a[24] + a[28]);\n\t\t\ta[24] -= a[28];\n\t\t\ta[28] = xr - a[24];\n\n\t\t\txr = a[24] - a[16];\n\t\t\ta[24] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\n\t\t\txr = a[25] - a[17];\n\t\t\ta[25] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[17] - a[1];\n\t\t\ta[17] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[1] - a[0];\n\t\t\ta[1] = xr;\n\t\t\txr = a[16] - xr;\n\t\t\ta[16] = xr;\n\t\t\txr = a[17] - xr;\n\t\t\ta[17] = xr;\n\t\t\txr = a[8] - xr;\n\t\t\ta[8] = xr;\n\t\t\txr = a[9] - xr;\n\t\t\ta[9] = xr;\n\t\t\txr = a[24] - xr;\n\t\t\ta[24] = xr;\n\t\t\txr = a[25] - xr;\n\t\t\ta[25] = xr;\n\t\t\txr = a[4] - xr;\n\t\t\ta[4] = xr;\n\t\t\txr = a[5] - xr;\n\t\t\ta[5] = xr;\n\t\t\txr = a[20] - xr;\n\t\t\ta[20] = xr;\n\t\t\txr = a[21] - xr;\n\t\t\ta[21] = xr;\n\t\t\txr = a[12] - xr;\n\t\t\ta[12] = xr;\n\t\t\txr = a[13] - xr;\n\t\t\ta[13] = xr;\n\t\t\txr = a[28] - xr;\n\t\t\ta[28] = xr;\n\t\t\txr = a[29] - xr;\n\t\t\ta[29] = xr;\n\n\t\t\txr = a[0];\n\t\t\ta[0] += a[31];\n\t\t\ta[31] -= xr;\n\t\t\txr = a[1];\n\t\t\ta[1] += a[30];\n\t\t\ta[30] -= xr;\n\t\t\txr = a[16];\n\t\t\ta[16] += a[15];\n\t\t\ta[15] -= xr;\n\t\t\txr = a[17];\n\t\t\ta[17] += a[14];\n\t\t\ta[14] -= xr;\n\t\t\txr = a[8];\n\t\t\ta[8] += a[23];\n\t\t\ta[23] -= xr;\n\t\t\txr = a[9];\n\t\t\ta[9] += a[22];\n\t\t\ta[22] -= xr;\n\t\t\txr = a[24];\n\t\t\ta[24] += a[7];\n\t\t\ta[7] -= xr;\n\t\t\txr = a[25];\n\t\t\ta[25] += a[6];\n\t\t\ta[6] -= xr;\n\t\t\txr = a[4];\n\t\t\ta[4] += a[27];\n\t\t\ta[27] -= xr;\n\t\t\txr = a[5];\n\t\t\ta[5] += a[26];\n\t\t\ta[26] -= xr;\n\t\t\txr = a[20];\n\t\t\ta[20] += a[11];\n\t\t\ta[11] -= xr;\n\t\t\txr = a[21];\n\t\t\ta[21] += a[10];\n\t\t\ta[10] -= xr;\n\t\t\txr = a[12];\n\t\t\ta[12] += a[19];\n\t\t\ta[19] -= xr;\n\t\t\txr = a[13];\n\t\t\ta[13] += a[18];\n\t\t\ta[18] -= xr;\n\t\t\txr = a[28];\n\t\t\ta[28] += a[3];\n\t\t\ta[3] -= xr;\n\t\t\txr = a[29];\n\t\t\ta[29] += a[2];\n\t\t\ta[2] -= xr;\n\t\t}\n\t}\n\n\t/**\n\t * Function: Calculation of the MDCT In the case of long blocks (type 0,1,3)\n\t * there are 36 coefficents in the time domain and 18 in the frequency\n\t * domain.<BR>\n\t * In the case of short blocks (type 2) there are 3 transformations with\n\t * short length. This leads to 12 coefficents in the time and 6 in the\n\t * frequency domain. In this case the results are stored side by side in the\n\t * vector out[].\n\t *\n\t * New layer3\n\t */\n\tfunction mdct_short(inout, inoutPos) {\n\t\tfor (var l = 0; l < 3; l++) {\n\t\t\tvar tc0, tc1, tc2, ts0, ts1, ts2;\n\n\t\t\tts0 = inout[inoutPos + 2 * 3] * win[Encoder.SHORT_TYPE][0]\n\t\t\t\t\t- inout[inoutPos + 5 * 3];\n\t\t\ttc0 = inout[inoutPos + 0 * 3] * win[Encoder.SHORT_TYPE][2]\n\t\t\t\t\t- inout[inoutPos + 3 * 3];\n\t\t\ttc1 = ts0 + tc0;\n\t\t\ttc2 = ts0 - tc0;\n\n\t\t\tts0 = inout[inoutPos + 5 * 3] * win[Encoder.SHORT_TYPE][0]\n\t\t\t\t\t+ inout[inoutPos + 2 * 3];\n\t\t\ttc0 = inout[inoutPos + 3 * 3] * win[Encoder.SHORT_TYPE][2]\n\t\t\t\t\t+ inout[inoutPos + 0 * 3];\n\t\t\tts1 = ts0 + tc0;\n\t\t\tts2 = -ts0 + tc0;\n\n\t\t\ttc0 = (inout[inoutPos + 1 * 3] * win[Encoder.SHORT_TYPE][1] - inout[inoutPos + 4 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tts0 = (inout[inoutPos + 4 * 3] * win[Encoder.SHORT_TYPE][1] + inout[inoutPos + 1 * 3]) * 2.069978111953089e-11;\n\t\t\t/*\n\t\t\t * tritab_s [ 1 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 0] = tc1 * 1.907525191737280e-11 + tc0;\n\t\t\t/*\n\t\t\t * tritab_s[ 2 ]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 5] = -ts1 * 1.907525191737280e-11 + ts0;\n\t\t\t/*\n\t\t\t * tritab_s[0 ]\n\t\t\t */\n\t\t\ttc2 = tc2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 2]\n\t\t\t */\n\t\t\tts1 = ts1 * 0.5 * 1.907525191737281e-11 + ts0;\n\t\t\tinout[inoutPos + 3 * 1] = tc2 - ts1;\n\t\t\tinout[inoutPos + 3 * 2] = tc2 + ts1;\n\n\t\t\ttc1 = tc1 * 0.5 * 1.907525191737281e-11 - tc0;\n\t\t\tts2 = ts2 * 0.86602540378443870761 * 1.907525191737281e-11;\n\t\t\t/*\n\t\t\t * tritab_s[ 0]\n\t\t\t */\n\t\t\tinout[inoutPos + 3 * 3] = tc1 + ts2;\n\t\t\tinout[inoutPos + 3 * 4] = tc1 - ts2;\n\n\t\t\tinoutPos++;\n\t\t}\n\t}\n\n\tfunction mdct_long(out, outPos, _in) {\n\t\tvar ct, st;\n\t\t{\n\t\t\tvar tc1, tc2, tc3, tc4, ts5, ts6, ts7, ts8;\n\t\t\t/* 1,2, 5,6, 9,10, 13,14, 17 */\n\t\t\ttc1 = _in[17] - _in[9];\n\t\t\ttc3 = _in[15] - _in[11];\n\t\t\ttc4 = _in[14] - _in[12];\n\t\t\tts5 = _in[0] + _in[8];\n\t\t\tts6 = _in[1] + _in[7];\n\t\t\tts7 = _in[2] + _in[6];\n\t\t\tts8 = _in[3] + _in[5];\n\n\t\t\tout[outPos + 17] = (ts5 + ts7 - ts8) - (ts6 - _in[4]);\n\t\t\tst = (ts5 + ts7 - ts8) * cx[12 + 7] + (ts6 - _in[4]);\n\t\t\tct = (tc1 - tc3 - tc4) * cx[12 + 6];\n\t\t\tout[outPos + 5] = ct + st;\n\t\t\tout[outPos + 6] = ct - st;\n\n\t\t\ttc2 = (_in[16] - _in[10]) * cx[12 + 6];\n\t\t\tts6 = ts6 * cx[12 + 7] + _in[4];\n\t\t\tct = tc1 * cx[12 + 0] + tc2 + tc3 * cx[12 + 1] + tc4 * cx[12 + 2];\n\t\t\tst = -ts5 * cx[12 + 4] + ts6 - ts7 * cx[12 + 5] + ts8 * cx[12 + 3];\n\t\t\tout[outPos + 1] = ct + st;\n\t\t\tout[outPos + 2] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 1] - tc2 - tc3 * cx[12 + 2] + tc4 * cx[12 + 0];\n\t\t\tst = -ts5 * cx[12 + 5] + ts6 - ts7 * cx[12 + 3] + ts8 * cx[12 + 4];\n\t\t\tout[outPos + 9] = ct + st;\n\t\t\tout[outPos + 10] = ct - st;\n\n\t\t\tct = tc1 * cx[12 + 2] - tc2 + tc3 * cx[12 + 0] - tc4 * cx[12 + 1];\n\t\t\tst = ts5 * cx[12 + 3] - ts6 + ts7 * cx[12 + 4] - ts8 * cx[12 + 5];\n\t\t\tout[outPos + 13] = ct + st;\n\t\t\tout[outPos + 14] = ct - st;\n\t\t}\n\t\t{\n\t\t\tvar ts1, ts2, ts3, ts4, tc5, tc6, tc7, tc8;\n\n\t\t\tts1 = _in[8] - _in[0];\n\t\t\tts3 = _in[6] - _in[2];\n\t\t\tts4 = _in[5] - _in[3];\n\t\t\ttc5 = _in[17] + _in[9];\n\t\t\ttc6 = _in[16] + _in[10];\n\t\t\ttc7 = _in[15] + _in[11];\n\t\t\ttc8 = _in[14] + _in[12];\n\n\t\t\tout[outPos + 0] = (tc5 + tc7 + tc8) + (tc6 + _in[13]);\n\t\t\tct = (tc5 + tc7 + tc8) * cx[12 + 7] - (tc6 + _in[13]);\n\t\t\tst = (ts1 - ts3 + ts4) * cx[12 + 6];\n\t\t\tout[outPos + 11] = ct + st;\n\t\t\tout[outPos + 12] = ct - st;\n\n\t\t\tts2 = (_in[7] - _in[1]) * cx[12 + 6];\n\t\t\ttc6 = _in[13] - tc6 * cx[12 + 7];\n\t\t\tct = tc5 * cx[12 + 3] - tc6 + tc7 * cx[12 + 4] + tc8 * cx[12 + 5];\n\t\t\tst = ts1 * cx[12 + 2] + ts2 + ts3 * cx[12 + 0] + ts4 * cx[12 + 1];\n\t\t\tout[outPos + 3] = ct + st;\n\t\t\tout[outPos + 4] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 5] + tc6 - tc7 * cx[12 + 3] - tc8 * cx[12 + 4];\n\t\t\tst = ts1 * cx[12 + 1] + ts2 - ts3 * cx[12 + 2] - ts4 * cx[12 + 0];\n\t\t\tout[outPos + 7] = ct + st;\n\t\t\tout[outPos + 8] = ct - st;\n\n\t\t\tct = -tc5 * cx[12 + 4] + tc6 - tc7 * cx[12 + 5] - tc8 * cx[12 + 3];\n\t\t\tst = ts1 * cx[12 + 0] - ts2 + ts3 * cx[12 + 1] - ts4 * cx[12 + 2];\n\t\t\tout[outPos + 15] = ct + st;\n\t\t\tout[outPos + 16] = ct - st;\n\t\t}\n\t}\n\n\tthis.mdct_sub48 = function(gfc, w0, w1) {\n\t\tvar wk = w0;\n\t\tvar wkPos = 286;\n\t\t/* thinking cache performance, ch->gr loop is better than gr->ch loop */\n\t\tfor (var ch = 0; ch < gfc.channels_out; ch++) {\n\t\t\tfor (var gr = 0; gr < gfc.mode_gr; gr++) {\n\t\t\t\tvar band;\n\t\t\t\tvar gi = (gfc.l3_side.tt[gr][ch]);\n\t\t\t\tvar mdct_enc = gi.xr;\n\t\t\t\tvar mdct_encPos = 0;\n\t\t\t\tvar samp = gfc.sb_sample[ch][1 - gr];\n\t\t\t\tvar sampPos = 0;\n\n\t\t\t\tfor (var k = 0; k < 18 / 2; k++) {\n\t\t\t\t\twindow_subband(wk, wkPos, samp[sampPos]);\n\t\t\t\t\twindow_subband(wk, wkPos + 32, samp[sampPos + 1]);\n\t\t\t\t\tsampPos += 2;\n\t\t\t\t\twkPos += 64;\n\t\t\t\t\t/*\n\t\t\t\t\t * Compensate for inversion in the analysis filter\n\t\t\t\t\t */\n\t\t\t\t\tfor (band = 1; band < 32; band += 2) {\n\t\t\t\t\t\tsamp[sampPos - 1][band] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Perform imdct of 18 previous subband samples + 18 current\n\t\t\t\t * subband samples\n\t\t\t\t */\n\t\t\t\tfor (band = 0; band < 32; band++, mdct_encPos += 18) {\n\t\t\t\t\tvar type = gi.block_type;\n\t\t\t\t\tvar band0 = gfc.sb_sample[ch][gr];\n\t\t\t\t\tvar band1 = gfc.sb_sample[ch][1 - gr];\n\t\t\t\t\tif (gi.mixed_block_flag != 0 && band < 2)\n\t\t\t\t\t\ttype = 0;\n\t\t\t\t\tif (gfc.amp_filter[band] < 1e-12) {\n\t\t\t\t\t\tArrays.fill(mdct_enc, mdct_encPos + 0,\n\t\t\t\t\t\t\t\tmdct_encPos + 18, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (gfc.amp_filter[band] < 1.0) {\n\t\t\t\t\t\t\tfor (var k = 0; k < 18; k++)\n\t\t\t\t\t\t\t\tband1[k][order[band]] *= gfc.amp_filter[band];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type == Encoder.SHORT_TYPE) {\n\t\t\t\t\t\t\tfor (var k = -NS / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar w = win[Encoder.SHORT_TYPE][k + 3];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 9] = band0[9 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 18] = band0[14 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band0[15 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 10] = band0[15 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band0[14 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 19] = band1[2 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[3 + k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 11] = band1[3 + k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w - band1[2 - k][order[band]];\n\t\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k * 3 + 20] = band1[8 - k][order[band]]\n\t\t\t\t\t\t\t\t\t\t* w + band1[9 + k][order[band]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmdct_short(mdct_enc, mdct_encPos);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar work = new_float(18);\n\t\t\t\t\t\t\tfor (var k = -NL / 4; k < 0; k++) {\n\t\t\t\t\t\t\t\tvar a, b;\n\t\t\t\t\t\t\t\ta = win[type][k + 27]\n\t\t\t\t\t\t\t\t\t\t* band1[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t+ win[type][k + 36]\n\t\t\t\t\t\t\t\t\t\t* band1[8 - k][order[band]];\n\t\t\t\t\t\t\t\tb = win[type][k + 9]\n\t\t\t\t\t\t\t\t\t\t* band0[k + 9][order[band]]\n\t\t\t\t\t\t\t\t\t\t- win[type][k + 18]\n\t\t\t\t\t\t\t\t\t\t* band0[8 - k][order[band]];\n\t\t\t\t\t\t\t\twork[k + 9] = a - b * tantab_l[3 + k + 9];\n\t\t\t\t\t\t\t\twork[k + 18] = a * tantab_l[3 + k + 9] + b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmdct_long(mdct_enc, mdct_encPos, work);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * Perform aliasing reduction butterfly\n\t\t\t\t\t */\n\t\t\t\t\tif (type != Encoder.SHORT_TYPE && band != 0) {\n\t\t\t\t\t\tfor (var k = 7; k >= 0; --k) {\n\t\t\t\t\t\t\tvar bu, bd;\n\t\t\t\t\t\t\tbu = mdct_enc[mdct_encPos + k] * ca[20 + k]\n\t\t\t\t\t\t\t\t\t+ mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* cs[28 + k];\n\t\t\t\t\t\t\tbd = mdct_enc[mdct_encPos + k] * cs[28 + k]\n\t\t\t\t\t\t\t\t\t- mdct_enc[mdct_encPos + -1 - k]\n\t\t\t\t\t\t\t\t\t* ca[20 + k];\n\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + -1 - k] = bu;\n\t\t\t\t\t\t\tmdct_enc[mdct_encPos + k] = bd;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twk = w1;\n\t\t\twkPos = 286;\n\t\t\tif (gfc.mode_gr == 1) {\n\t\t\t\tfor (var i = 0; i < 18; i++) {\n\t\t\t\t\tSystem.arraycopy(gfc.sb_sample[ch][1][i], 0,\n\t\t\t\t\t\t\tgfc.sb_sample[ch][0][i], 0, 32);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { NewMDCT };\n","import { Encoder } from './Encoder.js';\nimport * as common from './common.js';\nconst { System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte, new_double, new_float, new_float_n, new_int, new_int_n, assert } = common;\n\nclass III_psy_xmin {\n    constructor() {\n        this.l = new_float(Encoder.SBMAX_l);\n        this.s = new_float_n([Encoder.SBMAX_s, 3]);\n    }\n\n    assign(iii_psy_xmin) {\n        System.arraycopy(iii_psy_xmin.l, 0, this.l, 0, Encoder.SBMAX_l);\n        for (var i = 0; i < Encoder.SBMAX_s; i++) {\n            for (var j = 0; j < 3; j++) {\n                this.s[i][j] = iii_psy_xmin.s[i][j];\n            }\n        }\n    }\n}\n\nexport { III_psy_xmin };\n","//package mp3;\n\nimport { III_psy_xmin } from './III_psy_xmin.js';\n\nclass III_psy_ratio {\n\tconstructor() {\n\t\tthis.thm = new III_psy_xmin();\n\t\tthis.en = new III_psy_xmin();\n\t}\n}\n\nexport { III_psy_ratio };\n","//package mp3;\n\n/* MPEG modes */\nfunction MPEGMode(ordinal) {\n    var _ordinal = ordinal;\n    this.ordinal = function () {\n        return _ordinal;\n    }\n}\n\nMPEGMode.STEREO = new MPEGMode(0);\nMPEGMode.JOINT_STEREO = new MPEGMode(1);\nMPEGMode.DUAL_CHANNEL = new MPEGMode(2);\nMPEGMode.MONO = new MPEGMode(3);\nMPEGMode.NOT_SET = new MPEGMode(4);\n\nexport { MPEGMode };\n","import { SBMAX_s} from './Encoder.js';\n\nclass L3Side {\n\t/**\n\t * max scalefactor band, max(SBMAX_l, SBMAX_s*3, (SBMAX_s-3)*3+8)\n\t */\n\tstatic SFBMAX = (SBMAX_s * 3);\n}\n\nexport { L3Side };\n","/**\n * @fileoverview Core MP3 frame encoding logic for LAME.\n * Ported from encoder.c. Handles MDCT, psychoacoustic model interaction,\n * quantization loop selection, and bitstream formatting for a single frame.\n * Uses ES Module syntax.\n *\n * @module Encoder\n */\n\n// Import necessary modules using ES Module syntax\nimport * as common from './common.js';\nimport { NewMDCT } from './NewMDCT.js';\nimport { III_psy_ratio } from './III_psy_ratio.js';\nimport { MPEGMode } from './MPEGMode.js';\nimport { L3Side } from './L3Side.js'; // Contains SideInfo structure\nimport { VbrMode } from './common.js'; // Import VbrMode for comparison\n\n// Assuming these types are defined elsewhere and imported if needed\n/** @typedef {import('./BitStream.js').BitStream} BitStream */\n/** @typedef {import('./PsyModel.js').PsyModel} PsyModel */\n/** @typedef {import('./QuantizePVT.js').QuantizePVT} QuantizePVT */\n/** @typedef {import('./VBRTag.js').default} VBRTag */\n/** @typedef {import('./LameGlobalFlags.js').default} LameGlobalFlags */\n/** @typedef {import('./LameInternalFlags.js').default} LameInternalFlags */\n\n// Destructure common utilities for easier access\nconst {\n    Float, ShortBlock, Util, Arrays, new_array_n, new_byte,\n    new_float, new_float_n, new_int, new_int_n, assert\n} = common;\n\n/**\n * @classdesc Contains the core logic for encoding a single MP3 frame,\n * coordinating the MDCT, psychoacoustic analysis, quantization, and bitstream writing.\n * @constructs Encoder\n */\nclass Encoder {\n    // --- Static Constants ---\n    static ENCDELAY = 576;\n    static POSTDELAY = Encoder.ENCDELAY + 1152 - 576 - 1;\n    static MDCTDELAY = 48;\n    static FFTOFFSET = (224 + Encoder.MDCTDELAY);\n    static DECDELAY = 528;\n    static SBLIMIT = 32;\n    static CBANDS = 64;\n    static SBPSY_l = 21;\n    static SBPSY_s = 12;\n    static SBMAX_l = 22;\n    static SBMAX_s = 13;\n    static PSFB21 = 6;\n    static PSFB12 = 6;\n    static BLKSIZE = 1024;\n    static HBLKSIZE = (Encoder.BLKSIZE / 2 + 1);\n    static BLKSIZE_s = 256;\n    static HBLKSIZE_s = (Encoder.BLKSIZE_s / 2 + 1);\n    static NORM_TYPE = 0;\n    static START_TYPE = 1;\n    static SHORT_TYPE = 2;\n    static STOP_TYPE = 3;\n    static MPG_MD_LR_LR = 0;\n    static MPG_MD_LR_I = 1;\n    static MPG_MD_MS_LR = 2;\n    static MPG_MD_MS_I = 3;\n    static fircoef = [-0.0207887 * 5, -0.0378413 * 5, -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5, 0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\n\n    /** @private @type {BitStream|null} */\n    bs = null;\n    /** @private @type {PsyModel|null} */\n    psy = null;\n    /** @private @type {VBRTag|null} */\n    vbr = null;\n    /** @private @type {QuantizePVT|null} */\n    qupvt = null;\n    /** @private @type {NewMDCT} */\n    newMDCT;\n\n    constructor() {\n        /** @private */\n        this.newMDCT = new NewMDCT();\n    }\n\n    /**\n     * Sets the internal module dependencies.\n     * @public\n     * @param {BitStream} _bs\n     * @param {PsyModel} _psy\n     * @param {QuantizePVT} _qupvt\n     * @param {VBRTag} _vbr\n     */\n    setModules(_bs, _psy, _qupvt, _vbr) {\n        this.bs = _bs;\n        this.psy = _psy;\n        this.qupvt = _qupvt;\n        this.vbr = _vbr;\n    }\n\n    // --- Private Helper Methods ---\n    // ... ( _adjust_ATH, _updateStats, _lame_encode_frame_init methods remain the same ) ...\n    /** @private */\n    _adjust_ATH(gfc) { /* ... */ }\n    /** @private */\n    _updateStats(gfc) { /* ... */ }\n    /** @private */\n    _lame_encode_frame_init(gfp, inbuf) { /* ... */ }\n\n\n    // --- Public Methods ---\n\n    /**\n     * Encodes a single MP3 frame.\n     * Takes PCM data (after potential resampling and buffering), performs\n     * psychoacoustic analysis, MDCT, quantization (via iteration loop),\n     * and formats the bitstream.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Float32Array} inbuf_l - Left channel PCM data for the frame + overlap.\n     * @param {Float32Array} inbuf_r - Right channel PCM data (or copy of left for mono).\n     * @param {Uint8Array} mp3buf - Output buffer for the encoded MP3 frame data.\n     * @param {number} mp3bufPos - Starting position offset within `mp3buf`.\n     * @param {number} mp3buf_size - Available size in `mp3buf` from `mp3bufPos`.\n     * @returns {number} The number of bytes written to `mp3buf` for this frame, or a negative error code.\n     */\n    lame_encode_mp3_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        // ... (Implementation remains the same as before) ...\n        let mp3count;\n        const masking_LR = [ [new III_psy_ratio(), new III_psy_ratio()], [new III_psy_ratio(), new III_psy_ratio()] ];\n        const masking_MS = [ [new III_psy_ratio(), new III_psy_ratio()], [new III_psy_ratio(), new III_psy_ratio()] ];\n        let masking;\n        const inbuf = [inbuf_l, inbuf_r];\n        const gfc = gfp.internal_flags;\n        const ms_ener_ratio = new_float(2);\n        const pe = new_float_n([2, 2]);\n        const pe_MS = new_float_n([2, 2]);\n        let pe_use;\n        let ch, gr;\n\n        if (gfc.lame_encode_frame_init === 0) {\n            this._lame_encode_frame_init(gfp, inbuf);\n        }\n        gfc.padding = 0;\n        if (gfc.frac_SpF > 1e-9) { gfc.slot_lag -= gfc.frac_SpF; if (gfc.slot_lag < 0) { gfc.slot_lag += gfp.out_samplerate; gfc.padding = 1; } }\n\n        if (gfc.psymodel !== 0) {\n            let ret; const bufp = [null, null]; const blocktype = new_int(2);\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                const bufpPos = 576 + gr * 576 - Encoder.FFTOFFSET;\n                bufp[0] = inbuf[0].subarray(bufpPos); if (gfc.channels_out === 2) bufp[1] = inbuf[1].subarray(bufpPos);\n                if (gfp.VBR === VbrMode.vbr_mtrh || gfp.VBR === VbrMode.vbr_mt) { ret = this.psy.L3psycho_anal_vbr(gfp, bufp, 0, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], gfc.tot_ener, blocktype); }\n                else { ret = this.psy.L3psycho_anal_ns(gfp, bufp, 0, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], gfc.tot_ener, blocktype); }\n                if (ret !== 0) return -4;\n                if (gfp.mode === MPEGMode.JOINT_STEREO) { const total_ms_energy = gfc.tot_ener[2] + gfc.tot_ener[3]; if(total_ms_energy > 0) { ms_ener_ratio[gr] = gfc.tot_ener[3] / total_ms_energy; } else { ms_ener_ratio[gr] = 0.5; } }\n                for (ch = 0; ch < gfc.channels_out; ch++) { const cod_info = gfc.l3_side.tt[gr][ch]; cod_info.block_type = blocktype[ch]; cod_info.mixed_block_flag = 0; }\n            }\n        } else { for (gr = 0; gr < gfc.mode_gr; gr++) { for (ch = 0; ch < gfc.channels_out; ch++) { gfc.l3_side.tt[gr][ch].block_type = Encoder.NORM_TYPE; gfc.l3_side.tt[gr][ch].mixed_block_flag = 0; pe_MS[gr][ch] = pe[gr][ch] = 700; } } }\n        this._adjust_ATH(gfc);\n        this.newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n        gfc.mode_ext = Encoder.MPG_MD_LR_LR;\n        if (gfp.force_ms) { gfc.mode_ext = Encoder.MPG_MD_MS_LR; }\n        else if (gfp.mode === MPEGMode.JOINT_STEREO && gfc.channels_out == 2) {\n            let sum_pe_MS = 0.0; let sum_pe_LR = 0.0;\n            for (gr = 0; gr < gfc.mode_gr; gr++) { sum_pe_MS += pe_MS[gr][0] + pe_MS[gr][1]; sum_pe_LR += pe[gr][0] + pe[gr][1]; }\n            if (sum_pe_MS <= 1.00 * sum_pe_LR) { const types_match_gr0 = (gfc.l3_side.tt[0][0].block_type === gfc.l3_side.tt[0][1].block_type); const types_match_gr1 = (gfc.mode_gr === 1) || (gfc.l3_side.tt[1][0].block_type === gfc.l3_side.tt[1][1].block_type); if(types_match_gr0 && types_match_gr1) { gfc.mode_ext = Encoder.MPG_MD_MS_LR; } }\n        }\n        if (gfc.mode_ext === Encoder.MPG_MD_MS_LR) { masking = masking_MS; pe_use = pe_MS; } else { masking = masking_LR; pe_use = pe; }\n        if (gfp.analysis && gfc.pinfo != null) { /* ... copy pinfo data ... */ }\n        if (gfp.VBR === VbrMode.vbr_off || gfp.VBR === VbrMode.vbr_abr) {\n            let f = 0.0; for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) f += pe_use[gr][ch];\n            for (let i = 0; i < 18; i++) gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1]; gfc.nsPsy.pefirbuf[18] = f;\n            f = gfc.nsPsy.pefirbuf[9]; for (let i = 0; i < 9; i++) f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i]) * Encoder.fircoef[i];\n            const target_avg_pe = (670 * 5 * gfc.mode_gr * gfc.channels_out); if (f !== 0) f = target_avg_pe / f; else f = 1.0;\n            for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) pe_use[gr][ch] *= f;\n        }\n        gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n        this.bs.format_bitstream(gfp);\n        mp3count = this.bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n        if (mp3count < 0) return mp3count;\n        if (gfp.bWriteVbrTag) { /* this.vbr.addVbrFrame(gfp); */ }\n        if (gfp.analysis && gfc.pinfo != null) { /* ... copy pinfo data ... */ }\n        this._updateStats(gfc);\n        return mp3count;\n    }\n\n} // End class Encoder\n\n// --- Exports ---\n// Export the class itself\nexport { Encoder };\nexport default Encoder;\n\n// Export the constants needed by other modules\nexport const ENCDELAY = Encoder.ENCDELAY;\nexport const POSTDELAY = Encoder.POSTDELAY;\nexport const MDCTDELAY = Encoder.MDCTDELAY;\nexport const FFTOFFSET = Encoder.FFTOFFSET;\nexport const DECDELAY = Encoder.DECDELAY;\nexport const SBLIMIT = Encoder.SBLIMIT;\nexport const CBANDS = Encoder.CBANDS;\nexport const SBPSY_l = Encoder.SBPSY_l;\nexport const SBPSY_s = Encoder.SBPSY_s;\nexport const SBMAX_l = Encoder.SBMAX_l;\nexport const SBMAX_s = Encoder.SBMAX_s;\nexport const PSFB21 = Encoder.PSFB21;\nexport const PSFB12 = Encoder.PSFB12;\nexport const BLKSIZE = Encoder.BLKSIZE;\nexport const HBLKSIZE = Encoder.HBLKSIZE;\nexport const BLKSIZE_s = Encoder.BLKSIZE_s;\nexport const HBLKSIZE_s = Encoder.HBLKSIZE_s;\nexport const NORM_TYPE = Encoder.NORM_TYPE;\nexport const START_TYPE = Encoder.START_TYPE;\nexport const SHORT_TYPE = Encoder.SHORT_TYPE;\nexport const STOP_TYPE = Encoder.STOP_TYPE;\nexport const MPG_MD_LR_LR = Encoder.MPG_MD_LR_LR;\nexport const MPG_MD_LR_I = Encoder.MPG_MD_LR_I;\nexport const MPG_MD_MS_LR = Encoder.MPG_MD_MS_LR;\nexport const MPG_MD_MS_I = Encoder.MPG_MD_MS_I;\n// fircoef is likely internal, not needed for export","function HuffCodeTab(len, max, tab, hl) {\n    this.xlen = len;\n    this.linmax = max;\n    this.table = tab;\n    this.hlen = hl;\n}\n\nvar Tables = {};\n\n\nTables.t1HB = [\n    1, 1,\n    1, 0\n];\n\nTables.t2HB = [\n    1, 2, 1,\n    3, 1, 1,\n    3, 2, 0\n];\n\nTables.t3HB = [\n    3, 2, 1,\n    1, 1, 1,\n    3, 2, 0\n];\n\nTables.t5HB = [\n    1, 2, 6, 5,\n    3, 1, 4, 4,\n    7, 5, 7, 1,\n    6, 1, 1, 0\n];\n\nTables.t6HB = [\n    7, 3, 5, 1,\n    6, 2, 3, 2,\n    5, 4, 4, 1,\n    3, 3, 2, 0\n];\n\nTables.t7HB = [\n    1, 2, 10, 19, 16, 10,\n    3, 3, 7, 10, 5, 3,\n    11, 4, 13, 17, 8, 4,\n    12, 11, 18, 15, 11, 2,\n    7, 6, 9, 14, 3, 1,\n    6, 4, 5, 3, 2, 0\n];\n\nTables.t8HB = [\n    3, 4, 6, 18, 12, 5,\n    5, 1, 2, 16, 9, 3,\n    7, 3, 5, 14, 7, 3,\n    19, 17, 15, 13, 10, 4,\n    13, 5, 8, 11, 5, 1,\n    12, 4, 4, 1, 1, 0\n];\n\nTables.t9HB = [\n    7, 5, 9, 14, 15, 7,\n    6, 4, 5, 5, 6, 7,\n    7, 6, 8, 8, 8, 5,\n    15, 6, 9, 10, 5, 1,\n    11, 7, 9, 6, 4, 1,\n    14, 4, 6, 2, 6, 0\n];\n\nTables.t10HB = [\n    1, 2, 10, 23, 35, 30, 12, 17,\n    3, 3, 8, 12, 18, 21, 12, 7,\n    11, 9, 15, 21, 32, 40, 19, 6,\n    14, 13, 22, 34, 46, 23, 18, 7,\n    20, 19, 33, 47, 27, 22, 9, 3,\n    31, 22, 41, 26, 21, 20, 5, 3,\n    14, 13, 10, 11, 16, 6, 5, 1,\n    9, 8, 7, 8, 4, 4, 2, 0\n];\n\nTables.t11HB = [\n    3, 4, 10, 24, 34, 33, 21, 15,\n    5, 3, 4, 10, 32, 17, 11, 10,\n    11, 7, 13, 18, 30, 31, 20, 5,\n    25, 11, 19, 59, 27, 18, 12, 5,\n    35, 33, 31, 58, 30, 16, 7, 5,\n    28, 26, 32, 19, 17, 15, 8, 14,\n    14, 12, 9, 13, 14, 9, 4, 1,\n    11, 4, 6, 6, 6, 3, 2, 0\n];\n\nTables.t12HB = [\n    9, 6, 16, 33, 41, 39, 38, 26,\n    7, 5, 6, 9, 23, 16, 26, 11,\n    17, 7, 11, 14, 21, 30, 10, 7,\n    17, 10, 15, 12, 18, 28, 14, 5,\n    32, 13, 22, 19, 18, 16, 9, 5,\n    40, 17, 31, 29, 17, 13, 4, 2,\n    27, 12, 11, 15, 10, 7, 4, 1,\n    27, 12, 8, 12, 6, 3, 1, 0\n];\n\nTables.t13HB = [\n    1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19,\n    3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14,\n    15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16,\n    22, 20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14,\n    35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24,\n    58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17,\n    47, 45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15,\n    72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42,\n    43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16,\n    53, 25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11,\n    35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22,\n    53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7,\n    34, 32, 28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5,\n    45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3,\n    48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2,\n    16, 15, 17, 27, 25, 20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1\n];\n\nTables.t15HB = [\n    7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63,\n    13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36,\n    19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 33,\n    29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29,\n    52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27,\n    77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,\n    125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30,\n    109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25,\n    90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,\n    71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15,\n    109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9,\n    86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11,\n    118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7,\n    91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3,\n    123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1,\n    71, 37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0\n];\n\nTables.t16HB = [\n    1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17,\n    3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9,\n    15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 110, 209, 206, 16,\n    45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26,\n    75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9,\n    66, 30, 59, 56, 102, 185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16,\n    111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10,\n    98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372, 380, 889, 884, 8,\n    85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7,\n    154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11,\n    139, 129, 67, 125, 247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4,\n    243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6,\n    202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 443, 707, 440, 437, 1728, 4,\n    747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2,\n    377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 0,\n    12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3\n];\n\nTables.t24HB = [\n    15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88,\n    14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42,\n    47, 22, 41, 74, 68, 128, 120, 221, 207, 194, 182, 340, 315, 295, 541, 18,\n    81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16,\n    147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 540, 14,\n    263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12,\n    249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10,\n    435, 115, 111, 109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17,\n    427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16,\n    335, 199, 197, 191, 189, 181, 174, 333, 321, 305, 289, 275, 521, 379, 371, 11,\n    668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10,\n    652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 368, 362, 6,\n    648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4,\n    620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2,\n    1033, 280, 278, 274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0,\n    43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3\n];\n\nTables.t32HB = [\n    1 << 0, 5 << 1, 4 << 1, 5 << 2, 6 << 1, 5 << 2, 4 << 2, 4 << 3,\n    7 << 1, 3 << 2, 6 << 2, 0 << 3, 7 << 2, 2 << 3, 3 << 3, 1 << 4\n];\n\nTables.t33HB = [\n    15 << 0, 14 << 1, 13 << 1, 12 << 2, 11 << 1, 10 << 2, 9 << 2, 8 << 3,\n    7 << 1, 6 << 2, 5 << 2, 4 << 3, 3 << 2, 2 << 3, 1 << 3, 0 << 4\n];\n\nTables.t1l = [\n    1, 4,\n    3, 5\n];\n\nTables.t2l = [\n    1, 4, 7,\n    4, 5, 7,\n    6, 7, 8\n];\n\nTables.t3l = [\n    2, 3, 7,\n    4, 4, 7,\n    6, 7, 8\n];\n\nTables.t5l = [\n    1, 4, 7, 8,\n    4, 5, 8, 9,\n    7, 8, 9, 10,\n    8, 8, 9, 10\n];\n\nTables.t6l = [\n    3, 4, 6, 8,\n    4, 4, 6, 7,\n    5, 6, 7, 8,\n    7, 7, 8, 9\n];\n\nTables.t7l = [\n    1, 4, 7, 9, 9, 10,\n    4, 6, 8, 9, 9, 10,\n    7, 7, 9, 10, 10, 11,\n    8, 9, 10, 11, 11, 11,\n    8, 9, 10, 11, 11, 12,\n    9, 10, 11, 12, 12, 12\n];\n\nTables.t8l = [\n    2, 4, 7, 9, 9, 10,\n    4, 4, 6, 10, 10, 10,\n    7, 6, 8, 10, 10, 11,\n    9, 10, 10, 11, 11, 12,\n    9, 9, 10, 11, 12, 12,\n    10, 10, 11, 11, 13, 13\n];\n\nTables.t9l = [\n    3, 4, 6, 7, 9, 10,\n    4, 5, 6, 7, 8, 10,\n    5, 6, 7, 8, 9, 10,\n    7, 7, 8, 9, 9, 10,\n    8, 8, 9, 9, 10, 11,\n    9, 9, 10, 10, 11, 11\n];\n\nTables.t10l = [\n    1, 4, 7, 9, 10, 10, 10, 11,\n    4, 6, 8, 9, 10, 11, 10, 10,\n    7, 8, 9, 10, 11, 12, 11, 11,\n    8, 9, 10, 11, 12, 12, 11, 12,\n    9, 10, 11, 12, 12, 12, 12, 12,\n    10, 11, 12, 12, 13, 13, 12, 13,\n    9, 10, 11, 12, 12, 12, 13, 13,\n    10, 10, 11, 12, 12, 13, 13, 13\n];\n\nTables.t11l = [\n    2, 4, 6, 8, 9, 10, 9, 10,\n    4, 5, 6, 8, 10, 10, 9, 10,\n    6, 7, 8, 9, 10, 11, 10, 10,\n    8, 8, 9, 11, 10, 12, 10, 11,\n    9, 10, 10, 11, 11, 12, 11, 12,\n    9, 10, 11, 12, 12, 13, 12, 13,\n    9, 9, 9, 10, 11, 12, 12, 12,\n    9, 9, 10, 11, 12, 12, 12, 12\n];\n\nTables.t12l = [\n    4, 4, 6, 8, 9, 10, 10, 10,\n    4, 5, 6, 7, 9, 9, 10, 10,\n    6, 6, 7, 8, 9, 10, 9, 10,\n    7, 7, 8, 8, 9, 10, 10, 10,\n    8, 8, 9, 9, 10, 10, 10, 11,\n    9, 9, 10, 10, 10, 11, 10, 11,\n    9, 9, 9, 10, 10, 11, 11, 12,\n    10, 10, 10, 11, 11, 11, 11, 12\n];\n\nTables.t13l = [\n    1, 5, 7, 8, 9, 10, 10, 11, 10, 11, 12, 12, 13, 13, 14, 14,\n    4, 6, 8, 9, 10, 10, 11, 11, 11, 11, 12, 12, 13, 14, 14, 14,\n    7, 8, 9, 10, 11, 11, 12, 12, 11, 12, 12, 13, 13, 14, 15, 15,\n    8, 9, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 15,\n    9, 9, 11, 11, 12, 12, 13, 13, 12, 13, 13, 14, 14, 15, 15, 16,\n    10, 10, 11, 12, 12, 12, 13, 13, 13, 13, 14, 13, 15, 15, 16, 16,\n    10, 11, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 16,\n    11, 11, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 18, 18,\n    10, 10, 11, 12, 12, 13, 13, 14, 14, 14, 14, 15, 15, 16, 17, 17,\n    11, 11, 12, 12, 13, 13, 13, 15, 14, 15, 15, 16, 16, 16, 18, 17,\n    11, 12, 12, 13, 13, 14, 14, 15, 14, 15, 16, 15, 16, 17, 18, 19,\n    12, 12, 12, 13, 14, 14, 14, 14, 15, 15, 15, 16, 17, 17, 17, 18,\n    12, 13, 13, 14, 14, 15, 14, 15, 16, 16, 17, 17, 17, 18, 18, 18,\n    13, 13, 14, 15, 15, 15, 16, 16, 16, 16, 16, 17, 18, 17, 18, 18,\n    14, 14, 14, 15, 15, 15, 17, 16, 16, 19, 17, 17, 17, 19, 18, 18,\n    13, 14, 15, 16, 16, 16, 17, 16, 17, 17, 18, 18, 21, 20, 21, 18\n];\n\nTables.t15l = [\n    3, 5, 6, 8, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 14,\n    5, 5, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,\n    6, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 13, 13, 13,\n    7, 8, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    8, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13,\n    9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14,\n    10, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 14,\n    10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14,\n    10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 15, 14,\n    11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15,\n    12, 12, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15,\n    12, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15,\n    13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 14, 15,\n    13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15\n];\n\nTables.t16_5l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 11,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 11,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 12,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 13,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 12,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 13,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 13,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 13,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 13,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 14,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 13,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 14,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 14,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 14,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 14,\n    11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 12\n];\n\nTables.t16l = [\n    1, 5, 7, 9, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 10,\n    4, 6, 8, 9, 10, 11, 11, 11, 12, 12, 12, 13, 14, 13, 14, 10,\n    7, 8, 9, 10, 11, 11, 12, 12, 13, 12, 13, 13, 13, 14, 14, 11,\n    9, 9, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 12,\n    10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 11,\n    10, 10, 11, 11, 12, 13, 13, 14, 13, 14, 14, 15, 15, 15, 16, 12,\n    11, 11, 11, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 12,\n    11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 17, 17, 12,\n    11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 12,\n    12, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 15, 16, 15, 13,\n    12, 13, 12, 13, 14, 14, 14, 14, 15, 16, 16, 16, 17, 17, 16, 12,\n    13, 13, 13, 13, 14, 14, 15, 16, 16, 16, 16, 16, 16, 15, 16, 13,\n    13, 14, 14, 14, 14, 15, 15, 15, 15, 17, 16, 16, 16, 16, 18, 13,\n    15, 14, 14, 14, 15, 15, 16, 16, 16, 18, 17, 17, 17, 19, 17, 13,\n    14, 15, 13, 14, 16, 16, 15, 16, 16, 17, 18, 17, 19, 17, 16, 13,\n    10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10\n];\n\nTables.t24l = [\n    4, 5, 7, 8, 9, 10, 10, 11, 11, 12, 12, 12, 12, 12, 13, 10,\n    5, 6, 7, 8, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 10,\n    7, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 9,\n    8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 9,\n    9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13, 9,\n    10, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 9,\n    10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 9,\n    11, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 10,\n    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 10,\n    12, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 10,\n    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 10,\n    13, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 10,\n    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 6\n];\n\nTables.t32l = [\n    1 + 0, 4 + 1, 4 + 1, 5 + 2, 4 + 1, 6 + 2, 5 + 2, 6 + 3,\n    4 + 1, 5 + 2, 5 + 2, 6 + 3, 5 + 2, 6 + 3, 6 + 3, 6 + 4\n];\n\nTables.t33l = [\n    4 + 0, 4 + 1, 4 + 1, 4 + 2, 4 + 1, 4 + 2, 4 + 2, 4 + 3,\n    4 + 1, 4 + 2, 4 + 2, 4 + 3, 4 + 2, 4 + 3, 4 + 3, 4 + 4\n];\n\n/**\n * Array of Huffman code table specifications. Indexed by table number (0-33).\n * @public\n * @const {HuffCodeTab[]}\n */\nexport const ht = [\n\n    /* xlen, linmax, table, hlen */\n    new HuffCodeTab(0, 0, null, null),\n    new HuffCodeTab(2, 0, Tables.t1HB, Tables.t1l),\n    new HuffCodeTab(3, 0, Tables.t2HB, Tables.t2l),\n    new HuffCodeTab(3, 0, Tables.t3HB, Tables.t3l),\n    new HuffCodeTab(0, 0, null, null), /* Apparently not used */\n    new HuffCodeTab(4, 0, Tables.t5HB, Tables.t5l),\n    new HuffCodeTab(4, 0, Tables.t6HB, Tables.t6l),\n    new HuffCodeTab(6, 0, Tables.t7HB, Tables.t7l),\n    new HuffCodeTab(6, 0, Tables.t8HB, Tables.t8l),\n    new HuffCodeTab(6, 0, Tables.t9HB, Tables.t9l),\n    new HuffCodeTab(8, 0, Tables.t10HB, Tables.t10l),\n    new HuffCodeTab(8, 0, Tables.t11HB, Tables.t11l),\n    new HuffCodeTab(8, 0, Tables.t12HB, Tables.t12l),\n    new HuffCodeTab(16, 0, Tables.t13HB, Tables.t13l),\n    new HuffCodeTab(0, 0, null, Tables.t16_5l), /* Apparently not used */\n    new HuffCodeTab(16, 0, Tables.t15HB, Tables.t15l),\n\n    new HuffCodeTab(1, 1, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(2, 3, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(3, 7, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(4, 15, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(6, 63, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(8, 255, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(10, 1023, Tables.t16HB, Tables.t16l),\n    new HuffCodeTab(13, 8191, Tables.t16HB, Tables.t16l),\n\n    new HuffCodeTab(4, 15, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(5, 31, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(6, 63, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(7, 127, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(8, 255, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(9, 511, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(11, 2047, Tables.t24HB, Tables.t24l),\n    new HuffCodeTab(13, 8191, Tables.t24HB, Tables.t24l),\n\n    new HuffCodeTab(0, 0, Tables.t32HB, Tables.t32l),\n    new HuffCodeTab(0, 0, Tables.t33HB, Tables.t33l),\n];\n\n/**\n * Combined Huffman lengths for tables 16 and 24 (Region 0/1 boundary).\n * `largetbl[i] = ((ht[16].hlen[i]) << 16) + ht[24].hlen[i];`\n * @public\n * @const {number[]}\n */\nexport const largetbl = [\n    0x010004, 0x050005, 0x070007, 0x090008, 0x0a0009, 0x0a000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000c, 0x0c000c, 0x0d000c, 0x0d000c, 0x0d000c, 0x0e000d, 0x0a000a,\n    0x040005, 0x060006, 0x080007, 0x090008, 0x0a0009, 0x0b000a, 0x0b000a, 0x0b000b,\n    0x0c000b, 0x0c000b, 0x0c000c, 0x0d000c, 0x0e000c, 0x0d000c, 0x0e000c, 0x0a000a,\n    0x070007, 0x080007, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0c000b, 0x0d000b, 0x0d000c, 0x0d000c, 0x0e000c, 0x0e000d, 0x0b0009,\n    0x090008, 0x090008, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0c000b,\n    0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0c0009,\n    0x0a0009, 0x0a0009, 0x0b0009, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000a, 0x0d000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000d, 0x0b0009,\n    0x0a000a, 0x0a0009, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0e000b,\n    0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0c0009,\n    0x0b000a, 0x0b000a, 0x0b000a, 0x0c000a, 0x0d000a, 0x0d000b, 0x0d000b, 0x0d000b,\n    0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000d, 0x0c0009,\n    0x0b000b, 0x0b000a, 0x0c000a, 0x0c000a, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b,\n    0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x0f000c, 0x11000d, 0x11000d, 0x0c000a,\n    0x0b000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b,\n    0x0f000b, 0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000d, 0x10000d, 0x0c000a,\n    0x0c000b, 0x0c000b, 0x0c000b, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000b, 0x0f000c,\n    0x0f000c, 0x0f000c, 0x0f000c, 0x10000c, 0x0f000d, 0x10000d, 0x0f000d, 0x0d000a,\n    0x0c000c, 0x0d000b, 0x0c000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0e000c, 0x0e000c,\n    0x0f000c, 0x10000c, 0x10000c, 0x10000d, 0x11000d, 0x11000d, 0x10000d, 0x0c000a,\n    0x0d000c, 0x0d000c, 0x0d000b, 0x0d000b, 0x0e000b, 0x0e000c, 0x0f000c, 0x10000c,\n    0x10000c, 0x10000c, 0x10000c, 0x10000d, 0x10000d, 0x0f000d, 0x10000d, 0x0d000a,\n    0x0d000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x0f000c,\n    0x0f000c, 0x11000c, 0x10000d, 0x10000d, 0x10000d, 0x10000d, 0x12000d, 0x0d000a,\n    0x0f000c, 0x0e000c, 0x0e000c, 0x0e000c, 0x0f000c, 0x0f000c, 0x10000c, 0x10000c,\n    0x10000d, 0x12000d, 0x11000d, 0x11000d, 0x11000d, 0x13000d, 0x11000d, 0x0d000a,\n    0x0e000d, 0x0f000c, 0x0d000c, 0x0e000c, 0x10000c, 0x10000c, 0x0f000c, 0x10000d,\n    0x10000d, 0x11000d, 0x12000d, 0x11000d, 0x13000d, 0x11000d, 0x10000d, 0x0d000a,\n    0x0a0009, 0x0a0009, 0x0a0009, 0x0b0009, 0x0b0009, 0x0c0009, 0x0c0009, 0x0c0009,\n    0x0d0009, 0x0d0009, 0x0d0009, 0x0d000a, 0x0d000a, 0x0d000a, 0x0d000a, 0x0a0006\n];\n\n/**\n * Combined Huffman lengths for tables 2 and 3.\n * `table23[i] = ((ht[2].hlen[i]) << 16) + ht[3].hlen[i];`\n * @public\n * @const {number[]}\n */\nexport const table23 = [\n    0x010002, 0x040003, 0x070007,\n    0x040004, 0x050004, 0x070007,\n    0x060006, 0x070007, 0x080008\n];\n\n/**\n * Combined Huffman lengths for tables 5 and 6.\n * `table56[i] = ((ht[5].hlen[i]) << 16) + ht[6].hlen[i];`\n * @public\n * @const {number[]}\n */\nexport const table56 = [\n    0x010003, 0x040004, 0x070006, 0x080008, 0x040004, 0x050004, 0x080006, 0x090007,\n    0x070005, 0x080006, 0x090007, 0x0a0008, 0x080007, 0x080007, 0x090008, 0x0a0009\n];\n\n/**\n * \n * @public\n * @const {number[]}\n */\nexport const bitrate_table = [\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1], /* MPEG 2 */\n    [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], /* MPEG 1 */\n    [0, 8, 16, 24, 32, 40, 48, 56, 64, -1, -1, -1, -1, -1, -1, -1], /* MPEG 2.5 */\n];\n\n/**\n * MPEG 2, MPEG 1, MPEG 2.5.\n */\nTables.samplerate_table = [\n    [22050, 24000, 16000, -1],\n    [44100, 48000, 32000, -1],\n    [11025, 12000, 8000, -1],\n];\n\n/**\n * This is the scfsi_band table from 2.4.2.7 of the IS.\n */\nTables.scfsi_band = [0, 6, 11, 16, 21];\n\nexport { Tables }\n","//package mp3;\nimport * as common from './common.js';\nconst { System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte, new_double, new_float, new_float_n, new_int, new_int_n, assert } = common;\n\nimport { L3Side } from './L3Side.js';\n\nclass GrInfo {\n    constructor() {\n        //float xr[] = new float[576];\n        this.xr = new_float(576);\n        //int l3_enc[] = new int[576];\n        this.l3_enc = new_int(576);\n        //int scalefac[] = new int[L3Side.SFBMAX];\n        this.scalefac = new_int(L3Side.SFBMAX);\n        this.xrpow_max = 0.;\n\n        this.part2_3_length = 0;\n        this.big_values = 0;\n        this.count1 = 0;\n        this.global_gain = 0;\n        this.scalefac_compress = 0;\n        this.block_type = 0;\n        this.mixed_block_flag = 0;\n        this.table_select = new_int(3);\n        this.subblock_gain = new_int(3 + 1);\n        this.region0_count = 0;\n        this.region1_count = 0;\n        this.preflag = 0;\n        this.scalefac_scale = 0;\n        this.count1table_select = 0;\n\n        this.part2_length = 0;\n        this.sfb_lmax = 0;\n        this.sfb_smin = 0;\n        this.psy_lmax = 0;\n        this.sfbmax = 0;\n        this.psymax = 0;\n        this.sfbdivide = 0;\n        this.width = new_int(L3Side.SFBMAX);\n        this.window = new_int(L3Side.SFBMAX);\n        this.count1bits = 0;\n        /**\n         * added for LSF\n         */\n        this.sfb_partition_table = null;\n        this.slen = new_int(4);\n\n        this.max_nonzero_coeff = 0;\n    }\n\n    static clone_int(array) {\n        return new Int32Array(array);\n    }\n\n    static clone_float(array) {\n        return new Float32Array(array);\n    }\n\n    assign(other) {\n        this.xr = GrInfo.clone_float(other.xr);\n        this.l3_enc = GrInfo.clone_int(other.l3_enc);\n        this.scalefac = GrInfo.clone_int(other.scalefac);\n        this.xrpow_max = other.xrpow_max;\n\n        this.part2_3_length = other.part2_3_length;\n        this.big_values = other.big_values;\n        this.count1 = other.count1;\n        this.global_gain = other.global_gain;\n        this.scalefac_compress = other.scalefac_compress;\n        this.block_type = other.block_type;\n        this.mixed_block_flag = other.mixed_block_flag;\n        this.table_select = GrInfo.clone_int(other.table_select);\n        this.subblock_gain = GrInfo.clone_int(other.subblock_gain);\n        this.region0_count = other.region0_count;\n        this.region1_count = other.region1_count;\n        this.preflag = other.preflag;\n        this.scalefac_scale = other.scalefac_scale;\n        this.count1table_select = other.count1table_select;\n\n        this.part2_length = other.part2_length;\n        this.sfb_lmax = other.sfb_lmax;\n        this.sfb_smin = other.sfb_smin;\n        this.psy_lmax = other.psy_lmax;\n        this.sfbmax = other.sfbmax;\n        this.psymax = other.psymax;\n        this.sfbdivide = other.sfbdivide;\n        this.width = GrInfo.clone_int(other.width);\n        this.window = GrInfo.clone_int(other.window);\n        this.count1bits = other.count1bits;\n\n        this.sfb_partition_table = other.sfb_partition_table.slice(0);\n        this.slen = GrInfo.clone_int(other.slen);\n        this.max_nonzero_coeff = other.max_nonzero_coeff;\n    }\n}\n\nexport { GrInfo };","//package mp3;\n\n/**\n * Layer III side information.\n *\n * @author Ken\n *\n */\n\nimport * as common from './common.js';\nconst { System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte, new_double, new_float, new_float_n, new_int, new_int_n, assert } = common;\n\nimport { Encoder } from './Encoder.js';\n\nclass ScaleFac {\n    constructor(arrL, arrS, arr21, arr12) {\n        this.l = new_int(1 + Encoder.SBMAX_l);\n        this.s = new_int(1 + Encoder.SBMAX_s);\n        this.psfb21 = new_int(1 + Encoder.PSFB21);\n        this.psfb12 = new_int(1 + Encoder.PSFB12);\n        const l = this.l;\n        const s = this.s;\n\n        if (arguments.length == 4) {\n            this.arrL = arrL;\n            this.arrS = arrS;\n            this.arr21 = arr21;\n            this.arr12 = arr12;\n\n            System.arraycopy(this.arrL, 0, l, 0, Math.min(this.arrL.length, this.l.length));\n            System.arraycopy(this.arrS, 0, s, 0, Math.min(this.arrS.length, this.s.length));\n            System.arraycopy(this.arr21, 0, this.psfb21, 0, Math.min(this.arr21.length, this.psfb21.length));\n            System.arraycopy(this.arr12, 0, this.psfb12, 0, Math.min(this.arr12.length, this.psfb12.length));\n        }\n    }\n}\n\nexport { ScaleFac };\n","class MeanBits {\n    constructor(meanBits) {\n        this.bits = meanBits;\n    }\n}\n\nexport { MeanBits };\n","import * as common from './common.js';\nconst { System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte, new_double, new_float, new_float_n, new_int, new_int_n, assert } = common;\n\nimport { GrInfo } from './GrInfo.js';\n\nclass IIISideInfo {\n    constructor() {\n        this.tt = [[null, null], [null, null]];\n        this.main_data_begin = 0;\n        this.private_bits = 0;\n        this.resvDrain_pre = 0;\n        this.resvDrain_post = 0;\n        this.scfsi = [new_int(4), new_int(4)];\n\n        for (var gr = 0; gr < 2; gr++) {\n            for (var ch = 0; ch < 2; ch++) {\n                this.tt[gr][ch] = new GrInfo();\n            }\n        }\n    }\n}\n\nexport { IIISideInfo };\n","import * as common from './common.js';\nconst { System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte, new_double, new_float, new_float_n, new_int, new_int_n, assert } = common;\n\nimport { Encoder } from './Encoder.js';\n\n/**\n * Variables used for --nspsytune\n *\n * @author Ken\n */\nclass NsPsy {\n    constructor() {\n        this.last_en_subshort = new_float_n([4, 9]);\n        this.lastAttacks = new_int(4);\n        this.pefirbuf = new_float(19);\n        this.longfact = new_float(Encoder.SBMAX_l);\n        this.shortfact = new_float(Encoder.SBMAX_s);\n\n        /**\n         * short block tuning\n         */\n        this.attackthre = 0.;\n        this.attackthre_s = 0.;\n    }\n}\n\nexport { NsPsy };\n","//package mp3;\n\nclass VBRSeekInfo {\n    constructor() {\n        /**\n         * What we have seen so far.\n         */\n        this.sum = 0;\n        /**\n         * How many frames we have seen in this chunk.\n         */\n        this.seen = 0;\n        /**\n         * How many frames we want to collect into one chunk.\n         */\n        this.want = 0;\n        /**\n         * Actual position in our bag.\n         */\n        this.pos = 0;\n        /**\n         * Size of our bag.\n         */\n        this.size = 0;\n        /**\n         * Pointer to our bag.\n         */\n        this.bag = null;\n        this.nVbrNumFrames = 0;\n        this.nBytesWritten = 0;\n        /* VBR tag data */\n        this.TotalFrameSize = 0;\n    }\n}\n\nexport { VBRSeekInfo };\n","/**\n * @fileoverview Internal flags and state variables for the LAME encoder.\n * Ported from internal_flags.h. Contains detailed configuration derived\n * from global flags, psychoacoustic model state, bitstream state, etc.\n * Uses ES Module syntax.\n *\n * @module LameInternalFlags\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { IIISideInfo } from './IIISideInfo.js';\nimport { ScaleFac } from './ScaleFac.js';\nimport { NsPsy } from './NsPsy.js';\nimport { VBRSeekInfo } from './VBRSeekInfo.js';\nimport { III_psy_xmin } from './III_psy_xmin.js';\nimport { Encoder, SBMAX_l, SBMAX_s } from './Encoder.js';\nimport { L3Side } from './L3Side.js';\n// Assuming these types are defined elsewhere and imported if needed for full type safety\n/** @typedef {import('./ATH.js').ATH} ATH */\n/** @typedef {import('./ReplayGain.js').ReplayGain} ReplayGain */\n/** @typedef {import('./IterationLoop.js').IterationLoop} IterationLoop */\n/** @typedef {import('./ID3TagSpec.js').ID3TagSpec} ID3TagSpec */\n/** @typedef {import('./MPGLib.js').MPGLib} MPGLib */ // Placeholder type\n/** @typedef {import('./PlottingData.js').PlottingData} PlottingData */ // Placeholder type\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used\n    // VbrMode, // Not used directly\n    // Float, // Not used\n    // ShortBlock, // Not used\n    // Util, // Not used\n    Arrays, // Keep for potential fill/sort usage\n    new_array_n,\n    new_byte,\n    // new_double, // Use Float64Array directly\n    new_float,\n    new_float_n,\n    new_int,\n    new_int_n,\n    assert\n} = common;\n\n// Helper to create the nested structure for en/thm used in the constructor\n/** @private */\nfunction createMaskingInfoInternal() {\n    // Helper for internal flags initialization\n    return {\n        l: new_float(SBMAX_l),\n        // Array of [SBMAX_s] Float32Arrays[3]\n        s: new_float_n([SBMAX_s, 3])\n    };\n}\n\n\n/**\n * @classdesc Holds internal state variables and configuration flags used during encoding.\n * This structure is not meant to be directly manipulated by the application; it's\n * populated and used internally by LAME based on the `LameGlobalFlags`.\n * @constructs LameInternalFlags\n */\nclass LameInternalFlags {\n    // --- Static Constants ---\n    /** Size of main filter buffer mfbuf */\n    static MFSIZE = (3 * 1152 + Encoder.ENCDELAY - Encoder.MDCTDELAY);\n    /** Max size for header buffer array */\n    static MAX_HEADER_BUF = 256;\n    /** Max bits for a channel in a granule */\n    static MAX_BITS_PER_CHANNEL = 4095;\n    /** Max bits for a granule (sum of channels) */\n    static MAX_BITS_PER_GRANULE = 7680;\n    /** Max Coefficients per block for resampling filter calc? */\n    static BPC = 320;\n    /** Size of one channel's resample history buffer */\n    static INBUF_SIZE = 4096; // Size used in original C internal_flags.h for inbuf_old\n\n    // --- Properties ---\n\n    /** Class Identifier (for type checking) @public @type {number} */\n    Class_ID = 0;\n\n    /** Initialization flag for lame_encode_frame @public @type {number} */\n    lame_encode_frame_init = 0;\n    /** Initialization flag for iteration_init @public @type {number} */\n    iteration_init_init = 0;\n    /** Initialization flag for resampler @public @type {number} */\n    fill_buffer_resample_init = 0;\n\n    /** Input buffer for MDCT [2][MFSIZE] @public @type {Array<Float32Array>} */\n    mfbuf;\n\n    /** Input buffer history for resampling [2][BLACKSIZE] @public @type {Array<Float32Array>} */\n    inbuf_old;\n\n    /** Noise history buffer 1 [4][CBANDS] @public @type {Array<Float32Array>} */\n    nb_1;\n    /** Noise history buffer 2 [4][CBANDS] @public @type {Array<Float32Array>} */\n    nb_2;\n    /** Short block noise history buffer 1 [4][CBANDS] @public @type {Array<Float32Array>} */\n    nb_s1;\n    /** Short block noise history buffer 2 [4][CBANDS] @public @type {Array<Float32Array>} */\n    nb_s2;\n\n    /** Loudness calculation state [ch] @public @type {Float32Array} */\n    loudness_sq_save;\n    /** Loudness squared per granule/channel [gr][ch] @public @type {Array<Float32Array>} */\n    loudness_sq;\n\n\n    // Psychoacoustic model internal arrays (sizes set, filled later)\n    /** Number of lines in long partition bands [CBANDS] @public @type {Int32Array} */\n    numlines_l;\n    /** Number of lines in short partition bands [CBANDS] @public @type {Int32Array} */\n    numlines_s;\n    /** Boundary partition index for long sfbs [SBMAX_l] @public @type {Int32Array} */\n    bo_l;\n    /** Boundary partition index for short sfbs [SBMAX_s] @public @type {Int32Array} */\n    bo_s;\n    /** Mid partition index for long sfbs [SBMAX_l] @public @type {Int32Array} */\n    bm_l;\n    /** Mid partition index for short sfbs [SBMAX_s] @public @type {Int32Array} */\n    bm_s;\n    /** MLD factor per long sfb [SBMAX_l] @public @type {Float32Array} */\n    mld_l;\n    /** MLD factor per short sfb [SBMAX_s] @public @type {Float32Array} */\n    mld_s;\n    /** MLD factor per long partition band [CBANDS] @public @type {Float32Array} */\n    mld_cb_l;\n    /** MLD factor per short partition band [CBANDS] @public @type {Float32Array} */\n    mld_cb_s;\n    /** Reciprocal number of lines in long partition bands [CBANDS] @public @type {Float32Array} */\n    rnumlines_l;\n    /** Spreading function indices [CBANDS][2] @public @type {Array<Int32Array>} */\n    s3ind;\n    /** Short block spreading function indices [CBANDS][2] @public @type {Array<Int32Array>} */\n    s3ind_s;\n    /** Flattened long block spreading function values @public @type {Float32Array | null} */\n    s3_ll = null;\n    /** Flattened short block spreading function values @public @type {Float32Array | null} */\n    s3_ss = null;\n    /** Min value table for long blocks [CBANDS] @public @type {Float32Array} */\n    minval_l;\n    /** Min value table for short blocks [CBANDS] @public @type {Float32Array} */\n    minval_s;\n    /** State for substep shaping [SBMAX_l]? @public @type {Int32Array} */\n    pseudohalf;\n    /** Total energy per channel [4] @public @type {Float32Array} */\n    tot_ener;\n    /** Temporal masking decay factor @public @type {number} */\n    decay = 0.0;\n\n\n    /** Granules per frame (1 or 2) @public @type {number} */\n    mode_gr = 0;\n    /** Number of input channels @public @type {number} */\n    channels_in = 0;\n    /** Number of output channels @public @type {number} */\n    channels_out = 0;\n    /** Resampling ratio (in/out) @public @type {number} */\n    resample_ratio = 0.0;\n\n    /** Samples remaining in internal buffers to be encoded @public @type {number} */\n    mf_samples_to_encode = 0;\n    /** Current number of valid samples in mfbuf @public @type {number} */\n    mf_size = 0;\n    /** Min VBR bitrate index @public @type {number} */\n    VBR_min_bitrate = 0;\n    /** Max VBR bitrate index @public @type {number} */\n    VBR_max_bitrate = 0;\n    /** Current frame bitrate index @public @type {number} */\n    bitrate_index = 0;\n    /** Output samplerate index @public @type {number} */\n    samplerate_index = 0;\n    /** Stereo mode extension (e.g., MS/LR) @public @type {number} */\n    mode_ext = 0;\n\n    /* lowpass and highpass filter control */\n    /** Normalized lower freq bound of lowpass @public @type {number} */\n    lowpass1 = 0.0;\n    /** Normalized upper freq bound of lowpass @public @type {number} */\n    lowpass2 = 0.0;\n    /** Normalized lower freq bound of highpass @public @type {number} */\n    highpass1 = 0.0;\n    /** Normalized upper freq bound of highpass @public @type {number} */\n    highpass2 = 0.0;\n\n    /* Noise shaping controls */\n    /** @public @type {number} */ noise_shaping = 0;\n    /** @public @type {number} */ noise_shaping_amp = 0;\n    /** @public @type {number} */ substep_shaping = 0;\n    /** @public @type {number} */ noise_shaping_stop = 0;\n    /** @public @type {number} */ subblock_gain = 0;\n\n    /** Psychoacoustic model active flag (0=off, 1=on) @public @type {number} */\n    psymodel = 0;\n    /** Use best Huffman table division @public @type {number} */\n    use_best_huffman = 0;\n    /** Force full outer loop search @public @type {number} */\n    full_outer_loop = 0;\n\n    /** Side info structure for the current frame @public @type {IIISideInfo} */\n    l3_side;\n\n    /* Padding state */\n    /** Padding flag for current frame @public @type {number} */\n    padding = 0;\n    /** Fractional samples per frame (for padding calc) @public @type {number} */\n    frac_SpF = 0.0;\n    /** Slot lag for CBR padding @public @type {number} */\n    slot_lag = 0;\n\n    /** ID3 tag specification (details for tag writing) @public @type {ID3TagSpec | null} */\n    tag_spec = null;\n    /** Music CRC value @public @type {number} */\n    nMusicCRC = 0;\n\n    /* Quantization loop state */\n    /** Previous global gain values [ch] @public @type {Int32Array} */\n    OldValue;\n    /** Current gain step size [ch] @public @type {Int32Array} */\n    CurrentStep;\n    /** Global masking adjustment factor @public @type {number} */\n    masking_lower = 0.0;\n    /** Scalefactor per coefficient (temporary?) [576] @public @type {Int32Array} */\n    bv_scf;\n\n    /** Use sfb21/sfb12 bands beyond standard limits. Will be properly set in lame_init_params based on VBR mode and output sample rate. @public @type {boolean} */\n    sfb21_extra;\n\n    /* Resampling state */\n    /** Precomputed filter coefficients [joff][filter_l+1] @public @type {Array<Float32Array | null>} */\n    blackfilt;\n    /** Time offset for resampling [ch] @public @type {Float64Array} */\n    itime;\n\n    /** Length of side info in bytes @public @type {number} */\n    sideinfo_len = 0;\n\n    /* mdct state */\n    /** Polyphase filterbank outputs [ch][gr][sfb][coeff] @public @type {Array<Array<Array<Float32Array>>>} */\n    sb_sample;\n    /** Polyphase filter amplitude adjustment [32] @public @type {Float32Array} */\n    amp_filter;\n\n    /* Header/Ancillary data state (if writing custom headers) */\n    /** Header buffer objects @public @type {Array<object>} */\n    header;\n    /** Current header read pointer @public @type {number} */\n    h_ptr = 0;\n    /** Current header write pointer @public @type {number} */\n    w_ptr = 0;\n    /** Flag for ancillary data @public @type {number} */\n    ancillary_flag = 0;\n\n    /* Reservoir state */\n    /** Current reservoir size (bits) @public @type {number} */\n    ResvSize = 0;\n    /** Max reservoir size (bits) @public @type {number} */\n    ResvMax = 0;\n\n    /** Scalefactor band boundary information @public @type {ScaleFac} */\n    scalefac_band;\n\n    /* Masking thresholds and energies (potentially M/S) [4] */\n    /** Threshold per sfb @public @type {Array<{l: Float32Array, s: Array<Float32Array>}>} */\n    thm;\n    /** Energy per sfb @public @type {Array<{l: Float32Array, s: Array<Float32Array>}>} */\n    en;\n\n    /* M/S ratio history */\n    /** @public @type {number} */ ms_ratio_s_old = 0.0;\n    /** @public @type {number} */ ms_ratio_l_old = 0.0;\n    /** @public @type {number} */ ms_ener_ratio_old = 0.0;\n\n    /** Previous granule block type [ch] @public @type {Int32Array} */\n    blocktype_old;\n\n    /** NS PsyTune specific state @public @type {NsPsy} */\n    nsPsy;\n\n    /** VBR tag seek table information @public @type {VBRSeekInfo} */\n    VBR_seek_table;\n\n    /** ATH calculation results @public @type {ATH | null} */\n    ATH = null;\n    /** Psychoacoustic model parameters (internal class) @public @type {_PSY | null} */\n    PSY = null; // Refers to internal _PSY class\n\n    /* Gapless encoding state */\n    /** Total samples for gapless info @public @type {number} */\n    nogap_total = 0;\n    /** Current sample count for gapless info @public @type {number} */\n    nogap_current = 0;\n\n    /* ReplayGain state */\n    /** @public @type {boolean} */ decode_on_the_fly = false; // Default to false\n    /** @public @type {boolean} */ findReplayGain = false;\n    /** @public @type {boolean} */ findPeakSample = false;\n    /** @public @type {number} */ PeakSample = 0.0;\n    /** @public @type {number} */ RadioGain = 0;\n    /** @public @type {number} */ AudiophileGain = 0;\n    /** ReplayGain analysis data @public @type {ReplayGain | null} */\n    rgdata = null;\n    /** @public @type {number} */ noclipGainChange = 0;\n    /** @public @type {number} */ noclipScale = 0.0;\n\n    /* Simple statistics */\n    /** Histogram [bitrate_idx][mode+1] @public @type {Array<Int32Array> | null} */\n    bitrate_stereoMode_Hist = null;\n    /** Histogram [bitrate_idx][blockType+1] @public @type {Array<Int32Array> | null} */\n    bitrate_blockType_Hist = null;\n\n    /** Plotting/Analysis info structure @public @type {PlottingData | null} */\n    pinfo = null;\n    /** mpglib decoder instance (if decode_on_the_fly) @public @type {MPGLib | null} */\n    hip = null;\n\n    /* Input buffer state (used by lame_encode_buffer) */\n    /** @public @type {number} */ in_buffer_nsamples = 0;\n    /** @public @type {Float32Array | null} */ in_buffer_0 = null;\n    /** @public @type {Float32Array | null} */ in_buffer_1 = null;\n\n    /** Function pointer to the selected iteration loop @public @type {IterationLoop | null} */\n    iteration_loop = null;\n\n    // --- Constructor ---\n    constructor() {\n        // Initialize arrays\n        this.mfbuf = [new_float(LameInternalFlags.MFSIZE), new_float(LameInternalFlags.MFSIZE)];\n        // Initialize inbuf_old with enough space for negative indices\n        this.inbuf_old = [new_float(LameInternalFlags.INBUF_SIZE), new_float(LameInternalFlags.INBUF_SIZE)];\n        // Initialize sfb21_extra to false by default - will be updated in lame_init_params based on VBR mode and output sample rate\n        this.sfb21_extra = false;\n\n        // Initialize noise history buffers\n        this.nb_1 = new_float_n([4, Encoder.CBANDS]);\n        this.nb_2 = new_float_n([4, Encoder.CBANDS]);\n        this.nb_s1 = new_float_n([4, Encoder.CBANDS]);\n        this.nb_s2 = new_float_n([4, Encoder.CBANDS]);\n        this.loudness_sq_save = new_float(2);\n        this.loudness_sq = new_float_n([2, 2]); // Initialize loudness_sq array\n        this.numlines_l = new_int(Encoder.CBANDS);\n        this.numlines_s = new_int(Encoder.CBANDS);\n        this.bo_l = new_int(Encoder.SBMAX_l);\n        this.bo_s = new_int(Encoder.SBMAX_s);\n        this.bm_l = new_int(Encoder.SBMAX_l);\n        this.bm_s = new_int(Encoder.SBMAX_s);\n        this.mld_l = new_float(Encoder.SBMAX_l);\n        this.mld_s = new_float(Encoder.SBMAX_s);\n        this.mld_cb_l = new_float(Encoder.CBANDS);\n        this.mld_cb_s = new_float(Encoder.CBANDS);\n        this.rnumlines_l = new_float(Encoder.CBANDS);\n        this.s3ind = new_int_n([Encoder.CBANDS, 2]);\n        this.s3ind_s = new_int_n([Encoder.CBANDS, 2]);\n        this.minval_l = new_float(Encoder.CBANDS);\n        this.minval_s = new_float(Encoder.CBANDS);\n        this.pseudohalf = new_int(Encoder.SBMAX_l);\n        this.tot_ener = new_float(4);\n        this.OldValue = new_int(2);\n        this.CurrentStep = new_int(2);\n        this.bv_scf = new_int(576);\n        this.blackfilt = new Array(2 * LameInternalFlags.BPC + 1).fill(null);\n        this.itime = new Float64Array(2); // Use Float64Array directly\n        this.sb_sample = new_array_n([2, 2, 18, Encoder.SBLIMIT], () => 0.0);\n        this.amp_filter = new_float(32);\n        this.header = new Array(LameInternalFlags.MAX_HEADER_BUF);\n        this.scalefac_band = new ScaleFac();\n        this.thm = new Array(4);\n        this.en = new Array(4);\n        for (let i = 0; i < 4; i++) {\n            this.thm[i] = new III_psy_xmin();\n            this.en[i] = new III_psy_xmin();\n        }\n        this.blocktype_old = new_int(2);\n        this.nsPsy = new NsPsy();\n        this.VBR_seek_table = new VBRSeekInfo();\n        this.l3_side = new IIISideInfo();\n\n        // Initialize Header array elements\n        for (let i = 0; i < LameInternalFlags.MAX_HEADER_BUF; i++) {\n             class Header {\n                 constructor() { this.write_timing = 0; this.ptr = 0; this.buf = new_byte(40); }\n             }\n            this.header[i] = new Header();\n        }\n\n        // Ensure histogram arrays are initialized\n        if (!this.bitrate_stereoMode_Hist) this.bitrate_stereoMode_Hist = new_int_n([16, 5]);\n        if (!this.bitrate_blockType_Hist) this.bitrate_blockType_Hist = new_int_n([16, 6]);\n\n        // Initialize other nullable properties to null explicitly\n        this.ATH = null;\n        this.PSY = null;\n        this.rgdata = null;\n        this.iteration_loop = null;\n        this.hip = null;\n        this.pinfo = null;\n        this.tag_spec = null;\n        this.in_buffer_0 = null;\n        this.in_buffer_1 = null;\n        this.s3_ll = null;\n        this.s3_ss = null;\n    }\n}\n\n// Define static constants after class definition if needed\n// (Already defined within the class using static keyword)\n\n// At the bottom of LameInternalFlags.js\nconst MAX_HEADER_BUF = LameInternalFlags.MAX_HEADER_BUF; // Assign static to const\nexport { LameInternalFlags, MAX_HEADER_BUF }; // Export both\nexport default LameInternalFlags;","/**\n * @fileoverview Internal quantization helper functions for LAME MP3 encoder.\n * Ported from quantize_pvt.c. Contains tables, initialization routines,\n * noise calculation, and VBR helper functions used by the main Quantize module.\n * Uses ES Module syntax.\n *\n * Original C Source Header:\n *      quantize_pvt source file\n *\n *      Copyright (c) 1999-2002 Takehiro Tominaga\n *      Copyright (c) 2000-2002 Robert Hegemann\n *      Copyright (c) 2001 Naoki Shibata\n *      Copyright (c) 2002-2005 Gabriel Bouvigne\n *      ... (License details omitted for brevity) ...\n *\n * $Id: QuantizePVT.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $\n *\n * @module QuantizePVT\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport { ScaleFac } from './ScaleFac.js';\nimport * as common from './common.js';\nimport { Encoder } from './Encoder.js';\nimport { MeanBits } from './MeanBits.js';\nimport { LameInternalFlags } from './LameInternalFlags.js';\nimport { BitStream } from './BitStream.js'; // Assuming BitStream has static methods or default export\n\n// Assuming these are provided externally or via setModules\n/** @typedef {import('./Takehiro.js').default} Takehiro */\n/** @typedef {import('./Reservoir.js').default} Reservoir */\n/** @typedef {import('./PsyModel.js').default} PsyModel */\n/** @typedef {import('./LameGlobalFlags.js').default} LameGlobalFlags */\n/** @typedef {import('./GrInfo.js').default} GrInfo */\n/** @typedef {import('./CalcNoiseResult.js').default} CalcNoiseResult */\n/** @typedef {import('./CalcNoiseData.js').default} CalcNoiseData */\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used directly\n    VbrMode,\n    Float,\n    ShortBlock,\n    Util,\n    Arrays,\n    // new_array_n, // Used indirectly\n    // new_byte, // Not used\n    // new_double, // Not used\n    new_float,\n    new_float_n,\n    new_int,\n    // new_int_n, // Not used directly\n    assert\n} = common;\n\n// --- Constants ---\nconst Q_MAX = 257; // 256 + 1\nconst Q_MAX2 = 116; // Max combined gain offset\nconst LARGE_BITS = 100000; // Placeholder for large bit counts\nconst IXMAX_VAL = 8206; // Max value for ix in quantization loop\nconst PRECALC_SIZE = IXMAX_VAL + 2; // Size for precomputed pow43 table\nconst DBL_EPSILON = 2.2204460492503131e-016; // Machine epsilon\nconst NSATHSCALE = 100; // ATH scaling factor in dB\n\n// --- Precomputed Tables ---\n// Initialized in iteration_init\nlet pow20 = new_float(Q_MAX + Q_MAX2 + 1);\nlet ipow20 = new_float(Q_MAX);\nlet pow43 = new_float(PRECALC_SIZE);\nlet adj43 = new_float(PRECALC_SIZE);\n\n/**\n * @classdesc Provides private helper functions and data structures for the\n * main Quantize module. This includes precomputed tables, noise calculation,\n * ATH adjustments, and VBR preparation logic.\n * @constructs QuantizePVT\n */\nclass QuantizePVT {\n    /** @private @type {Takehiro|null} Huffman coding/bit counting module. */\n    tak = null;\n    /** @private @type {Reservoir|null} Reservoir handling module. */\n    rv = null;\n    /** @private @type {PsyModel|null} Psychoacoustic model module. */\n    psy = null;\n\n    /**\n     * Table B.6: layer3 preemphasis. Values added to scalefactors before quantization.\n     * @public\n     * @const {number[]}\n     */\n    pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0];\n\n    /**\n     * MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor bands.\n     * Contains boundary information for different sample rates and block types.\n     * Indexed by sample rate and MPEG version.\n     * @public\n     * @const {ScaleFac[]}\n     */\n    sfBandIndex = [\n        // Definitions omitted for brevity, assume they are correct from original code\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 22.05 kHz MPEG2\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464, 540, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 24 kHz MPEG2\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 16 kHz MPEG2\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418, 576], [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 44.1 kHz MPEG1\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384, 576], [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 48 kHz MPEG1\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550, 576], [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 32 kHz MPEG1\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 11.025 kHz MPEG2.5 (Uses MPEG2 indices?)\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]), // 12 kHz MPEG2.5 (Uses MPEG2 indices?)\n        new ScaleFac([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570, 572, 574, 576], [0, 8, 16, 24, 36, 52, 72, 96, 124, 160, 162, 164, 166, 192], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0])  // 8 kHz MPEG2.5 (Adjusted short block table?)\n    ];\n\n\n    /**\n     * Scalefactor partitioning table for MPEG2. Used for grouping scalefactors\n     * for transmission (slen values). Dimensions: [table_number][row][column].\n     * @public\n     * @const {number[][][]}\n     */\n    nr_of_sfb_block = [\n        [[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]],\n        [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]],\n        [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]],\n        [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]],\n        [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]],\n        [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n\n\n    /**\n     * Precomputed table for adjusting quantization steps (x^(4/3)).\n     * Used in noise calculation. Global access needed? Made public for now.\n     * @public\n     * @type {Float32Array}\n     */\n    adj43 = adj43; // Assign instance variable\n\n    constructor() {\n        // Properties initialized externally via setModules\n    }\n\n    /**\n     * Sets the internal module dependencies. Must be called before use.\n     *\n     * @public\n     * @param {Takehiro} _tk - Huffman coding and bit counting module.\n     * @param {Reservoir} _rv - Bit reservoir handling module.\n     * @param {PsyModel} _psy - Psychoacoustic model module.\n     */\n    setModules(_tk, _rv, _psy) {\n        this.tak = _tk;\n        this.rv = _rv;\n        this.psy = _psy;\n    }\n\n    /**\n     * Calculates `2.0 ^ ((x - 210) * -0.1875)`. Inverse power function.\n     * Used for converting quantized values back to spectral domain (approx).\n     * Uses precomputed table `ipow20`.\n     *\n     * @public\n     * @param {number} x - Input value (typically related to gains/scalefactors). Expected range [0, Q_MAX-1].\n     * @returns {number} Precomputed inverse power value.\n     */\n    IPOW20(x) {\n        assert(0 <= x && x < Q_MAX, `IPOW20 index out of bounds: ${x}`);\n        return ipow20[x];\n    }\n\n    // --- Private Helper Functions ---\n    // (JSDoc omitted for brevity)\n\n    /** @private */\n    _POW20(x) { // Renamed from POW20 to avoid conflict and indicate internal use\n        assert(0 <= (x + Q_MAX2) && x < Q_MAX + Q_MAX2 + 1, `POW20 index out of bounds: ${x}`); // Check adjusted index\n        return pow20[x + Q_MAX2];\n    }\n\n    /** @private */\n    _ATHmdct(gfp, f) {\n        let ath = this.psy.ATHformula(f, gfp);\n        ath -= NSATHSCALE;\n        ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n        return ath;\n    }\n\n    /** @private */\n    _compute_ath(gfp) {\n        const gfc = gfp.internal_flags;\n        const ATH_l = gfc.ATH.l;\n        const ATH_psfb21 = gfc.ATH.psfb21;\n        const ATH_s = gfc.ATH.s;\n        const ATH_psfb12 = gfc.ATH.psfb12;\n        const samp_freq = gfp.out_samplerate;\n\n        for (let sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            const start = gfc.scalefac_band.l[sfb]; const end = gfc.scalefac_band.l[sfb + 1];\n            ATH_l[sfb] = Float.MAX_VALUE;\n            for (let i = start; i < end; i++) { const freq = i * samp_freq / (2.0 * 576.0); const ATH_f = this._ATHmdct(gfp, freq); ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f); }\n        }\n        for (let sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n            const start = gfc.scalefac_band.psfb21[sfb]; const end = gfc.scalefac_band.psfb21[sfb + 1];\n            ATH_psfb21[sfb] = Float.MAX_VALUE;\n            for (let i = start; i < end; i++) { const freq = i * samp_freq / (2.0 * 576.0); const ATH_f = this._ATHmdct(gfp, freq); ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f); }\n        }\n        for (let sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n            const start = gfc.scalefac_band.s[sfb]; const end = gfc.scalefac_band.s[sfb + 1];\n            ATH_s[sfb] = Float.MAX_VALUE;\n            for (let i = start; i < end; i++) { const freq = i * samp_freq / (2.0 * 192.0); const ATH_f = this._ATHmdct(gfp, freq); ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f); }\n            ATH_s[sfb] *= (gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb]);\n        }\n        for (let sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n            const start = gfc.scalefac_band.psfb12[sfb]; const end = gfc.scalefac_band.psfb12[sfb + 1];\n            ATH_psfb12[sfb] = Float.MAX_VALUE;\n            for (let i = start; i < end; i++) { const freq = i * samp_freq / (2.0 * 192.0); const ATH_f = this._ATHmdct(gfp, freq); ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f); }\n            ATH_psfb12[sfb] *= (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]); // Uses fixed width?\n        }\n        if (gfp.noATH) {\n            for (let sfb = 0; sfb < Encoder.SBMAX_l; sfb++) ATH_l[sfb] = 1E-20;\n            for (let sfb = 0; sfb < Encoder.PSFB21; sfb++) ATH_psfb21[sfb] = 1E-20;\n            for (let sfb = 0; sfb < Encoder.SBMAX_s; sfb++) ATH_s[sfb] = 1E-20;\n            for (let sfb = 0; sfb < Encoder.PSFB12; sfb++) ATH_psfb12[sfb] = 1E-20;\n        }\n        gfc.ATH.floor = 10.0 * Math.log10(this._ATHmdct(gfp, -1.0)); // Calculate floor using special value\n    }\n\n\n    // --- Public Methods ---\n\n    /**\n     * Initializes tables and psychoacoustic parameters used by the quantization loops.\n     * Computes ATH values, precalculates power tables (`pow43`, `pow20`, `ipow20`),\n     * initializes Huffman coding tables, and sets up psychoacoustic tuning factors.\n     * This function should only be called once during encoder initialization.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     */\n    iteration_init(gfp) {\n        const gfc = gfp.internal_flags;\n        let i;\n\n        if (gfc.iteration_init_init === 0) { // Check if already initialized\n            gfc.iteration_init_init = 1; // Mark as initialized\n\n            gfc.l3_side.main_data_begin = 0; // Reset main data pointer?\n            this._compute_ath(gfp); // Calculate ATH values\n\n            // Precompute power tables\n            pow43[0] = 0.0;\n            for (i = 1; i < PRECALC_SIZE; i++) pow43[i] = Math.pow(i, 4.0 / 3.0);\n\n            for (i = 0; i < PRECALC_SIZE - 1; i++) adj43[i] = ((i + 1) - Math.pow(0.5 * (pow43[i] + pow43[i + 1]), 0.75));\n            adj43[PRECALC_SIZE - 1] = 0.5; // Set last value explicitly\n\n            for (i = 0; i < Q_MAX; i++) ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n            for (i = 0; i <= Q_MAX + Q_MAX2; i++) pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n\n            // Initialize Huffman tables (delegated to Takehiro module)\n            this.tak.huffman_init(gfc);\n\n            // Initialize psychoacoustic tuning factors based on exp_nspsytune\n            {\n                let bass, alto, treble, sfb21;\n                i = (gfp.exp_nspsytune >> 2) & 63; if (i >= 32) i -= 64; bass = Math.pow(10, i / 4.0 / 10.0);\n                i = (gfp.exp_nspsytune >> 8) & 63; if (i >= 32) i -= 64; alto = Math.pow(10, i / 4.0 / 10.0);\n                i = (gfp.exp_nspsytune >> 14) & 63; if (i >= 32) i -= 64; treble = Math.pow(10, i / 4.0 / 10.0);\n                i = (gfp.exp_nspsytune >> 20) & 63; if (i >= 32) i -= 64; sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n\n                for (i = 0; i < Encoder.SBMAX_l; i++) {\n                    let f = (i <= 6) ? bass : (i <= 13) ? alto : (i <= 20) ? treble : sfb21;\n                    gfc.nsPsy.longfact[i] = f;\n                }\n                for (i = 0; i < Encoder.SBMAX_s; i++) {\n                     let f = (i <= 5) ? bass : (i <= 10) ? alto : (i <= 11) ? treble : sfb21;\n                    gfc.nsPsy.shortfact[i] = f;\n                }\n            }\n        }\n    }\n\n    /**\n     * Allocates target bits among channels based on perceptual entropy (PE).\n     * Higher PE gets more bits. Considers bit reservoir and enforces limits.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Array<Float32Array>} pe - Perceptual entropy [gr][ch].\n     * @param {Int32Array} targ_bits - Input/Output: Target bits array for the granule [ch]. Initial allocation might be present; modified in place.\n     * @param {number} mean_bits - Average bits available per granule (considering reservoir).\n     * @param {number} gr - Granule index (0 or 1).\n     * @param {number} cbr - Flag indicating CBR mode (affects reservoir usage).\n     * @returns {number} Maximum allowed bits for this granule (including reservoir).\n     */\n    on_pe(gfp, pe, targ_bits, mean_bits, gr, cbr) {\n        const gfc = gfp.internal_flags;\n        let tbits = 0; // Base bits for this granule from reservoir\n        let total_added_bits = 0; // Total extra bits allocated based on PE\n        const add_bits = new_int(2); // Extra bits per channel\n        const channels = gfc.channels_out;\n\n        // 1. Get base bits and allowed extra bits from reservoir\n        let mb = new MeanBits(tbits);\n        const extra_bits = this.rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n        tbits = mb.bits; // Base bits available for this granule\n        const max_bits_granule = tbits + extra_bits; // Total allowed for granule\n        // Apply hard limit per granule\n        const capped_max_bits_granule = Math.min(max_bits_granule, LameInternalFlags.MAX_BITS_PER_GRANULE);\n\n        // 2. Initial target bit allocation and calculate needed extra bits based on PE\n        for (let ch = 0; ch < channels; ++ch) {\n            // Initial target: Base bits distributed equally\n            targ_bits[ch] = Math.min(LameInternalFlags.MAX_BITS_PER_CHANNEL, Math.floor(tbits / channels));\n\n            // Calculate extra bits needed based on PE (relative to 700)\n            add_bits[ch] = Math.floor(targ_bits[ch] * pe[gr][ch] / 700.0) - targ_bits[ch];\n\n            // Limit extra bits per channel (heuristic: 0 to 0.75 * avg_bits_per_channel)\n            const avg_bits_per_ch_granule = mean_bits / channels; // Approx avg bits per ch/gr\n            if (add_bits[ch] > avg_bits_per_ch_granule * 0.75) {\n                add_bits[ch] = Math.floor(avg_bits_per_ch_granule * 0.75);\n            }\n            if (add_bits[ch] < 0) add_bits[ch] = 0;\n\n            // Ensure adding extra bits doesn't exceed per-channel limit\n            if (add_bits[ch] + targ_bits[ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                add_bits[ch] = Math.max(0, LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n            }\n\n            total_added_bits += add_bits[ch]; // Sum needed extra bits\n        }\n\n        // 3. Scale added bits if total needed exceeds available extra bits\n        let actual_extra_bits = extra_bits; // Use the reservoir's calculated extra bits\n        if (total_added_bits > actual_extra_bits) {\n            for (let ch = 0; ch < channels; ++ch) {\n                add_bits[ch] = Math.floor(actual_extra_bits * add_bits[ch] / total_added_bits);\n            }\n        }\n\n        // 4. Add the allocated extra bits to the target bits\n        let final_total_bits = 0;\n        for (let ch = 0; ch < channels; ++ch) {\n            targ_bits[ch] += add_bits[ch];\n            final_total_bits += targ_bits[ch];\n        }\n\n        // 5. Rescale final targets if total exceeds granule hard limit (MAX_BITS_PER_GRANULE)\n        // This might happen if initial tbits + scaled add_bits > hard limit\n        if (final_total_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n            let sum_after_scale = 0;\n            for (let ch = 0; ch < channels; ++ch) {\n                targ_bits[ch] = Math.floor(targ_bits[ch] * LameInternalFlags.MAX_BITS_PER_GRANULE / final_total_bits);\n                sum_after_scale += targ_bits[ch];\n            }\n             assert(sum_after_scale <= LameInternalFlags.MAX_BITS_PER_GRANULE, \"on_pe rescaling failed\");\n        }\n\n        // Return the maximum bits allowed for this granule\n        return capped_max_bits_granule;\n    }\n\n    /**\n     * Reduces the number of bits allocated to the Side channel in MS Stereo,\n     * transferring them to the Mid channel based on the Mid/Side energy ratio.\n     * Aims for roughly a 2:1 Mid:Side bit split when energy is equal, shifting\n     * towards Mid as Side energy decreases. Enforces a minimum bit allocation\n     * for the Side channel and respects overall granule/channel bit limits.\n     *\n     * @public\n     * @param {Int32Array} targ_bits - Input/Output: Target bits array for the granule [ch]. Modified in place.\n     * @param {number} ms_ener_ratio - Energy ratio (Side / Mid). Typically 0 to 1.\n     * @param {number} mean_bits - Average total bits per granule (Mid+Side). Used for limiting transfer.\n     * @param {number} max_bits - Maximum total bits allowed for the granule (Mid+Side).\n     */\n    reduce_side(targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n        assert(max_bits <= LameInternalFlags.MAX_BITS_PER_GRANULE, \"max_bits exceeds granule limit in reduce_side\");\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE, \"Initial targ_bits exceed granule limit\");\n\n        // Calculate transfer factor (0 to 0.5).\n        // fac = 0.33 when ratio=0 (all Mid), fac=0 when ratio=0.5 (equal), fac=-0.165 when ratio=1 (all Side)\n        // Clamp factor between 0 and 0.5.\n        let fac = 0.33 * (0.5 - ms_ener_ratio) / 0.5;\n        if (fac < 0) fac = 0;\n        if (fac > 0.5) fac = 0.5;\n\n        // Calculate bits to move: factor * half_of_total_bits\n        let move_bits = Math.floor(fac * 0.5 * (targ_bits[0] + targ_bits[1]));\n\n        // Limit move_bits: cannot make Mid exceed max channel bits\n        if (move_bits > LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n            move_bits = LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0];\n        }\n        if (move_bits < 0) move_bits = 0; // Should not happen due to factor clamping\n\n        // Check if Side channel has enough bits and enforce minimum\n        const SIDE_MIN_BITS = 125;\n        if (targ_bits[1] >= SIDE_MIN_BITS) {\n            // Only move bits if Side remains above minimum\n            if (targ_bits[1] - move_bits >= SIDE_MIN_BITS) {\n                // Limit transfer if Mid already has significantly more than average\n                // (mean_bits here is avg per granule *for both channels*)\n                 if (targ_bits[0] < mean_bits) { // Transfer only if Mid is below average total? Heuristic check.\n                     targ_bits[0] += move_bits;\n                     targ_bits[1] -= move_bits;\n                 }\n                 // If Mid is already high, don't transfer bits.\n            } else {\n                // Move only enough bits to bring Side down to minimum\n                const bits_to_move_limited = targ_bits[1] - SIDE_MIN_BITS;\n                 if (targ_bits[0] < mean_bits) { // Check Mid average heuristic again\n                     targ_bits[0] += bits_to_move_limited;\n                 }\n                 // else: Mid is high, don't add more, but Side still goes to minimum.\n                 targ_bits[1] = SIDE_MIN_BITS;\n            }\n        }\n         // else: Side channel starts below minimum, no bits are moved.\n\n        // Final check: Ensure total bits do not exceed max_bits for the granule\n        const total_bits_after_move = targ_bits[0] + targ_bits[1];\n        if (total_bits_after_move > max_bits) {\n            // Scale both channels down proportionally\n            if (total_bits_after_move > 0) { // Avoid division by zero\n                 targ_bits[0] = Math.floor(max_bits * targ_bits[0] / total_bits_after_move);\n                 targ_bits[1] = Math.floor(max_bits * targ_bits[1] / total_bits_after_move);\n            } else {\n                // Should not happen if SIDE_MIN_BITS > 0\n                 targ_bits[0] = Math.floor(max_bits / 2);\n                 targ_bits[1] = Math.floor(max_bits / 2);\n            }\n        }\n\n        // Assert final limits\n        assert(targ_bits[0] >= 0 && targ_bits[0] <= LameInternalFlags.MAX_BITS_PER_CHANNEL, `Mid bits out of range: ${targ_bits[0]}`);\n        assert(targ_bits[1] >= 0 && targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_CHANNEL, `Side bits out of range: ${targ_bits[1]}`);\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE, \"Total bits exceed granule limit after reduce_side\");\n    }\n\n    /**\n     * Adjusts the Absolute Threshold of Hearing (ATH) value based on the\n     * ATH adjustment factor (`a`) and the ATH floor. This aims to shape\n     * the noise floor dynamically. Used in VBR modes.\n     *\n     * @public\n     * @param {number} a - ATH adjustment factor (gfc.ATH.adjust, typically 0 to 1).\n     * @param {number} x - Original ATH value for the band (linear energy scale).\n     * @param {number} athFloor - ATH floor in dB (gfc.ATH.floor).\n     * @returns {number} Adjusted ATH value (linear energy scale).\n     */\n    athAdjust(a, x, athFloor) {\n        const o = 90.30873362; // Constant from formula\n        const p = 94.82444863; // Constant from formula\n        let u = Util.FAST_LOG10_X(x, 10.0); // Convert original ATH energy to dB-like scale\n        const v = a * a; // Square of adjustment factor\n        let w = 0.0;\n\n        u -= athFloor; // Offset by ATH floor\n\n        // Apply adjustment factor 'a' (via 'v') logarithmically relative to constant 'o'\n        if (v > 1E-20) {\n            w = 1.0 + Util.FAST_LOG10_X(v, 10.0 / o); // Log scale the adjustment factor\n        }\n        if (w < 0.0) w = 0.0; // Clamp adjustment effect\n        u *= w; // Apply scaled adjustment\n\n        u += athFloor + o - p; // Reapply floor and constants\n\n        // Convert back to linear energy scale\n        return Math.pow(10.0, 0.1 * u);\n    }\n\n\n    /**\n     * Calculates the allowed noise `xmin` for each scalefactor band based on\n     * the psycho-acoustic model results (`ratio`) and the ATH.\n     * `xmin(sb) = max(ATH(sb), masking_threshold(sb))`\n     * where `masking_threshold(sb) = energy(sb) * ratio(sb) * masking_lower`\n     * adjusted for perceptual tuning factors (`nsPsy.longfact`, `nsPsy.shortfact`).\n     * Also finds the highest non-zero spectral coefficient (`max_nonzero_coeff`).\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {object} ratio - Masking ratio structure containing `en` (energy) and `thm` (threshold ratio) for the granule/channel.\n     * @param {GrInfo} cod_info - Granule info structure containing block type, spectral data (`xr`). `max_nonzero_coeff` is set here.\n     * @param {Float32Array} pxmin - Output: Array [SBMAX] to store the calculated allowed noise for each band.\n     * @returns {number} `ath_over`: Count of scalefactor bands where energy exceeds the ATH.\n     */\n    calc_xmin(gfp, ratio, cod_info, pxmin) {\n        let pxminPos = 0; // Index for pxmin output array\n        const gfc = gfp.internal_flags;\n        let gsfb; // Scalefactor band index (combined long/short)\n        let j = 0; // Index into spectral data xr[]\n        let ath_over = 0; // Count of bands where energy > ATH\n        const ATH = gfc.ATH; // ATH values structure\n        const xr = cod_info.xr; // Spectral data\n        const enable_athaa_fix = (gfp.VBR === VbrMode.vbr_mtrh) ? 1 : 0; // VBR MTRH specific flag\n        let masking_lower = gfc.masking_lower; // Global masking adjustment\n\n        // VBR MTRH/MT already applied masking_lower in PSY model\n        if (gfp.VBR === VbrMode.vbr_mtrh || gfp.VBR === VbrMode.vbr_mt) {\n            masking_lower = 1.0;\n        }\n\n        // --- Process Long Block Bands (or long part of mixed block) ---\n        for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n            let ath_band; // ATH for this band\n            let xmin; // Minimum allowed noise (allowed distortion power)\n            const width = cod_info.width[gsfb]; // Number of coefficients in this band\n            let en0 = 0.0; // Energy in this band\n\n            // Calculate ATH for the band (potentially adjusted)\n            if (gfp.VBR === VbrMode.vbr_rh || gfp.VBR === VbrMode.vbr_mtrh) {\n                ath_band = this.athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);\n            } else {\n                ath_band = ATH.adjust * ATH.l[gsfb];\n            }\n\n            // Calculate energy (en0) and a noise estimate (rh2) based on ATH clipping\n            const rh1 = ath_band / width; // ATH threshold per coefficient (approx)\n            let rh2 = DBL_EPSILON; // Accumulated noise assuming clipping at rh1\n            if(width > 0) { // Avoid loop if width is 0\n                let l = width >> 1; // Process pairs\n                do {\n                    const xa = xr[j] * xr[j]; en0 += xa; rh2 += Math.min(xa, rh1); j++;\n                    const xb = xr[j] * xr[j]; en0 += xb; rh2 += Math.min(xb, rh1); j++;\n                } while (--l > 0);\n                 // Handle odd width if necessary (already included in C logic by loop condition)\n                 // if (width & 1) { const xa = xr[j] * xr[j]; en0 += xa; rh2 += Math.min(xa, rh1); j++; }\n            }\n\n            // Check if energy exceeds ATH\n            if (en0 > ath_band) ath_over++;\n\n            // Apply nsPsy tuning factor adjustment (specific sfb index?)\n            if (gsfb === Encoder.SBPSY_l) { // Special handling for last psy band? Check index.\n                const x = ath_band * gfc.nsPsy.longfact[gsfb];\n                if (rh2 < x) rh2 = x; // Adjust noise estimate based on tuning factor\n            }\n\n            // Set initial xmin based on ATH (potentially using rh2 for VBR MTRH)\n            xmin = (enable_athaa_fix !== 0) ? rh2 : ath_band;\n\n            // Add masking threshold component if not ATHonly mode\n            if (!gfp.ATHonly) {\n                const mask_en = ratio.en.l[gsfb];\n                if (mask_en > 0.0) {\n                    let mask_thr = en0 * ratio.thm.l[gsfb] * masking_lower / mask_en;\n                    // Apply nsPsy tuning factor to masking threshold part\n                    if (enable_athaa_fix !== 0) mask_thr *= gfc.nsPsy.longfact[gsfb];\n                    // xmin is the maximum of ATH and masking threshold\n                    if (xmin < mask_thr) xmin = mask_thr;\n                }\n            }\n\n            // Store final xmin (apply nsPsy factor if not MTRH fix)\n            pxmin[pxminPos++] = (enable_athaa_fix !== 0) ? xmin : xmin * gfc.nsPsy.longfact[gsfb];\n\n        } // End long block loop\n\n        // --- Find highest non-zero coefficient (only needed for long blocks here?) ---\n        let max_nonzero = 575;\n        if (cod_info.block_type !== Encoder.SHORT_TYPE) { // Long or Mixed blocks\n            let k = 576;\n            // C code has while(k--!=0 && EQ(xr[k],0)); max_nonzero=k;\n            // This finds the index *of* the last non-zero or -1 if all zero.\n            while (k-- > 0) {\n                if (Math.abs(xr[k]) > 1e-9) break; // Find last non-zero\n            }\n             max_nonzero = k; // k is -1 if all zero, or index of last non-zero\n             if(max_nonzero < 0) max_nonzero = 0; // Ensure non-negative index if used later\n             cod_info.max_nonzero_coeff = max_nonzero;\n        } else {\n             cod_info.max_nonzero_coeff = 575; // Assume all coeffs potentially non-zero for short blocks\n        }\n\n\n        // --- Process Short Block Bands (if applicable) ---\n        let sfb_s = cod_info.sfb_smin; // Short block sfb index\n        while (gsfb < cod_info.psymax) { // Continue using combined index gsfb\n            const width = cod_info.width[gsfb]; // Width of one short sub-band\n            let ath_band; // ATH for this short sfb\n\n            // Calculate ATH for the band\n            if (gfp.VBR === VbrMode.vbr_rh || gfp.VBR === VbrMode.vbr_mtrh) {\n                 ath_band = this.athAdjust(ATH.adjust, ATH.s[sfb_s], ATH.floor);\n            } else {\n                 ath_band = ATH.adjust * ATH.s[sfb_s];\n            }\n\n            // Process the 3 windows (sub-blocks) for this short sfb\n            for (let b = 0; b < 3; b++) {\n                let en0 = 0.0; let xmin;\n                const rh1 = ath_band / width; // ATH per coefficient\n                let rh2 = DBL_EPSILON; // Accumulated noise estimate\n                if(width > 0) {\n                    let l = width >> 1;\n                    do {\n                        const xa = xr[j] * xr[j]; en0 += xa; rh2 += Math.min(xa, rh1); j++;\n                        const xb = xr[j] * xr[j]; en0 += xb; rh2 += Math.min(xb, rh1); j++;\n                    } while (--l > 0);\n                    // if(width & 1) { const xa = xr[j] * xr[j]; en0 += xa; rh2 += Math.min(xa, rh1); j++; }\n                }\n\n                if (en0 > ath_band) ath_over++;\n\n                // Apply nsPsy tuning factor adjustment (specific sfb index?)\n                 if (sfb_s === Encoder.SBPSY_s) { // Check index for last psy short band\n                     const x = ath_band * gfc.nsPsy.shortfact[sfb_s];\n                     if (rh2 < x) rh2 = x;\n                 }\n\n                // Set initial xmin based on ATH\n                xmin = (enable_athaa_fix !== 0) ? rh2 : ath_band;\n\n                // Add masking threshold component if not ATHonly/ATHshort mode\n                if (!gfp.ATHonly && !gfp.ATHshort) {\n                    const mask_en = ratio.en.s[sfb_s][b];\n                    if (mask_en > 0.0) {\n                        let mask_thr = en0 * ratio.thm.s[sfb_s][b] * masking_lower / mask_en;\n                         if (enable_athaa_fix !== 0) mask_thr *= gfc.nsPsy.shortfact[sfb_s];\n                        if (xmin < mask_thr) xmin = mask_thr;\n                    }\n                }\n\n                // Store final xmin (apply nsPsy factor if not MTRH fix)\n                 pxmin[pxminPos++] = (enable_athaa_fix !== 0) ? xmin : xmin * gfc.nsPsy.shortfact[sfb_s];\n\n                gsfb++; // Increment combined index for each window\n            } // End window loop (b)\n\n            // Temporal masking adjustment (apply decay between windows of same sfb)\n            if (gfp.useTemporal) {\n                if (pxmin[pxminPos - 3] > pxmin[pxminPos - 2]) pxmin[pxminPos - 2] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 2]) * gfc.decay;\n                if (pxmin[pxminPos - 2] > pxmin[pxminPos - 1]) pxmin[pxminPos - 1] += (pxmin[pxminPos - 2] - pxmin[pxminPos - 1]) * gfc.decay;\n            }\n\n            sfb_s++; // Increment short block sfb index\n        } // End short block sfb loop\n\n        return ath_over; // Return count of bands where energy exceeded ATH\n    }\n\n\n    /**\n     * Helper class for calc_noise_core to pass index by reference.\n     * @private\n     */\n    _StartLine = class { constructor(j) { this.s = j; } };\n\n\n    /**\n     * Core calculation of quantization noise power for a scalefactor band.\n     * Noise = Sum[ (|xr[i]| - quantized_xr[i])^2 ]\n     * where quantized_xr depends on the quantization step (`step`) and the\n     * quantized value (`ix[i]`). Handles different quantization regions (big_values, count1).\n     *\n     * @public\n     * @param {GrInfo} cod_info - Granule info containing spectral data (`xr`) and quantized values (`l3_enc`).\n     * @param {object} startline - Input/Output: Object `{s: number}` holding the starting index into `xr` and `l3_enc`. Updated after processing.\n     * @param {number} l - Number of coefficient *pairs* to process (width / 2).\n     * @param {number} step - Quantization step size (linear scale, from `_POW20(s)`).\n     * @returns {number} Total noise power (sum of squared errors) for the processed coefficients.\n     */\n    calc_noise_core(cod_info, startline, l, step) {\n        let noise = 0.0;\n        let j = startline.s; // Current index in xr/l3_enc\n        const ix = cod_info.l3_enc; // Quantized values\n        const xr_abs = cod_info.xr; // Original spectral values (absolute values used here)\n\n        // Determine which quantization region the current index falls into\n        if (j >= cod_info.count1) { // Region 2: ix[j] = 0 or 1 (abs value < 1.5*step?) - Not possible here? count1 is boundary.\n            // This region seems to be where ix[j] == 0. The error is just xr[j]^2.\n            while (l-- > 0) {\n                let temp;\n                temp = xr_abs[j]; j++; noise += temp * temp; // ix[j-1] assumed 0\n                temp = xr_abs[j]; j++; noise += temp * temp; // ix[j-1] assumed 0\n            }\n        } else if (j >= cod_info.big_values) { // Region 1: ix[j] = 0 or 1\n            const ix01 = [0.0, step]; // Dequantized values for ix=0 and ix=1\n            while (l-- > 0) {\n                let temp;\n                // Error = |xr| - dequantized_value(|xr|)\n                temp = Math.abs(xr_abs[j]) - ix01[ix[j]]; j++; noise += temp * temp;\n                temp = Math.abs(xr_abs[j]) - ix01[ix[j]]; j++; noise += temp * temp;\n            }\n        } else { // Region 0 (big_values): ix[j] > 1\n            // Dequantized value = (ix[j])^(4/3) * step\n            while (l-- > 0) {\n                 let temp;\n                 // Check index bounds for pow43\n                 const ix_val_0 = ix[j];\n                 const dequant_0 = (ix_val_0 < PRECALC_SIZE) ? pow43[ix_val_0] * step : Math.pow(ix_val_0, 4.0/3.0) * step; // Fallback if index too high\n                 temp = Math.abs(xr_abs[j]) - dequant_0; j++; noise += temp * temp;\n\n                 const ix_val_1 = ix[j];\n                 const dequant_1 = (ix_val_1 < PRECALC_SIZE) ? pow43[ix_val_1] * step : Math.pow(ix_val_1, 4.0/3.0) * step;\n                 temp = Math.abs(xr_abs[j]) - dequant_1; j++; noise += temp * temp;\n            }\n        }\n\n        startline.s = j; // Update index in the passed object\n        return noise;\n    }\n\n    /**\n     * Calculates the quantization noise relative to the allowed noise (`l3_xmin`)\n     * for each scalefactor band. Populates the `distort` array where `distort[sfb] = noise / l3_xmin[sfb]`.\n     * Also calculates overall noise metrics (total noise, noise over threshold, max noise)\n     * and stores them in the `res` object. Can optionally use/update `prev_noise` cache.\n     *\n     * @public\n     * @param {GrInfo} cod_info - Granule info containing quantization results and parameters.\n     * @param {Float32Array} l3_xmin - Array [SBMAX] of allowed noise per scalefactor band.\n     * @param {Float32Array} distort - Output: Array [SBMAX] to store the noise ratio (noise/xmin) per band.\n     * @param {CalcNoiseResult} res - Output: Object to store overall noise metrics (`over_count`, `tot_noise`, `over_noise`, `max_noise`, `over_SSD`).\n     * @param {CalcNoiseData|null} prev_noise - Optional Input/Output: Cache for noise values from previous iteration with same global gain. Can speed up repeated calculations.\n     * @returns {number} `over_count`: Number of bands where noise > allowed noise (distort > 1).\n     */\n    calc_noise(cod_info, l3_xmin, distort, res, prev_noise) {\n        let distortPos = 0; // Index for distort array\n        let l3_xminPos = 0; // Index for l3_xmin array\n        let over = 0; // Count of distorted bands\n        let over_noise_db = 0.0; // Sum of dB noise for distorted bands\n        let tot_noise_db = 0.0; // Sum of dB noise for all bands\n        let max_noise = -20.0; // Max noise in dB relative to xmin (-200 dB)\n        let j = 0; // Index into spectral data xr[]\n        const scalefac = cod_info.scalefac;\n        let scalefacPos = 0; // Index for scalefac array\n\n        res.over_SSD = 0.0; // Sum of squared distortions for over-noise bands (integer scale)\n\n        // Check if prev_noise cache is valid for this global_gain\n        const use_prev = prev_noise != null && prev_noise.global_gain === cod_info.global_gain;\n\n        // Iterate over psychoacoustic scalefactor bands\n        for (let sfb = 0; sfb < cod_info.psymax; sfb++) {\n            let s; // Effective gain = global_gain - scalefac_gain - subblock_gain\n            let noise_power = 0.0; // Noise power for this band (linear)\n            let noise_db = 0.0; // Noise power relative to xmin (dB * 10)\n\n            // Calculate effective gain 's'\n            s = cod_info.global_gain -\n                (((scalefac[scalefacPos++]) + (cod_info.preflag !== 0 ? this.pretab[sfb] : 0)) << (cod_info.scalefac_scale + 1)) -\n                (cod_info.subblock_gain[cod_info.window[sfb]] * 8);\n\n            // Check cache or calculate noise\n            if (use_prev && prev_noise.step[sfb] === s) {\n                // Use cached values\n                noise_power = prev_noise.noise[sfb];\n                noise_db = prev_noise.noise_log[sfb];\n                j += cod_info.width[sfb]; // Advance spectral data index\n                distort[distortPos++] = noise_power / l3_xmin[l3_xminPos++]; // Calculate distortion ratio\n            } else {\n                // Calculate noise from scratch\n                const step = this._POW20(s); // Get linear quantization step size\n                let width = cod_info.width[sfb];\n                let l = width >> 1; // Number of pairs\n                let start_idx = j;\n\n                // Adjust length if band crosses max_nonzero_coeff boundary\n                if ((j + width) > cod_info.max_nonzero_coeff) {\n                    const usefullsize = cod_info.max_nonzero_coeff - j + 1;\n                    l = (usefullsize > 0) ? usefullsize >> 1 : 0;\n                    // Handle odd usefullsize? calc_noise_core expects pairs.\n                    // If usefullsize is odd, the last coeff is processed by calc_noise_core? Check logic.\n                    // Assuming calc_noise_core handles this.\n                }\n                if (l < 0) l = 0; // Ensure non-negative length\n\n                // Calculate noise power using core function\n                 let sl_obj = new this._StartLine(start_idx);\n                 noise_power = this.calc_noise_core(cod_info, sl_obj, l, step);\n                 j = sl_obj.s; // Update spectral data index\n\n                // Store calculated values in cache if provided\n                if (prev_noise != null) {\n                    prev_noise.step[sfb] = s;\n                    prev_noise.noise[sfb] = noise_power;\n                }\n\n                // Calculate distortion ratio and noise in dB\n                distort[distortPos++] = noise_power / l3_xmin[l3_xminPos++];\n                noise_db = Util.FAST_LOG10(Math.max(distort[distortPos - 1], 1E-20)); // Use distortion ratio for dB calc\n\n                if (prev_noise != null) {\n                    prev_noise.noise_log[sfb] = noise_db;\n                }\n            }\n\n            // Update overall noise metrics\n            tot_noise_db += noise_db;\n            if (noise_db > 0.0) { // If distorted (noise > xmin)\n                 // Calculate integer measure of distortion for over_SSD\n                 const tmp = Math.max(Math.floor(noise_db * 10.0 + 0.5), 1); // Round dB*10 to nearest int, min 1\n                 res.over_SSD += tmp * tmp; // Add squared value\n\n                 over++; // Increment distorted band count\n                 over_noise_db += noise_db; // Sum dB noise of distorted bands\n            }\n            max_noise = Math.max(max_noise, noise_db); // Track max noise (dB)\n\n        } // End sfb loop\n\n        // Store final metrics in result object\n        res.over_count = over;\n        res.tot_noise = tot_noise_db;\n        res.over_noise = over_noise_db;\n        res.max_noise = max_noise;\n\n        // Update cache global gain marker if cache was used\n        if (prev_noise != null) {\n            prev_noise.global_gain = cod_info.global_gain;\n        }\n\n        return over; // Return distorted band count\n    }\n\n    /**\n     * Updates the `gfc.pinfo` structure with detailed plotting/analysis data\n     * for a specific granule/channel based on the final quantization results.\n     * Calculates energy, masking threshold, and quantization noise per scalefactor band.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} cod_info - Granule info containing final quantization results.\n     * @param {object} ratio - Masking ratio structure for the granule/channel.\n     * @param {number} gr - Granule index (0 or 1).\n     * @param {number} ch - Channel index (0 or 1).\n     */\n    set_pinfo(gfp, cod_info, ratio, gr, ch) {\n        const gfc = gfp.internal_flags;\n        let sfb, sfb2; // Scalefactor band indices\n        let l; // Loop counter for spectral lines\n        let en0; // Energy per coefficient or band\n        const ifqstep = (cod_info.scalefac_scale === 0) ? 0.5 : 1.0; // Scalefactor step size factor\n        const scalefac = cod_info.scalefac; // Final scalefactors\n\n        // Temporary arrays for intermediate calculations\n        const l3_xmin = new_float(L3Side.SFBMAX); // Allowed noise per band\n        const distort = new_float(L3Side.SFBMAX); // Noise/xmin ratio per band\n        const noise_res = new CalcNoiseResult(); // Overall noise metrics\n\n        // Recalculate allowed noise and actual distortion for plotting\n        this.calc_xmin(gfp, ratio, cod_info, l3_xmin);\n        this.calc_noise(cod_info, l3_xmin, distort, noise_res, null); // Use final cod_info\n\n        const pinfo = gfc.pinfo; // Shortcut to plotting info structure\n        let j = 0; // Index into spectral data xr[]\n\n        // Determine upper sfb limit based on block type\n        sfb2 = cod_info.sfb_lmax; // Default limit for mixed/short\n        if (cod_info.block_type !== Encoder.SHORT_TYPE && cod_info.mixed_block_flag === 0) {\n            sfb2 = 22; // Full long block limit\n        }\n\n        // --- Process Long Bands ---\n        for (sfb = 0; sfb < sfb2; sfb++) {\n            const start = gfc.scalefac_band.l[sfb];\n            const end = gfc.scalefac_band.l[sfb + 1];\n            const bw = end - start; // Bandwidth (number of coefficients)\n            if (bw === 0) continue; // Skip zero-width bands\n\n            // Calculate energy in the band\n            en0 = 0.0;\n            for (l = start; l < end; l++) { // Use temp index l\n                en0 += cod_info.xr[l] * cod_info.xr[l];\n            }\n            j = end; // Update main spectral index j\n            en0 /= bw; // Average energy per coefficient\n\n            // Store energy, noise, and threshold for plotting (scaled)\n            const plot_scale = 1e15; // Arbitrary scale factor for visibility\n            pinfo.en[gr][ch][sfb] = plot_scale * en0;\n            // Store scaled noise = scaled_xmin * distortion_ratio / bw\n            pinfo.xfsf[gr][ch][sfb] = plot_scale * l3_xmin[sfb] * distort[sfb] / bw;\n\n            // Calculate masking threshold (considering ATHonly mode)\n            let thr0 = gfc.ATH.l[sfb]; // Start with ATH\n            if (!gfp.ATHonly) {\n                const ratio_en = ratio.en.l[sfb];\n                if (ratio_en > 0) {\n                    // Masking threshold = (Energy / MaskRatioEnergy) * MaskRatioThreshold * MaskingLower? No.\n                    // Masking threshold = Energy * (MaskRatioThreshold / MaskRatioEnergy) * MaskingLower\n                    // Ratio.thm seems to be already Thm/En? Check PSY model. Assume Ratio.thm = Thresh/Energy.\n                    // thr = Energy * Ratio.thm (where Ratio.thm incorporates masking_lower?)\n                    // Let's re-evaluate C: en0 = en0 / ratio.en.l[sfb] => en0 = (Sum(xr^2)/bw) / ratio.en.l[sfb]\n                    // thr = max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb])\n                    // This implies threshold = max( (Sum(xr^2)/bw) / ratio.en * ratio.thm, ATH )\n                    // This seems wrong dimensionally unless ratio.en=Sum(xr^2) and ratio.thm=ThresholdPower.\n                    // Let's assume: thr = max(ratio.thm.l[sfb] * gfc.masking_lower?, ATH.l[sfb])\n                    // Revisit C: calc_xmin uses: xmin = max(ATH, en0*ratio.thm/ratio.en * masking_lower)\n                    // This plot calculation seems different. Let's trust the C plot code for now.\n                    let thr_mask = 0.0;\n                    if(ratio.en.l[sfb] > 0) {\n                        thr_mask = (en0 / ratio.en.l[sfb]) * ratio.thm.l[sfb]; // Is ratio.thm already scaled by masking_lower? Assume yes based on calc_xmin structure.\n                    }\n                    thr0 = Math.max(thr_mask, gfc.ATH.l[sfb]);\n\n                } // else: use ATH only if no energy in ratio\n            }\n            pinfo.thr[gr][ch][sfb] = plot_scale * thr0;\n\n            // Store effective scalefactor gain (dB-like?)\n            pinfo.LAMEsfb[gr][ch][sfb] = 0.0; // Initialize\n            if (cod_info.preflag !== 0 && sfb >= 11) {\n                pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * this.pretab[sfb]; // Subtract preemphasis gain\n            }\n            if (sfb < Encoder.SBPSY_l) { // Only apply scalefac if within psych limit\n                assert(scalefac[sfb] >= 0, `Negative scalefactor found: sfb=${sfb}, val=${scalefac[sfb]}`);\n                pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb]; // Subtract scalefactor gain\n            }\n        } // End long band loop\n\n        // --- Process Short Bands (if applicable) ---\n        if (cod_info.block_type === Encoder.SHORT_TYPE) {\n            let sfb_plot_idx = sfb2; // Continue combined index from long bands\n            for (sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                const start = gfc.scalefac_band.s[sfb];\n                const end = gfc.scalefac_band.s[sfb + 1];\n                const bw = end - start;\n                if (bw === 0) continue;\n\n                // Process 3 windows\n                for (let i = 0; i < 3; i++) {\n                    // Calculate energy for this window/sfb\n                    en0 = 0.0;\n                    // Need correct index 'j' into reordered xr[]\n                    // C code just continues 'j'. Let's assume j is correct after long block loop.\n                    const window_start_j = j;\n                    for (l = 0; l < bw; l++) { // Iterate through coeffs for this window/sfb\n                         en0 += cod_info.xr[j] * cod_info.xr[j];\n                         j++;\n                    }\n                    en0 = Math.max(en0 / bw, 1e-20); // Average energy per coeff\n\n                    const plot_idx = 3 * sfb + i; // Index for plotting arrays (interleaved)\n                    const plot_scale = 1e15;\n\n                    // Store plotting data for this short sub-band\n                    pinfo.en_s[gr][ch][plot_idx] = plot_scale * en0;\n                    // Store scaled noise\n                    pinfo.xfsf_s[gr][ch][plot_idx] = plot_scale * l3_xmin[sfb_plot_idx] * distort[sfb_plot_idx] / bw;\n\n                    // Calculate masking threshold\n                    let thr0 = gfc.ATH.s[sfb]; // Start with ATH (scaled by bw in _compute_ath?) Check ATH units. Assume ATH.s is per-band power.\n                    if (!gfp.ATHonly && !gfp.ATHshort) {\n                        const ratio_en = ratio.en.s[sfb][i];\n                        if(ratio_en > 0) {\n                             const thr_mask = (en0 / ratio_en) * ratio.thm.s[sfb][i]; // Similar dimension issue as long blocks\n                             thr0 = Math.max(thr_mask, gfc.ATH.s[sfb]);\n                        }\n                    }\n                    pinfo.thr_s[gr][ch][plot_idx] = plot_scale * thr0;\n\n                    // Store effective scalefactor gain\n                    pinfo.LAMEsfb_s[gr][ch][plot_idx] = -2.0 * cod_info.subblock_gain[i]; // Subblock gain component\n                    if (sfb < Encoder.SBPSY_s) { // Apply scalefac only within psy limit\n                         pinfo.LAMEsfb_s[gr][ch][plot_idx] -= ifqstep * scalefac[sfb_plot_idx]; // Scalefactor component\n                    }\n                    sfb_plot_idx++; // Increment combined index\n                } // End window loop (i)\n            } // End short sfb loop\n        } // End if short block\n\n        // Store overall granule/channel info\n        pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n        pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length + cod_info.part2_length; // Huffman + Scalefactors\n        pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length; // Scalefactor bits only\n        pinfo.over[gr][ch] = noise_res.over_count;\n        pinfo.max_noise[gr][ch] = noise_res.max_noise * 10.0; // Scale dB*10 to dB\n        pinfo.over_noise[gr][ch] = noise_res.over_noise * 10.0;\n        pinfo.tot_noise[gr][ch] = noise_res.tot_noise * 10.0;\n        pinfo.over_SSD[gr][ch] = noise_res.over_SSD;\n    }\n\n     /**\n      * Updates plotting data for a whole frame by calling set_pinfo for each granule/channel.\n      * Handles SCFSI scalefactor reconstruction for granule 1.\n      * @private\n      */\n     _set_frame_pinfo(gfp, ratio) {\n        const gfc = gfp.internal_flags;\n        gfc.masking_lower = 1.0; // Reset masking adjustment for plotting?\n\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                const cod_info = gfc.l3_side.tt[gr][ch];\n                const scalefac_sav = new_int(L3Side.SFBMAX);\n                System.arraycopy(cod_info.scalefac, 0, scalefac_sav, 0, L3Side.SFBMAX); // Save original scalefactors\n\n                // Reconstruct scalefactors if SCFSI was used (only for gr=1)\n                if (gr === 1) {\n                    for (let sfb = 0; sfb < cod_info.sfb_lmax; sfb++) { // Check limit - should cover all possible SCFSI bands\n                        if (cod_info.scalefac[sfb] < 0) { // SCFSI flag stored as negative? Check spec/tk code. Assume yes.\n                            cod_info.scalefac[sfb] = gfc.l3_side.tt[0][ch].scalefac[sfb]; // Copy from granule 0\n                        }\n                    }\n                     // Need similar logic for short block scalefactors if applicable? Assume covered by sfb_lmax.\n                }\n\n                // Set plotting info using (potentially reconstructed) scalefactors\n                this.set_pinfo(gfp, cod_info, ratio[gr][ch], gr, ch);\n\n                // Restore original scalefactors\n                System.arraycopy(scalefac_sav, 0, cod_info.scalefac, 0, L3Side.SFBMAX);\n            }\n        }\n    }\n\n} // End class QuantizePVT\n\n\n// Export the class\nexport { QuantizePVT };","/**\n * @fileoverview MP3 Huffman table selecting and bit counting logic.\n * Ported from takehiro.c.\n * Uses ES Module syntax.\n *\n * @module Takehiro\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { Encoder } from './Encoder.js';\nimport { Tables, ht, largetbl, table23, table56, bitrate_table } from './Tables.js'; // Import ht and other needed tables\nimport { GrInfo } from './GrInfo.js';\nimport { QuantizePVT } from './QuantizePVT.js';\n\n// Destructure common utilities for easier access\nconst {\n    System, VbrMode, Float, ShortBlock, Util, Arrays, new_array_n, new_byte,\n    new_double, new_float, new_float_n, new_int, new_int_n, assert\n} = common;\n\n// --- Module Scope Constants/Tables ---\n\n/**\n * Scalefactor length table 1 (based on scalefac_compress index).\n * @const {number[]}\n */\nexport const slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n\n/**\n * Scalefactor length table 2 (based on scalefac_compress index).\n * @const {number[]}\n */\nexport const slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n\n/**\n * Precomputed table for subdv_table lookup.\n * @private\n * @const {number[][]}\n */\nconst subdv_table = [\n    [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 1], [1, 1], [1, 1], [1, 2],\n    [2, 2], [2, 3], [2, 3], [3, 4], [3, 4], [3, 4], [4, 5], [4, 5], [4, 6],\n    [5, 6], [5, 6], [5, 7], [6, 7], [6, 7]\n];\n\n/**\n * Huffman tables that don't use ESCape codes. Index is max value - 1.\n * @private\n * @const {number[]}\n */\nconst huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13, 13, 13, 13, 13, 13, 13];\n\n\n/**\n * Simple helper class to pass bit count by reference.\n * @private\n */\nclass Bits {\n    constructor(b = 0) {\n        this.bits = 0 | b;\n    }\n}\n\n/**\n * Placeholder/Simplified function to count sign bit.\n * Original C code might have done more complex Huffman length lookup.\n * @param {number} p - Quantized value.\n * @returns {number} 1 if p is non-zero, 0 otherwise.\n */\nexport function count_bit(p) {\n    return (p !== 0) ? 1 : 0;\n}\n\n\n/**\n * @classdesc Implements Huffman coding logic, including table selection\n * and bit counting for quantized spectral values and scalefactors.\n * @constructs Takehiro\n */\nclass Takehiro {\n    /** @private @type {QuantizePVT|null} */\n    qupvt = null;\n\n    constructor() {\n        // Module set externally\n    }\n\n    /**\n     * Sets the internal QuantizePVT module dependency.\n     * @public\n     * @param {QuantizePVT} _qupvt - Private quantization helpers module instance.\n     */\n    setModules(_qupvt) {\n        this.qupvt = _qupvt;\n    }\n\n    // --- Private Helper Methods ---\n    // (JSDoc omitted for brevity)\n\n    /** @private */\n    _quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n        assert(l > 0, `quantize_lines_xrpow length must be > 0: ${l}`);\n        l = l >> 1; // Process pairs\n        let remaining = l % 2; // Check C code logic - l is pair count, original C checks width&1? No, uses loop.\n        // Let's stick to pair processing logic.\n        l = l >> 1; // Process quads\n        while (l-- > 0) {\n            let x0 = xr[xrPos++] * istep; let x1 = xr[xrPos++] * istep;\n            let rx0 = Math.floor(x0); let rx1 = Math.floor(x1); // Use floor for integer part\n            let x2 = xr[xrPos++] * istep; let x3 = xr[xrPos++] * istep;\n            let rx2 = Math.floor(x2); let rx3 = Math.floor(x3);\n            // Clamp indices for adj43 lookup\n            rx0 = Math.max(0, Math.min(rx0, QuantizePVT.IXMAX_VAL + 1));\n            rx1 = Math.max(0, Math.min(rx1, QuantizePVT.IXMAX_VAL + 1));\n            rx2 = Math.max(0, Math.min(rx2, QuantizePVT.IXMAX_VAL + 1));\n            rx3 = Math.max(0, Math.min(rx3, QuantizePVT.IXMAX_VAL + 1));\n            x0 += this.qupvt.adj43[rx0]; x1 += this.qupvt.adj43[rx1];\n            ix[ixPos++] = Math.floor(x0); ix[ixPos++] = Math.floor(x1);\n            x2 += this.qupvt.adj43[rx2]; x3 += this.qupvt.adj43[rx3];\n            ix[ixPos++] = Math.floor(x2); ix[ixPos++] = Math.floor(x3);\n        }\n        // Process remaining pair if original width was odd multiple of 2\n         if (remaining !== 0) { // This check might be wrong, based on original loop structure\n            let x0 = xr[xrPos++] * istep; let x1 = xr[xrPos++] * istep;\n            let rx0 = Math.floor(x0); let rx1 = Math.floor(x1);\n            rx0 = Math.max(0, Math.min(rx0, QuantizePVT.IXMAX_VAL + 1));\n            rx1 = Math.max(0, Math.min(rx1, QuantizePVT.IXMAX_VAL + 1));\n            x0 += this.qupvt.adj43[rx0]; x1 += this.qupvt.adj43[rx1];\n            ix[ixPos++] = Math.floor(x0); ix[ixPos++] = Math.floor(x1);\n         }\n    }\n\n    /** @private */\n    _quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n        const compareval0 = (1.0 - 0.4054) / istep;\n        assert(l > 0);\n        l = l >> 1; // Process pairs\n        while (l-- > 0) {\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n        }\n    }\n\n    /** @private */\n    _ix_max(ix, ixPos, endPos) {\n        let max1 = 0, max2 = 0;\n        // Ensure endPos is valid\n        endPos = Math.min(endPos, ix.length);\n        ixPos = Math.min(ixPos, endPos); // Ensure start is not beyond end\n\n        while (ixPos < endPos) { // Use < for standard loop\n            const x1 = ix[ixPos++];\n            if (max1 < x1) max1 = x1;\n            if (ixPos < endPos) { // Check if second element exists\n                const x2 = ix[ixPos++];\n                if (max2 < x2) max2 = x2;\n            }\n        }\n        return Math.max(max1, max2);\n    }\n\n    /** @private */\n    _count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n        const linbits1 = ht[t1].xlen; const linbits2 = ht[t2].xlen;\n        let sum1 = 0, sum2 = 0;\n        let linbits_esc1 = (1 << linbits1) -1; // Max value before escape for table 1\n        let linbits_esc2 = (1 << linbits2) -1; // Max value before escape for table 2\n\n        while (ixPos < end) {\n            let x = ix[ixPos++]; let y = ix[ixPos++];\n            let xy1 = 0, xy2 = 0;\n            let current_bits1 = 0, current_bits2 = 0;\n            let esc1 = false, esc2 = false;\n\n            if (x !== 0) {\n                if (x > 14) { x = 15; esc1 = true; current_bits1 += linbits1; }\n                xy1 = x * 16;\n            }\n            if (y !== 0) {\n                if (y > 14) { y = 15; esc1 = true; current_bits1 += linbits1; }\n                xy1 += y;\n            }\n            current_bits1 += largetbl[xy1] >> 16; // Get length from table 1 (upper 16 bits)\n\n            // Repeat for table 2\n             x = ix[ixPos-2]; y = ix[ixPos-1]; // Re-read original values\n             if (x !== 0) {\n                if (x > 14) { x = 15; esc2 = true; current_bits2 += linbits2; }\n                xy2 = x * 16;\n             }\n             if (y !== 0) {\n                if (y > 14) { y = 15; esc2 = true; current_bits2 += linbits2; }\n                xy2 += y;\n             }\n             current_bits2 += largetbl[xy1] & 0xffff; // Get length from table 2 (lower 16 bits) - Use xy1 index? C uses largetbl[x]\n\n             // C code uses largetbl[x] where x is xy1. Let's use that.\n             sum1 += current_bits1;\n             sum2 += current_bits2;\n\n        } // end while\n\n        let best_sum = sum1;\n        let best_table = t1;\n        if (sum1 > sum2) {\n            best_sum = sum2;\n            best_table = t2;\n        }\n\n        s.bits += best_sum;\n        return best_table;\n    }\n\n    /** @private */\n    _count_bit_noESC(ix, ixPos, end, s) {\n        let sum1 = 0;\n        const hlen1 = ht[1].hlen; // Table 1 lengths\n        while (ixPos < end) {\n            const x = ix[ixPos] * 2 + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n        }\n        s.bits += sum1;\n        return 1; // Always uses table 1\n    }\n\n    /** @private */\n    _count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n        let sum1 = 0, sum2 = 0;\n        const xlen = ht[t1].xlen;\n        const hlen_combined = (t1 === 2) ? table23 : table56;\n\n        while (ixPos < end) {\n            const x = ix[ixPos] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            const combined_len = hlen_combined[x];\n            sum1 += combined_len >> 16;   // Length from table t1\n            sum2 += combined_len & 0xffff; // Length from table t1+1\n        }\n\n        let best_sum = sum1;\n        let best_table = t1;\n        if (sum1 > sum2) {\n            best_sum = sum2;\n            best_table = t1 + 1;\n        }\n        s.bits += best_sum;\n        return best_table;\n    }\n\n    /** @private */\n    _count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n        let sum1 = 0, sum2 = 0, sum3 = 0;\n        const xlen = ht[t1].xlen;\n        const hlen1 = ht[t1].hlen;\n        const hlen2 = ht[t1 + 1].hlen;\n        const hlen3 = ht[t1 + 2].hlen;\n\n        while (ixPos < end) {\n            const x = ix[ixPos] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n            sum2 += hlen2[x];\n            sum3 += hlen3[x];\n        }\n\n        let best_sum = sum1;\n        let best_table = t1;\n        if (best_sum > sum2) { best_sum = sum2; best_table = t1 + 1; }\n        if (best_sum > sum3) { best_sum = sum3; best_table = t1 + 2; }\n\n        s.bits += best_sum;\n        return best_table;\n    }\n\n    /** @private */\n    _choose_table(ix, ixPos, endPos, s) {\n        const max = this._ix_max(ix, ixPos, endPos);\n\n        switch (max) {\n            case 0: return 0; // Table 0 for all zeros\n            case 1: return this._count_bit_noESC(ix, ixPos, endPos, s);\n            case 2: case 3:\n                return this._count_bit_noESC_from2(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n            case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15:\n                return this._count_bit_noESC_from3(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n            default:\n                if (max > QuantizePVT.IXMAX_VAL) { s.bits = LARGE_BITS; return -1; } // Value too large\n                // Find best ESC tables (16-23 and 24-31)\n                let choice2 = 24; for (; choice2 < 32; choice2++) if (ht[choice2].linmax >= max - 15) break;\n                let choice1 = 16; for (; choice1 < 24; choice1++) if (ht[choice1].linmax >= max - 15) break;\n                return this._count_bit_ESC(ix, ixPos, endPos, choice1, choice2, s);\n        }\n    }\n\n     /** @private */\n     _recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        const bigv = cod_info.big_values;\n        Arrays.fill(r01_bits, QuantizePVT.LARGE_BITS); // Initialize with large value\n\n        for (let r0 = 0; r0 < 16; r0++) { // region0 possible sizes (0..15 sfbs)\n             const a1 = gfc.scalefac_band.l[r0 + 1]; // End of region0\n             if (a1 >= bigv) break; // No point if region0 end exceeds bigvalues\n\n             let r0bits = 0; const bi0 = new Bits(r0bits);\n             const r0t = this._choose_table(ix, 0, a1, bi0);\n             r0bits = bi0.bits;\n             if(r0t < 0) continue; // Skip if error in choosing table\n\n             for (let r1 = 0; r1 < 8; r1++) { // region1 possible sizes (0..7 sfbs)\n                 const a2 = gfc.scalefac_band.l[r0 + r1 + 2]; // End of region1\n                 if (a2 >= bigv) break; // No point if region1 end exceeds bigvalues\n\n                 let bits = r0bits; const bi1 = new Bits(bits);\n                 const r1t = this._choose_table(ix, a1, a2, bi1);\n                 bits = bi1.bits;\n                 if(r1t < 0) continue; // Skip if error\n\n                 const region_boundary_index = r0 + r1; // Combined size index\n                 if (r01_bits[region_boundary_index] > bits) {\n                     r01_bits[region_boundary_index] = bits;\n                     r01_div[region_boundary_index] = r0; // Store best size for region0\n                     r0_tbl[region_boundary_index] = r0t;\n                     r1_tbl[region_boundary_index] = r1t;\n                 }\n             }\n        }\n    }\n\n    /** @private */\n    _recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        const bigv = cod_info2.big_values;\n\n        // Iterate through possible end points of region 1 (r2 = r0+r1+2)\n        for (let r2_idx = 0; r2_idx <= 7 + 15; r2_idx++) { // r2_idx = r0+r1\n             if(r01_bits[r2_idx] >= LARGE_BITS) continue; // Skip if no valid r0/r1 combo found\n\n             const r2_sfb_idx = r2_idx + 2; // Scalefactor band index for end of region 1\n             const a2 = gfc.scalefac_band.l[r2_sfb_idx]; // Start index of region 2\n             if (a2 >= bigv) continue; // No region 2 needed if start is beyond bigvalues\n\n             let bits = r01_bits[r2_idx] + cod_info2.count1bits; // Add count1 bits\n             if (gi.part2_3_length <= bits) continue; // Already worse than current best\n\n             const bi2 = new Bits(bits);\n             const r2t = this._choose_table(ix, a2, bigv, bi2); // Calculate bits for region 2\n             bits = bi2.bits;\n              if(r2t < 0) continue; // Skip if error\n\n             // If this division is better than the current best total\n             if (gi.part2_3_length > bits) {\n                 gi.assign(cod_info2); // Update best with current state (only count1 differs)\n                 gi.part2_3_length = bits; // Store new best bit count\n                 gi.region0_count = r01_div[r2_idx];\n                 gi.region1_count = r2_idx - gi.region0_count;\n                 gi.table_select[0] = r0_tbl[r2_idx];\n                 gi.table_select[1] = r1_tbl[r2_idx];\n                 gi.table_select[2] = r2t;\n             }\n        }\n    }\n\n    // --- Public Methods ---\n\n    /**\n     * Nonlinear quantization of xr elements based on xr^(3/4).\n     * Modifies the `ix` array in place.\n     *\n     * @public\n     * @param {number} l - Number of elements to process (must be even).\n     * @param {number} istep - Inverse quantization step size (1 / (2^(gain/4))).\n     * @param {Float32Array} xr - Input array containing xr^(3/4) values.\n     * @param {number} xrPos - Starting position in `xr`.\n     * @param {Int32Array} ix - Output array to store quantized integer values.\n     * @param {number} ixPos - Starting position in `ix`.\n     */\n    quantize_lines_xrpow = this._quantize_lines_xrpow; // Expose private method directly\n\n    /**\n     * Quantization for values expected to be 0 or 1. Faster than full quantization.\n     * Modifies the `ix` array in place.\n     *\n     * @public\n     * @param {number} l - Number of elements to process (must be even).\n     * @param {number} istep - Inverse quantization step size.\n     * @param {Float32Array} xr - Input array containing xr^(3/4) values.\n     * @param {number} xrPos - Starting position in `xr`.\n     * @param {Int32Array} ix - Output array to store quantized integer values (0 or 1).\n     * @param {number} ixPos - Starting position in `ix`.\n     */\n    quantize_lines_xrpow_01 = this._quantize_lines_xrpow_01;\n\n    /**\n     * Performs quantization on the `xrpow` data (`xr^(3/4)`) using the current\n     * scalefactors and global gain from `codInfo`. Stores results in `codInfo.l3_enc`.\n     * Uses cached noise data (`prevNoise`) if applicable.\n     *\n     * @public\n     * @param {Float32Array} xp - `xrpow` array (input).\n     * @param {Int32Array} pi - `l3_enc` array (output).\n     * @param {number} istep - Inverse quantization step size.\n     * @param {GrInfo} codInfo - Granule information (input/output).\n     * @param {CalcNoiseData | null} prevNoise - Cached noise data from previous iteration.\n     */\n    quantize_xrpow = this._quantize_xrpow;\n\n    /**\n     * Counts the number of bits needed to encode the quantized values (`l3_enc`)\n     * WITHOUT performing quantization again. Determines Huffman table selections,\n     * `big_values`, `count1`, and `count1bits`.\n     *\n     * @public\n     * @param {LameInternalFlags} gfc - LAME internal flags.\n     * @param {GrInfo} gi - Granule information containing `l3_enc` and block type info. Modified in place.\n     * @param {CalcNoiseData | null} prev_noise - Noise cache data (used to update sfb_count1).\n     * @returns {number} Total bits required for Huffman coding (part3).\n     */\n    noquant_count_bits(gfc, gi, prev_noise) {\n        const ix = gi.l3_enc;\n        let i = gi.max_nonzero_coeff + 1; // Start from one past the last non-zero\n        if(i & 1) i++; // Ensure even index to start search from pair boundary\n        i = Math.min(576, i); // Clamp to max index\n\n        if (prev_noise != null) prev_noise.sfb_count1 = 0; // Reset cache info\n\n        // Determine count1 region (where all ix <= 1)\n        for (; i > 1; i -= 2) {\n            if ((ix[i - 1] | ix[i - 2]) !== 0) break; // Found last non-zero pair\n        }\n        gi.count1 = i; // i is the start index of the all-zero region\n\n        // Determine count1 Huffman coding bits (quadruples of 0/1)\n        let a1 = 0; let a2 = 0;\n        let quad_idx = i; // Start from end of count1 region\n        for (; quad_idx > 3; quad_idx -= 4) {\n            // Check if any value in the quad is > 1\n            if (((ix[quad_idx - 1] | ix[quad_idx - 2] | ix[quad_idx - 3] | ix[quad_idx - 4])) > 1) {\n                break; // End of quadruples region\n            }\n            // Calculate packed value and add bits for tables 32 and 33\n            const p = ((ix[quad_idx - 4] * 3 + ix[quad_idx - 3]) * 3 + ix[quad_idx - 2]) * 3 + ix[quad_idx - 1]; // Corrected packing? Check C vs Huffman table format. Assume C is correct for now.\n            // Let's use the bitwise packing from C:\n            // p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n            const p_idx = ((ix[quad_idx - 4] << 3) | (ix[quad_idx - 3] << 2) | (ix[quad_idx - 2] << 1) | ix[quad_idx - 1]); // Simpler index?\n             // Need to map p_idx to the correct index in t32l/t33l if they are not direct lookups.\n             // Assuming Tables.t32l/t33l are direct lookups based on the packed value p:\n             const packed_val = ((ix[quad_idx - 4] * 3 + ix[quad_idx - 3]) * 3 + ix[quad_idx - 2]) * 3 + ix[quad_idx - 1]; // Revert to C packing if needed\n             const p_idx_c = ((ix[quad_idx - 4] * 2 + ix[quad_idx - 3]) * 2 + ix[quad_idx - 2]) * 2 + ix[quad_idx - 1];\n\n             if(p_idx_c >= 0 && p_idx_c < Tables.t32l.length && p_idx_c < Tables.t33l.length){\n                a1 += Tables.t32l[p_idx_c];\n                a2 += Tables.t33l[p_idx_c];\n             } else {\n                 console.error(\"Invalid index for count1 tables:\", p_idx_c);\n                 // Handle error or break?\n             }\n        }\n        // quad_idx now marks the start of the big_values region\n        gi.big_values = quad_idx;\n\n        // Choose best count1 table (32 or 33)\n        let bits = a1; gi.count1table_select = 0;\n        if (a1 > a2) { bits = a2; gi.count1table_select = 1; }\n        gi.count1bits = bits; // Store bits used for count1 region\n\n        if (gi.big_values === 0) return bits; // Only count1 region exists\n\n        // Determine region boundaries for big_values\n        let region0_end = 0, region1_end = 0; // Indices into xr/ix\n        if (gi.block_type === Encoder.SHORT_TYPE) {\n             // Short blocks have fixed regions (relative to start of short data?)\n             // Need gfc context here. Assuming gfc is accessible (passed externally or via 'this').\n             // This logic likely needs access to gfc passed as argument. Refactoring needed.\n             // Let's assume NORM_TYPE logic for now, short block needs GFC access.\n             console.warn(\"Short block region calculation in noquant_count_bits needs gfc context.\");\n             region0_end = Math.min(gi.big_values, 3 * gfc.scalefac_band.s[3]); // Example guess\n             region1_end = gi.big_values;\n\n        } else if (gi.block_type === Encoder.NORM_TYPE) {\n            assert(gi.big_values <= 576, \"big_values out of bounds\");\n             if (gi.big_values >= 2) { // Need at least 2 values for lookup\n                 // Look up precalculated region boundaries based on big_values end index\n                 gi.region0_count = gfc.bv_scf[gi.big_values - 2]; // region0 size in sfbs\n                 gi.region1_count = gfc.bv_scf[gi.big_values - 1]; // region1 size in sfbs\n             } else {\n                 gi.region0_count = 0;\n                 gi.region1_count = 0;\n             }\n             // Clamp region sizes\n             const max_region0_size = Encoder.SBPSY_l - 1; // Max sfb index for region0\n             if(gi.region0_count > max_region0_size) gi.region0_count = max_region0_size;\n             const max_region1_size = Encoder.SBPSY_l - gi.region0_count - 1;\n             if(gi.region1_count > max_region1_size) gi.region1_count = max_region1_size;\n\n             region0_end = gfc.scalefac_band.l[gi.region0_count + 1];\n             region1_end = gfc.scalefac_band.l[gi.region0_count + gi.region1_count + 2];\n\n        } else { // Mixed block (START/STOP types)\n            gi.region0_count = 7;\n            gi.region1_count = Encoder.SBMAX_l - 1 - 7 - 1; // SBMAX_l or SBPSY_l? Using SBMAX_l from C.\n            region0_end = gfc.scalefac_band.l[gi.region0_count + 1];\n            region1_end = gi.big_values; // Region 2 doesn't exist or is handled differently\n        }\n\n        // Ensure region ends don't exceed big_values start\n        region0_end = Math.min(region0_end, gi.big_values);\n        region1_end = Math.min(region1_end, gi.big_values);\n\n        // Count bits for regions 0, 1, 2\n        if (region0_end > 0) {\n             let bi = new Bits(bits);\n             gi.table_select[0] = this._choose_table(ix, 0, region0_end, bi);\n             bits = bi.bits;\n        }\n        if (region1_end > region0_end) {\n             let bi = new Bits(bits);\n             gi.table_select[1] = this._choose_table(ix, region0_end, region1_end, bi);\n             bits = bi.bits;\n        }\n        if (gi.big_values > region1_end) { // Region 2\n             let bi = new Bits(bits);\n             gi.table_select[2] = this._choose_table(ix, region1_end, gi.big_values, bi);\n             bits = bi.bits;\n        }\n\n        // Optional optimization: find best Huffman division\n        if (gfc.use_best_huffman === 2) {\n            gi.part2_3_length = bits; // Store current total\n            this.best_huffman_divide(gfc, gi); // Try to improve division\n            bits = gi.part2_3_length; // Get potentially updated total\n        }\n\n        // Update cache info if needed\n        if (prev_noise != null) {\n            if (gi.block_type === Encoder.NORM_TYPE) {\n                let sfb = 0;\n                // Find sfb containing the start of big_values\n                while (sfb < Encoder.SBMAX_l && gfc.scalefac_band.l[sfb + 1] < gi.big_values) {\n                    sfb++;\n                }\n                prev_noise.sfb_count1 = sfb; // Store sfb index where count1 ends\n            }\n            // else: Short block cache handling might be different\n        }\n\n        return bits; // Return total Huffman bits\n    }\n\n    /**\n     * Performs quantization and counts bits. This is the main function called\n     * by the iteration loop to evaluate a given set of quantization parameters.\n     *\n     * @public\n     * @param {LameInternalFlags} gfc - LAME internal flags.\n     * @param {Float32Array} xr - `xrpow` array (input).\n     * @param {GrInfo} gi - Granule information (input/output). `l3_enc` is modified.\n     * @param {CalcNoiseData | null} prev_noise - Cached noise data.\n     * @returns {number} Total bits required for Huffman coding, or `LARGE_BITS` if quantization fails (value too large).\n     */\n    count_bits(gfc, xr, gi, prev_noise) {\n        // Check if max xrpow exceeds limit for current gain\n        const istep = this.qupvt.IPOW20(gi.global_gain); // Inverse step size\n        const max_allowed_xrpow = QuantizePVT.IXMAX_VAL / istep;\n        if (gi.xrpow_max > max_allowed_xrpow) {\n            return LARGE_BITS; // Value too large to quantize with this gain\n        }\n\n        // Perform quantization\n        this._quantize_xrpow(xr, gi.l3_enc, istep, gi, prev_noise);\n\n        // Apply substep shaping if enabled\n        if ((gfc.substep_shaping & 2) !== 0) {\n            let j = 0;\n            const gain_factor = this.qupvt.IPOW20(gi.global_gain + gi.scalefac_scale); // Base step for gain comparison\n            const roundfac = 0.634521682242439 / gain_factor; // Threshold relative to gain\n            for (let sfb = 0; sfb < gi.sfbmax; sfb++) {\n                const width = gi.width[sfb];\n                if (gfc.pseudohalf[sfb] === 0) { // No shaping in this band\n                    j += width;\n                } else { // Apply shaping: zero out values below threshold\n                    const band_end = j + width;\n                    for (; j < band_end; ++j) {\n                        // Compare original xr value (not xrpow) against threshold? Check C.\n                        // C code uses xrpow (xr^3/4). Needs xr, not xrpow here.\n                        // This feature might need the original xr[] array passed in.\n                        // For now, assume it uses xrpow (incorrectly based on C context).\n                        // if (xr[j] < roundfac) gi.l3_enc[j] = 0;\n                        // --- Placeholder logic - Needs original xr[] ---\n                        // Cannot implement correctly without original xr\n                    }\n                }\n            }\n        }\n\n        // Count bits for the quantized values\n        return this.noquant_count_bits(gfc, gi, prev_noise);\n    }\n\n    /**\n     * Optimizes the Huffman table region boundaries (`region0_count`, `region1_count`)\n     * for the `big_values` section to minimize bit usage. Modifies `gi` in place\n     * if a better division is found.\n     *\n     * @public\n     * @param {LameInternalFlags} gfc - LAME internal flags.\n     * @param {GrInfo} gi - Granule information (input/output).\n     */\n    best_huffman_divide(gfc, gi) {\n        // Allocate temporary structures only if needed\n        if (gi.block_type !== Encoder.NORM_TYPE && gi.block_type !== Encoder.START_TYPE && gi.block_type !== Encoder.STOP_TYPE) {\n            // Currently only implemented for long/mixed blocks with standard regions\n             if (gi.block_type === Encoder.SHORT_TYPE && gfc.mode_gr === 1) return; // Skip MPEG2 LSF short blocks\n             // Fall through for other block types? Or return? Let's return for now.\n             return;\n        }\n\n        const cod_info2 = new GrInfo();\n        const ix = gi.l3_enc;\n        const r01_bits = new_int(7 + 15 + 1); // Max r0+r1 index\n        const r01_div = new_int(7 + 15 + 1);\n        const r0_tbl = new_int(7 + 15 + 1);\n        const r1_tbl = new_int(7 + 15 + 1);\n\n        cod_info2.assign(gi); // Start with current division\n\n        if (gi.block_type === Encoder.NORM_TYPE) {\n            // Calculate costs for all possible R0/R1 combinations\n            this._recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n            // Find the best combination including R2\n            this._recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n        }\n        // else: Mixed blocks (START/STOP) - C code doesn't call recalc_divide_init/sub?\n        // It seems to fall through to the count1 adjustment logic below.\n\n        // Check if adjusting count1 boundary helps\n        let i = cod_info2.big_values; // Use the big_values from the *potentially* updated cod_info2\n        if (i === 0 || i >= gi.count1) return; // No adjustment possible if no bigvals or already overlaps count1\n\n        // Check if the last *pair* of bigvalues are both <= 1\n        if ((ix[i - 1] | ix[i - 2]) > 1) return;\n\n        // Try extending count1 region by 2 samples\n        i = gi.count1 + 2; // New potential count1 boundary\n        if (i > 576) return; // Cannot extend beyond buffer\n\n        cod_info2.assign(gi); // Re-copy best state found so far\n        cod_info2.count1 = i; // Tentatively set new count1\n        let a1 = 0; let a2 = 0;\n        let quad_idx = i;\n\n        // Recalculate count1 bits for the *new*, potentially smaller quadruple region\n        for (; quad_idx > cod_info2.big_values; quad_idx -= 4) { // Loop from new count1 down to new big_values\n             const p_idx_c = ((ix[quad_idx - 4] << 3) | (ix[quad_idx - 3] << 2) | (ix[quad_idx - 2] << 1) | ix[quad_idx - 1]);\n             if(p_idx_c >= 0 && p_idx_c < Tables.t32l.length && p_idx_c < Tables.t33l.length){ a1 += Tables.t32l[p_idx_c]; a2 += Tables.t33l[p_idx_c]; }\n             else { console.error(\"Invalid index for count1 tables in best_huffman_divide:\", p_idx_c); return; } // Error out\n        }\n        cod_info2.big_values = quad_idx; // Update big_values to new boundary\n\n        // Choose best count1 table\n        cod_info2.count1table_select = (a1 > a2) ? 1 : 0;\n        cod_info2.count1bits = Math.min(a1, a2);\n\n        // Recalculate bits for the (now potentially larger) big_values regions (0, 1, 2)\n        cod_info2.part2_3_length = cod_info2.count1bits; // Start with new count1 bits\n        let region0_end = 0, region1_end = 0;\n        if (cod_info2.block_type === Encoder.NORM_TYPE) {\n             // Use the *original* region counts determined previously\n             region0_end = gfc.scalefac_band.l[gi.region0_count + 1];\n             region1_end = gfc.scalefac_band.l[gi.region0_count + gi.region1_count + 2];\n        } else { // Mixed block (use fixed regions)\n             region0_end = gfc.scalefac_band.l[7 + 1];\n             region1_end = cod_info2.big_values;\n        }\n        region0_end = Math.min(region0_end, cod_info2.big_values);\n        region1_end = Math.min(region1_end, cod_info2.big_values);\n\n        if (region0_end > 0) {\n            let bi = new Bits(cod_info2.part2_3_length);\n            cod_info2.table_select[0] = this._choose_table(ix, 0, region0_end, bi);\n            cod_info2.part2_3_length = bi.bits;\n        }\n        if (region1_end > region0_end) {\n            let bi = new Bits(cod_info2.part2_3_length);\n            cod_info2.table_select[1] = this._choose_table(ix, region0_end, region1_end, bi);\n            cod_info2.part2_3_length = bi.bits;\n        }\n        if (cod_info2.big_values > region1_end) { // Region 2\n            let bi = new Bits(cod_info2.part2_3_length);\n            cod_info2.table_select[2] = this._choose_table(ix, region1_end, cod_info2.big_values, bi);\n            cod_info2.part2_3_length = bi.bits;\n        }\n\n        // If this adjusted count1 boundary resulted in fewer bits, update the main gi\n        if (gi.part2_3_length > cod_info2.part2_3_length) {\n            gi.assign(cod_info2);\n        }\n    }\n\n    /**\n     * Calculates the number of bits used to encode scalefactors for MPEG1.\n     * Determines the optimal `scalefac_compress` value.\n     * Also applies `pretab` if possible and updates `cod_info.preflag`.\n     * Returns true if any scalefactor exceeds the limits for all `scalefac_compress` values.\n     *\n     * @public\n     * @param {GrInfo} cod_info - Granule information (input/output).\n     * @returns {boolean} True if scalefactors are too large, false otherwise.\n     */\n    scale_bitcount(cod_info) {\n        let k, sfb;\n        let max_slen1 = 0, max_slen2 = 0;\n        let tab;\n        const scalefac = cod_info.scalefac; // Use local ref\n\n        assert(this._all_scalefactors_not_negative(scalefac, cod_info.sfbmax), \"Negative scalefactor found before scale_bitcount\");\n\n        // Select appropriate bit count table based on block type\n        if (cod_info.block_type === Encoder.SHORT_TYPE) {\n            tab = (cod_info.mixed_block_flag !== 0) ? scale_mixed : scale_short;\n        } else { // Long/Start/Stop\n            tab = scale_long;\n            // Check if preemphasis can be applied (implicitly, by reducing scalefactors)\n            if (cod_info.preflag === 0) {\n                for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) {\n                    if (scalefac[sfb] < this.qupvt.pretab[sfb]) break; // Cannot apply if any sf < pretab\n                }\n                if (sfb === Encoder.SBPSY_l) { // All sfb >= pretab[sfb]\n                    cod_info.preflag = 1; // Enable preflag\n                    for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) {\n                         scalefac[sfb] -= this.qupvt.pretab[sfb]; // Adjust scalefactors\n                    }\n                }\n            }\n        }\n\n        // Find max scalefactor values in the two slen regions\n        for (sfb = 0; sfb < cod_info.sfbdivide; sfb++) {\n            if (max_slen1 < scalefac[sfb]) max_slen1 = scalefac[sfb];\n        }\n        for (; sfb < cod_info.sfbmax; sfb++) {\n            if (max_slen2 < scalefac[sfb]) max_slen2 = scalefac[sfb];\n        }\n\n        // Find best scalefac_compress value (minimum bits)\n        cod_info.part2_length = LARGE_BITS; // Initialize with large value\n        let found_valid = false;\n        for (k = 0; k < 16; k++) {\n            // Check if current max values fit within limits for this 'k'\n            if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k]) {\n                 found_valid = true; // At least one valid compression found\n                 if (cod_info.part2_length > tab[k]) { // If this 'k' gives fewer bits\n                    cod_info.part2_length = tab[k]; // Store new minimum bit count\n                    cod_info.scalefac_compress = k; // Store corresponding index\n                 }\n            }\n        }\n\n        // Return true if no valid scalefac_compress was found (scalefactors too large)\n        return !found_valid; // (found_valid=false means part2_length is still LARGE_BITS)\n        // Original C returned cod_info.part2_length == LARGE_BITS; equivalent.\n    }\n\n\n    /**\n     * Calculates the number of bits used to encode scalefactors for MPEG2 LSF.\n     * Determines the optimal `scalefac_compress` value based on partitioning.\n     * Returns true if any scalefactor exceeds the limits for the chosen partition table.\n     *\n     * @public\n     * @param {LameInternalFlags} gfc - LAME internal flags (for partition tables).\n     * @param {GrInfo} cod_info - Granule information (input/output).\n     * @returns {boolean} True if scalefactors are too large, false otherwise.\n     */\n    scale_bitcount_lsf(gfc, cod_info) {\n        let table_number, row_in_table, partition, nr_sfb, window;\n        let over = false; // Flag if any scalefactor exceeds limit\n        let i, sfb;\n        const max_sfac = new_int(4); // Max scalefac value per partition\n        const scalefac = cod_info.scalefac; // Use local ref\n\n        // --- Select Partition Table ---\n        // C code: tries table 1 if possible, otherwise uses 0 or 2 based on preflag.\n        // Simplified: use 0 or 2 based on preflag. Needs review if table 1 logic is crucial.\n        table_number = (cod_info.preflag !== 0) ? 2 : 0;\n\n        // Determine max scalefactor in each partition based on block type\n        Arrays.fill(max_sfac, 0); // Initialize max values\n        if (cod_info.block_type === Encoder.SHORT_TYPE) {\n            row_in_table = 1; // Short block partition row\n            const partition_table = this.qupvt.nr_of_sfb_block[table_number][row_in_table];\n            sfb = 0; // Short block scalefactor index\n            for (partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition] / 3; // Number of sfbs in this partition\n                for (i = 0; i < nr_sfb; i++, sfb++) {\n                    for (window = 0; window < 3; window++) {\n                        // Index into flat scalefac array for short blocks: sfb*3 + window\n                        const current_sf = scalefac[sfb * 3 + window];\n                        if (current_sf > max_sfac[partition]) max_sfac[partition] = current_sf;\n                    }\n                }\n            }\n        } else { // Long blocks\n            row_in_table = 0; // Long block partition row\n            const partition_table = this.qupvt.nr_of_sfb_block[table_number][row_in_table];\n            sfb = 0; // Long block scalefactor index\n            for (partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition]; // Number of sfbs in this partition\n                for (i = 0; i < nr_sfb; i++, sfb++) {\n                     if (scalefac[sfb] > max_sfac[partition]) max_sfac[partition] = scalefac[sfb];\n                }\n            }\n        }\n\n        // Check if max values exceed limits for the chosen table\n        for (partition = 0; partition < 4; partition++) {\n            if (max_sfac[partition] > max_range_sfac_tab[table_number][partition]) {\n                over = true; // Scalefactor too large\n                break;\n            }\n        }\n\n        // If no limits exceeded, calculate bits and set compress info\n        if (!over) {\n            cod_info.sfb_partition_table = this.qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (partition = 0; partition < 4; partition++) {\n                // slen is the number of bits needed for the max value in the partition\n                 cod_info.slen[partition] = log2tab[max_sfac[partition]];\n            }\n\n            // Calculate scalefac_compress based on slen values and table number\n            const slen1 = cod_info.slen[0]; const slen2 = cod_info.slen[1];\n            const slen3 = cod_info.slen[2]; const slen4 = cod_info.slen[3];\n            switch (table_number) {\n                case 0: cod_info.scalefac_compress = (((slen1 * 5) + slen2) << 4) + (slen3 << 2) + slen4; break;\n                case 1: cod_info.scalefac_compress = 400 + (((slen1 * 5) + slen2) << 2) + slen3; break;\n                case 2: cod_info.scalefac_compress = 500 + (slen1 * 3) + slen2; break;\n                default: console.error(\"LSF intensity stereo not implemented\"); break; // case 3, 4, 5\n            }\n\n            // Calculate total bits for scalefactors\n            cod_info.part2_length = 0;\n            assert(cod_info.sfb_partition_table != null, \"Partition table is null in scale_bitcount_lsf\");\n            for (partition = 0; partition < 4; partition++) {\n                 cod_info.part2_length += cod_info.slen[partition] * cod_info.sfb_partition_table[partition];\n            }\n        }\n         // else: 'over' is true, part2_length remains unset or potentially invalid\n\n        return over; // Return true if scalefactors were too large\n    }\n\n    /**\n     * Initializes Huffman table boundaries based on scalefactor bands.\n     * Precomputes `gfc.bv_scf` array.\n     *\n     * @public\n     * @param {LameInternalFlags} gfc - LAME internal flags.\n     */\n    huffman_init(gfc) {\n        // Precompute bv_scf table used in noquant_count_bits for NORM_TYPE blocks\n        for (let i = 2; i <= 576; i += 2) { // Iterate over pairs of coefficients\n             let scfb_anz = 0; // Scalefactor band index containing coeff i-1\n             // Find the scalefactor band for the current coefficient index i-1\n             // Note: Uses gfc.scalefac_band.l which should be initialized before this.\n             while (scfb_anz < Encoder.SBMAX_l && gfc.scalefac_band.l[scfb_anz + 1] < i) {\n                 scfb_anz++;\n             }\n             // Handle potential out-of-bounds if i is very high? Should not happen if i <= 576.\n             if(scfb_anz >= Encoder.SBMAX_l) scfb_anz = Encoder.SBMAX_l -1; // Clamp?\n\n             // Determine region0 boundary (bv_index) using subdv_table lookup\n             let bv_index = subdv_table[scfb_anz][0]; // Default region0 size for this sfb\n             // Adjust bv_index downwards if its end boundary exceeds the current coefficient index\n             while (bv_index > 0 && gfc.scalefac_band.l[bv_index + 1] >= i) {\n                 bv_index--;\n             }\n              // C code check: if (bv_index < 0) bv_index = subdv_table[scfb_anz][0]; - Seems redundant if adjusted down? Let's keep C logic.\n              if (bv_index < 0) bv_index = subdv_table[scfb_anz][0]; // Reset if adjustment went too far?\n\n             gfc.bv_scf[i - 2] = bv_index; // Store region0 size for coeff i-2\n\n             // Determine region1 boundary using subdv_table lookup\n             bv_index = subdv_table[scfb_anz][1]; // Default region1 size\n             // Adjust downwards based on region0 size and current coeff index\n             while (bv_index > 0 && gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] >= i) {\n                 bv_index--;\n             }\n              if (bv_index < 0) bv_index = subdv_table[scfb_anz][1]; // Reset?\n\n             gfc.bv_scf[i - 1] = bv_index; // Store region1 size for coeff i-1\n        }\n    }\n\n} // End class Takehiro\n\n// --- Module-level constants/tables used internally by Takehiro methods ---\n\n/** log2(0..15), integer */\nconst log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];\n\n/** Max values for slen1 region based on scalefac_compress index */\nconst slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n/** Max values for slen2 region based on scalefac_compress index */\nconst slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n\n/** Bit length for slen1 region */\n// const slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4]; // Now exported\n/** Bit length for slen2 region */\n// const slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3]; // Now exported\n\n/** Max scalefactor values allowed per partition for MPEG2 LSF tables */\nconst max_range_sfac_tab = [\n    [15, 15, 7, 7],  // Table 0\n    [15, 15, 7, 0],  // Table 1\n    [7, 3, 0, 0],   // Table 2 (pretab)\n    [15, 31, 31, 0], // Table 3 (intensity)\n    [7, 7, 7, 0],   // Table 4 (intensity)\n    [3, 3, 0, 0]    // Table 5 (intensity)\n];\n\n\nexport { Takehiro };","import {\n    // System, // Not used in this snippet\n    // VbrMode, // Not used in this snippet\n    // Float, // Not used in this snippet\n    // ShortBlock, // Not used in this snippet\n    Util,\n    // Arrays, // Not used in this snippet\n    // new_array_n, // Not used in this snippet\n    // new_byte, // Not used in this snippet\n    // new_double, // Not used in this snippet\n    new_float,\n    // new_float_n, // Not used in this snippet\n    // new_int, // Not used in this snippet\n    // new_int_n, // Not used in this snippet\n    // assert // Not used in this snippet\n} from './common.js';\n\n// Import Encoder as a namespace since its properties (constants) are used\nimport * as Encoder from './Encoder.js';\n\n// --- Module Constants and Static Helpers ---\n\nconst costab = [\n    9.238795325112867e-01, 3.826834323650898e-01,\n    9.951847266721969e-01, 9.801714032956060e-02,\n    9.996988186962042e-01, 2.454122852291229e-02,\n    9.999811752826011e-01, 6.135884649154475e-03\n];\n\nconst rv_tbl = [0x00, 0x80, 0x40,\n    0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10,\n    0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70,\n    0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28,\n    0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58,\n    0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,\n    0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64,\n    0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34,\n    0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c,\n    0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c,\n    0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c,\n    0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22,\n    0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52,\n    0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a,\n    0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a,\n    0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a,\n    0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46,\n    0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16,\n    0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76,\n    0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e,\n    0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e,\n    0xde, 0x3e, 0xbe, 0x7e, 0xfe];\n\n/**\n * Fast Hartley Transform Helper\n * (Moved to module scope as it doesn't depend on instance state)\n * @param {Float32Array} fz Data array\n * @param {number} fzPos Start position in fz\n * @param {number} n Transform size (e.g., BLKSIZE/2 or BLKSIZE_s/2)\n */\nfunction fht(fz, fzPos, n) {\n    var tri = 0;\n    var k4;\n    var fi;\n    var gi;\n\n    n <<= 1; // Adjust n similarly to original code logic\n    var fn = fzPos + n;\n    k4 = 4;\n    do {\n        var s1, c1;\n        var i, k1, k2, k3, kx;\n        kx = k4 >> 1;\n        k1 = k4;\n        k2 = k4 << 1;\n        k3 = k2 + k1;\n        k4 = k2 << 1;\n        fi = fzPos;\n        gi = fi + kx;\n        do {\n            var f0, f1, f2, f3;\n            f1 = fz[fi + 0] - fz[fi + k1];\n            f0 = fz[fi + 0] + fz[fi + k1];\n            f3 = fz[fi + k2] - fz[fi + k3];\n            f2 = fz[fi + k2] + fz[fi + k3];\n            fz[fi + k2] = f0 - f2;\n            fz[fi + 0] = f0 + f2;\n            fz[fi + k3] = f1 - f3;\n            fz[fi + k1] = f1 + f3;\n            f1 = fz[gi + 0] - fz[gi + k1];\n            f0 = fz[gi + 0] + fz[gi + k1];\n            f3 = (Util.SQRT2 * fz[gi + k3]);\n            f2 = (Util.SQRT2 * fz[gi + k2]);\n            fz[gi + k2] = f0 - f2;\n            fz[gi + 0] = f0 + f2;\n            fz[gi + k3] = f1 - f3;\n            fz[gi + k1] = f1 + f3;\n            gi += k4;\n            fi += k4;\n        } while (fi < fn);\n        c1 = costab[tri + 0];\n        s1 = costab[tri + 1];\n        for (i = 1; i < kx; i++) {\n            var c2, s2;\n            c2 = 1 - (2 * s1) * s1;\n            s2 = (2 * s1) * c1;\n            fi = fzPos + i;\n            gi = fzPos + k1 - i;\n            do {\n                var a, b, g0, f0, f1, g1, f2, g2, f3, g3;\n                b = s2 * fz[fi + k1] - c2 * fz[gi + k1];\n                a = c2 * fz[fi + k1] + s2 * fz[gi + k1];\n                f1 = fz[fi + 0] - a;\n                f0 = fz[fi + 0] + a;\n                g1 = fz[gi + 0] - b;\n                g0 = fz[gi + 0] + b;\n                b = s2 * fz[fi + k3] - c2 * fz[gi + k3];\n                a = c2 * fz[fi + k3] + s2 * fz[gi + k3];\n                f3 = fz[fi + k2] - a;\n                f2 = fz[fi + k2] + a;\n                g3 = fz[gi + k2] - b;\n                g2 = fz[gi + k2] + b;\n                b = s1 * f2 - c1 * g3;\n                a = c1 * f2 + s1 * g3;\n                fz[fi + k2] = f0 - a;\n                fz[fi + 0] = f0 + a;\n                fz[gi + k3] = g1 - b;\n                fz[gi + k1] = g1 + b;\n                b = c1 * g2 - s1 * f3;\n                a = s1 * g2 + c1 * f3;\n                fz[gi + k2] = g0 - a;\n                fz[gi + 0] = g0 + a;\n                fz[fi + k3] = f1 - b;\n                fz[fi + k1] = f1 + b;\n                gi += k4;\n                fi += k4;\n            } while (fi < fn);\n            c2 = c1;\n            c1 = c2 * costab[tri + 0] - s1 * costab[tri + 1];\n            s1 = c2 * costab[tri + 1] + s1 * costab[tri + 0];\n        }\n        tri += 2;\n    } while (k4 < n);\n}\n\n\n// --- FFT Class ---\n\nclass FFT {\n    constructor() {\n        // Instance variables for window functions\n        this.window = new_float(Encoder.BLKSIZE);\n        this.window_s = new_float(Encoder.BLKSIZE_s / 2);\n    }\n\n    init_fft(gfc) {\n        /* The type of window used here will make no real difference, but */\n        /* in the interest of merging nspsytune stuff - switch to blackman window */\n        for (let i = 0; i < Encoder.BLKSIZE; i++) {\n            /* blackman window */\n            this.window[i] = (0.42 - 0.5 * Math.cos(2 * Math.PI * (i + .5)\n                / Encoder.BLKSIZE) + 0.08 * Math.cos(4 * Math.PI * (i + .5)\n                / Encoder.BLKSIZE));\n        }\n\n        for (let i = 0; i < Encoder.BLKSIZE_s / 2; i++) {\n            this.window_s[i] = (0.5 * (1.0 - Math.cos(2.0 * Math.PI\n                * (i + 0.5) / Encoder.BLKSIZE_s)));\n        }\n    }\n\n    fft_short(gfc, x_real, chn, buffer, bufPos) {\n        for (let b = 0; b < 3; b++) {\n            let x = Encoder.BLKSIZE_s / 2;\n            // Use bitwise AND for ensuring k stays within valid range if needed,\n            // although simple addition/multiplication should be fine if bufPos/k calculation is correct.\n            // Using `& 0xffff` was in the original, kept for equivalence, but might not be strictly necessary in JS number handling unless specific overflow behavior is desired.\n            let k = 0xffff & ((576 / 3) * (b + 1)); // Original calculation\n            let j = Encoder.BLKSIZE_s / 8 - 1;\n            do {\n                let f0, f1, f2, f3, w;\n                // Ensure rv_tbl index is non-negative and within bounds.\n                // Using bitwise ops as in original.\n                let tbl_idx = j << 2;\n                if (tbl_idx < 0 || tbl_idx >= rv_tbl.length) {\n                     console.error(\"rv_tbl index out of bounds:\", tbl_idx);\n                     // Handle error appropriately, e.g., break or throw\n                     break;\n                }\n                let i = rv_tbl[tbl_idx] & 0xff;\n\n                // Accessing instance window properties with 'this.'\n                f0 = this.window_s[i] * buffer[chn][bufPos + i + k];\n                w = this.window_s[0x7f - i] * buffer[chn][bufPos + i + k + 0x80];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = this.window_s[i + 0x40] * buffer[chn][bufPos + i + k + 0x40];\n                w = this.window_s[0x3f - i] * buffer[chn][bufPos + i + k + 0xc0];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x -= 4;\n                x_real[b][x + 0] = f0 + f2;\n                x_real[b][x + 2] = f0 - f2;\n                x_real[b][x + 1] = f1 + f3;\n                x_real[b][x + 3] = f1 - f3;\n\n                f0 = this.window_s[i + 0x01] * buffer[chn][bufPos + i + k + 0x01];\n                w = this.window_s[0x7e - i] * buffer[chn][bufPos + i + k + 0x81];\n                f1 = f0 - w;\n                f0 = f0 + w;\n                f2 = this.window_s[i + 0x41] * buffer[chn][bufPos + i + k + 0x41];\n                w = this.window_s[0x3e - i] * buffer[chn][bufPos + i + k + 0xc1];\n                f3 = f2 - w;\n                f2 = f2 + w;\n\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 0] = f0 + f2;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 2] = f0 - f2;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 1] = f1 + f3;\n                x_real[b][x + Encoder.BLKSIZE_s / 2 + 3] = f1 - f3;\n            } while (--j >= 0);\n\n            // Call the module-scoped helper function\n            fht(x_real[b], 0, Encoder.BLKSIZE_s / 2); // Assuming x_real[b] starts at index 0\n            // Original code passed `x` (which was 0 after the loop) as fzPos.\n            // Passing 0 directly, assuming the array slice `x_real[b]` is the target.\n        }\n    }\n\n\n    fft_long(gfc, y, chn, buffer, bufPos) {\n        let jj = Encoder.BLKSIZE / 8 - 1;\n        let x = Encoder.BLKSIZE / 2;\n\n        do {\n            let f0, f1, f2, f3, w;\n             // Ensure rv_tbl index is non-negative and within bounds.\n            if (jj < 0 || jj >= rv_tbl.length) {\n                console.error(\"rv_tbl index out of bounds:\", jj);\n                // Handle error appropriately\n                break;\n            }\n            let i = rv_tbl[jj] & 0xff;\n\n            // Accessing instance window properties with 'this.'\n            f0 = this.window[i] * buffer[chn][bufPos + i];\n            w = this.window[i + 0x200] * buffer[chn][bufPos + i + 0x200];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = this.window[i + 0x100] * buffer[chn][bufPos + i + 0x100];\n            w = this.window[i + 0x300] * buffer[chn][bufPos + i + 0x300];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            x -= 4;\n            y[x + 0] = f0 + f2;\n            y[x + 2] = f0 - f2;\n            y[x + 1] = f1 + f3;\n            y[x + 3] = f1 - f3;\n\n            f0 = this.window[i + 0x001] * buffer[chn][bufPos + i + 0x001];\n            w = this.window[i + 0x201] * buffer[chn][bufPos + i + 0x201];\n            f1 = f0 - w;\n            f0 = f0 + w;\n            f2 = this.window[i + 0x101] * buffer[chn][bufPos + i + 0x101];\n            w = this.window[i + 0x301] * buffer[chn][bufPos + i + 0x301];\n            f3 = f2 - w;\n            f2 = f2 + w;\n\n            y[x + Encoder.BLKSIZE / 2 + 0] = f0 + f2;\n            y[x + Encoder.BLKSIZE / 2 + 2] = f0 - f2;\n            y[x + Encoder.BLKSIZE / 2 + 1] = f1 + f3;\n            y[x + Encoder.BLKSIZE / 2 + 3] = f1 - f3;\n        } while (--jj >= 0);\n\n        // Call the module-scoped helper function\n        fht(y, 0, Encoder.BLKSIZE / 2); // Assuming y starts at index 0\n        // Original code passed `x` (which was 0 after the loop) as fzPos.\n    }\n}\n\n// Export the FFT class using a named export (same as original)\nexport { FFT };","/**\n * @fileoverview Psychoacoustic model implementation for LAME MP3 encoder.\n * Ported from psymodel.c. Computes masking thresholds based on FFT analysis.\n * Uses ES Module syntax.\n *\n * Original C Source Header:\n *      psymodel.c\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 2001-2002 Naoki Shibata\n *      Copyright (c) 2000-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2008 Robert Hegemann\n *      Copyright (c) 2000-2005 Gabriel Bouvigne\n *      Copyright (c) 2000-2005 Alexander Leidinger\n *      ... (License details omitted for brevity) ...\n *\n * $Id: PsyModel.java,v 1.27 2011/05/24 20:48:06 kenchis Exp $\n *\n * @module PsyModel\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { FFT } from \"./FFT.js\";\nimport { Encoder } from \"./Encoder.js\";\nimport { MPEGMode } from './MPEGMode.js';\n\n// Type Imports for JSDoc\n/** @typedef {import('./LameGlobalFlags.js').default} LameGlobalFlags */\n/** @typedef {import('./LameInternalFlags.js').default} LameInternalFlags */\n/** @typedef {import('./III_psy_ratio.js').III_psy_ratio} III_psy_ratio */\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used directly here\n    VbrMode,\n    Float,\n    ShortBlock,\n    Util,\n    Arrays,\n    // new_array_n, // Used indirectly via new_float_n etc.\n    // new_byte, // Not used directly\n    // new_double, // Not used directly\n    new_float,\n    new_float_n,\n    new_int,\n    new_int_n,\n    assert\n} = common;\n\n// --- Psychoacoustic Constants ---\n\n/** Natural logarithm of 10. @const */\nconst LOG10 = 2.30258509299404568402;\n/** Log base 10 of e. @const */\nconst LN_TO_LOG10 = 0.2302585093;\n\n/** Pre-echo control RPELEV value for long blocks. @const */\nconst rpelev = 2;\n/** Pre-echo control RPELEV2 value for long blocks. @const */\nconst rpelev2 = 16;\n/** Pre-echo control RPELEV value for short blocks. @const */\nconst rpelev_s = 2;\n/** Pre-echo control RPELEV2 value for short blocks. @const */\nconst rpelev2_s = 16;\n\n/** Size of each partition band, in barks. @const */\nconst DELBARK = .34;\n\n/** Scale factor for loudness approximation, tuned for output level. @const */\nconst VO_SCALE = (1. / (14752 * 14752) / (Encoder.BLKSIZE / 2));\n\n/** Temporal masking sustain time in seconds. @const */\nconst temporalmask_sustain_sec = 0.01;\n\n/** Pre-echo attenuation factor 0 (NSPSY). @const */\nconst NS_PREECHO_ATT0 = 0.8;\n/** Pre-echo attenuation factor 1 (NSPSY). @const */\nconst NS_PREECHO_ATT1 = 0.6;\n/** Pre-echo attenuation factor 2 (NSPSY). @const */\nconst NS_PREECHO_ATT2 = 0.3;\n\n/** Mid/Side fixing factor (NSPSY). @const */\nconst NS_MSFIX = 3.5;\n\n/** Attack detection threshold for long blocks (NSPSY). @const */\nconst NSATTACKTHRE = 4.4;\n/** Attack detection threshold for short blocks (NSPSY). @const */\nconst NSATTACKTHRE_S = 25;\n\n/** FIR filter length for attack detection (NSPSY). @const */\nconst NSFIRLEN = 21;\n\n/**\n * Placeholder for non-linear energy scaling. Currently identity.\n * @param {number} x - Input energy value.\n * @returns {number} Scaled energy value.\n */\nfunction NON_LINEAR_SCALE_ENERGY(x) {\n    return x;\n}\n\n// --- Masking Addition Optimization Constants ---\n/** Optimization limit for mask_add (i > 8). @const */\nconst I1LIMIT = 8;\n/** Optimization limit for mask_add (i > 24, originally 23). @const */\nconst I2LIMIT = 23;\n/** Optimization limit for mask_add (m < 15). @const */\nconst MLIMIT = 15;\n\n/** Precalculated limit for mask_add optimization (10^((I1LIMIT+1)/16)). */\nlet ma_max_i1;\n/** Precalculated limit for mask_add optimization (10^((I2LIMIT+1)/16)). */\nlet ma_max_i2;\n/** Precalculated limit for mask_add optimization (10^(MLIMIT/10)). */\nlet ma_max_m;\n\n/**\n * Initializes precalculated maximum values for mask_add optimization.\n */\nfunction init_mask_add_max_values() {\n    ma_max_i1 = Math.pow(10, (I1LIMIT + 1) / 16.0);\n    ma_max_i2 = Math.pow(10, (I2LIMIT + 1) / 16.0);\n    ma_max_m = Math.pow(10, (MLIMIT) / 10.0);\n}\n\n// --- Masking Tables ---\n\n/**\n * Masking table based on tonality. Represents pow(10, -0.0..-0.6).\n * @const {number[]}\n */\nconst tab = [1.0, 0.79433, 0.63096, 0.63096,\n    0.63096, 0.63096, 0.63096, 0.25119, 0.11749];\n\n/** Precomputed table 1 for mask_add function (squared values). @const {number[]} */\nconst table1 = [3.3246 * 3.3246, 3.23837 * 3.23837, 3.15437 * 3.15437, 3.00412 * 3.00412, 2.86103 * 2.86103, 2.65407 * 2.65407, 2.46209 * 2.46209, 2.284 * 2.284, 2.11879 * 2.11879, 1.96552 * 1.96552, 1.82335 * 1.82335, 1.69146 * 1.69146, 1.56911 * 1.56911, 1.46658 * 1.46658, 1.37074 * 1.37074, 1.31036 * 1.31036, 1.25264 * 1.25264, 1.20648 * 1.20648, 1.16203 * 1.16203, 1.12765 * 1.12765, 1.09428 * 1.09428, 1.0659 * 1.0659, 1.03826 * 1.03826, 1.01895 * 1.01895, 1];\n/** Precomputed table 2 for mask_add function (squared values). @const {number[]} */\nconst table2 = [1.33352 * 1.33352, 1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497, 1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382, 1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n/** Precomputed table 3 for mask_add function (squared values). @const {number[]} */\nconst table3 = [2.35364 * 2.35364, 2.29259 * 2.29259, 2.23313 * 2.23313, 2.12675 * 2.12675, 2.02545 * 2.02545, 1.87894 * 1.87894, 1.74303 * 1.74303, 1.61695 * 1.61695, 1.49999 * 1.49999, 1.39148 * 1.39148, 1.29083 * 1.29083, 1.19746 * 1.19746, 1.11084 * 1.11084, 1.03826 * 1.03826];\n/** Precomputed table 2 (copy) for vbrpsy_mask_add function (squared values). @const {number[]} */\nconst table2_ = [1.33352 * 1.33352, 1.35879 * 1.35879, 1.38454 * 1.38454, 1.39497 * 1.39497, 1.40548 * 1.40548, 1.3537 * 1.3537, 1.30382 * 1.30382, 1.22321 * 1.22321, 1.14758 * 1.14758, 1];\n\n// --- FIR Filter Coefficients ---\n/** Coefficients for the FIR high-pass filter used in attack detection (NSPSY). Stored as `coeff * 2`. @const {number[]} */\nconst fircoef = [-8.65163e-18 * 2, -0.00851586 * 2, -6.74764e-18 * 2, 0.0209036 * 2, -3.36639e-17 * 2, -0.0438162 * 2, -1.54175e-17 * 2, 0.0931738 * 2, -5.52212e-17 * 2, -0.313819 * 2];\nconst fircoef_ = fircoef; // Alias used in vbrpsy_attack_detection\n\n// --- Perceptual Entropy Coefficients ---\n/** Coefficients for perceptual entropy calculation (short blocks). Tuned for 44.1kHz. @const {number[]} */\nconst regcoef_s = [11.8, 13.6, 17.2, 32, 46.5, 51.3, 57.5, 67.1, 71.5, 84.6, 97.6, 130, /* 255.8 */];\n/** Coefficients for perceptual entropy calculation (long blocks). Tuned for 44.1kHz. @const {number[]} */\nconst regcoef_l = [6.8, 5.8, 5.8, 6.4, 6.5, 9.9, 12.1, 14.4, 15, 18.9, 21.6, 26.9, 34.2, 40.2, 46.8, 56.5, 60.7, 73.9, 85.7, 93.4, 126.1, /* 241.3 */];\n\n\n/**\n * @classdesc Implements the psychoacoustic model for LAME MP3 encoding.\n *\n * This class encapsulates the algorithms for computing masking thresholds based on\n * the spectral analysis of the input audio signal. It handles both the standard\n * psychoacoustic model and the NSPSYTUNE variant, as well as VBR-specific logic.\n *\n * The model performs the following main steps:\n * 1. FFT analysis (long and short blocks).\n * 2. Calculation of energy and tonality per partition band.\n * 3. Calculation of masker strength.\n * 4. Convolution with spreading functions to determine masking thresholds.\n * 5. Inter-channel and Mid/Side masking adjustments.\n * 6. Block type switching logic based on attack detection.\n * 7. Perceptual Entropy (PE) calculation.\n *\n * Note: Data returned (maskings, PE, block type) is typically delayed by one granule\n * compared to the input buffer being processed.\n *\n * @constructs PsyModel\n */\nclass PsyModel {\n    /**\n     * FFT computation object instance.\n     * @type {FFT}\n     * @private\n     */\n    fft;\n\n    constructor() {\n        /**\n         * @private\n         */\n        this.fft = new FFT();\n\n        // Initialize s3ind as a 2D array\n        this.s3ind = new_int_n([Encoder.CBANDS, 2]);\n        \n        // Initialize s3 as a 2D array\n        this.s3 = new_float_n([Encoder.CBANDS, Encoder.CBANDS]);\n    }\n\n    // --- Private Helper Methods ---\n    // (JSDoc omitted for brevity as requested, focusing on public methods)\n\n    /** @private */\n    _psycho_loudness_approx(energy, gfc) {\n        let loudness_power = 0.0;\n        for (let i = 0; i < Encoder.BLKSIZE / 2; ++i) {\n            loudness_power += energy[i] * gfc.ATH.eql_w[i];\n        }\n        loudness_power *= VO_SCALE;\n        return loudness_power;\n    }\n\n    /** @private */\n    _compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_l, wsamp_lPos, wsamp_s, wsamp_sPos, gr_out, chn, buffer, bufPos) {\n        const gfc = gfp.internal_flags;\n        const current_chn_fft_l = wsamp_l[wsamp_lPos];\n        const current_chn_fft_s = wsamp_s[wsamp_sPos];\n\n        if (chn < 2) {\n            this.fft.fft_long(gfc, current_chn_fft_l, chn, buffer, bufPos);\n            this.fft.fft_short(gfc, current_chn_fft_s, chn, buffer, bufPos);\n        }\n        else if (chn === 2) {\n            const left_fft_l = wsamp_l[0];\n            const right_fft_l = wsamp_l[1];\n            for (let j = Encoder.BLKSIZE - 1; j >= 0; --j) {\n                const l = left_fft_l[j];\n                const r = right_fft_l[j];\n                wsamp_l[0][j] = (l + r) * Util.SQRT2 * 0.5; // Mid\n                wsamp_l[1][j] = (l - r) * Util.SQRT2 * 0.5; // Side\n            }\n            const left_fft_s = wsamp_s[0];\n            const right_fft_s = wsamp_s[1];\n            for (let b = 2; b >= 0; --b) {\n                for (let j = Encoder.BLKSIZE_s - 1; j >= 0; --j) {\n                    const l = left_fft_s[b][j];\n                    const r = right_fft_s[b][j];\n                    wsamp_s[0][b][j] = (l + r) * Util.SQRT2 * 0.5; // Mid\n                    wsamp_s[1][b][j] = (l - r) * Util.SQRT2 * 0.5; // Side\n                }\n            }\n        }\n\n        const target_fft_l = wsamp_l[wsamp_lPos];\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(target_fft_l[0]);\n        fftenergy[0] *= fftenergy[0];\n        for (let j = Encoder.BLKSIZE / 2 - 1; j >= 0; --j) {\n            const re = target_fft_l[Encoder.BLKSIZE / 2 - j];\n            const im = target_fft_l[Encoder.BLKSIZE / 2 + j];\n            fftenergy[Encoder.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);\n        }\n\n        const target_fft_s = wsamp_s[wsamp_sPos];\n        for (let b = 2; b >= 0; --b) {\n            fftenergy_s[b][0] = target_fft_s[b][0];\n            fftenergy_s[b][0] *= fftenergy_s[b][0];\n            for (let j = Encoder.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n                const re = target_fft_s[b][Encoder.BLKSIZE_s / 2 - j];\n                const im = target_fft_s[b][Encoder.BLKSIZE_s / 2 + j];\n                fftenergy_s[b][Encoder.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);\n            }\n        }\n\n        {\n            let totalenergy = 0.0;\n            for (let j = 11; j < Encoder.HBLKSIZE; j++)\n                totalenergy += fftenergy[j];\n            gfc.tot_ener[chn] = totalenergy;\n        }\n\n        if (gfp.analysis) {\n            for (let j = 0; j < Encoder.HBLKSIZE; j++) {\n                gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j];\n                gfc.pinfo.energy_save[chn][j] = fftenergy[j];\n            }\n             gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n\n        if (gfp.athaa_loudapprox === 2 && chn < 2) {\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = this._psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    /** @private */\n    _mask_add(m1, m2, kk, b, gfc, shortblock) {\n        let ratio;\n        if (m2 > m1) {\n            if (m2 < (m1 * ma_max_i2)) ratio = m2 / m1;\n            else return (m1 + m2);\n        } else {\n            if (m1 >= (m2 * ma_max_i2)) return (m1 + m2);\n            ratio = m1 / m2;\n        }\n        assert(m1 >= 0); assert(m2 >= 0);\n        let combined_masking = m1 + m2;\n        if ((b + 3) <= 6) {\n            if (ratio >= ma_max_i1) {\n                return combined_masking;\n            }\n            const i = 0 | (Util.FAST_LOG10_X(ratio, 16.0));\n            return combined_masking * table2[i];\n        }\n        const i = 0 | Util.FAST_LOG10_X(ratio, 16.0);\n        let ath_cb;\n        if (shortblock !== 0) {\n            ath_cb = gfc.ATH.cb_s[kk] * gfc.ATH.adjust;\n        } else {\n            ath_cb = gfc.ATH.cb_l[kk] * gfc.ATH.adjust;\n        }\n        assert(ath_cb >= 0);\n        if (combined_masking < ma_max_m * ath_cb) {\n            if (combined_masking > ath_cb) {\n                let f = 1.0;\n                if (i <= 13) f = table3[i];\n                const r_m_ath = Util.FAST_LOG10_X(combined_masking / ath_cb, 10.0 / 15.0);\n                return combined_masking * ((table1[i] - f) * r_m_ath + f);\n            }\n            if (i > 13) return combined_masking;\n            return combined_masking * table3[i];\n        }\n        return combined_masking * table1[i];\n    }\n\n    /** @private */\n    _vbrpsy_mask_add(m1, m2, b) {\n        let ratio;\n        if (m1 < 0) m1 = 0;\n        if (m2 < 0) m2 = 0;\n        if (m1 <= 0) return m2;\n        if (m2 <= 0) return m1;\n        if (m2 > m1) {\n            ratio = m2 / m1;\n        } else {\n            ratio = m1 / m2;\n        }\n        if (-2 <= b && b <= 2) {\n            if (ratio >= ma_max_i1) {\n                return m1 + m2;\n            } else {\n                const i = 0 | (Util.FAST_LOG10_X(ratio, 16.0));\n                return (m1 + m2) * table2_[i];\n            }\n        }\n        if (ratio < ma_max_i2) {\n            return m1 + m2;\n        }\n        if (m1 < m2) return m2;\n        return m1;\n    }\n\n    /** @private */\n    _calc_interchannel_masking(gfp, ratio) {\n        const gfc = gfp.internal_flags;\n        if (gfc.channels_out > 1) {\n            for (let sb = 0; sb < Encoder.SBMAX_l; sb++) {\n                const l = gfc.thm[0].l[sb];\n                const r = gfc.thm[1].l[sb];\n                gfc.thm[0].l[sb] += r * ratio;\n                gfc.thm[1].l[sb] += l * ratio;\n            }\n            for (let sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                for (let sblock = 0; sblock < 3; sblock++) {\n                    const l = gfc.thm[0].s[sb][sblock];\n                    const r = gfc.thm[1].s[sb][sblock];\n                    gfc.thm[0].s[sb][sblock] += r * ratio;\n                    gfc.thm[1].s[sb][sblock] += l * ratio;\n                }\n            }\n        }\n    }\n\n    /** @private */\n    _msfix1(gfc) {\n        for (let sb = 0; sb < Encoder.SBMAX_l; sb++) {\n            const thmL = gfc.thm[0].l[sb]; const thmR = gfc.thm[1].l[sb];\n            if (thmL > 1.58 * thmR || thmR > 1.58 * thmL) continue;\n            const thmM = gfc.thm[2].l[sb]; const thmS = gfc.thm[3].l[sb];\n            const enM = gfc.en[2].l[sb]; const enS = gfc.en[3].l[sb];\n            const mld_sb = gfc.mld_l[sb];\n            const mld_mid = mld_sb * enS; const rmid = Math.max(thmM, Math.min(thmS, mld_mid));\n            const mld_side = mld_sb * enM; const rside = Math.max(thmS, Math.min(thmM, mld_side));\n            gfc.thm[2].l[sb] = rmid; gfc.thm[3].l[sb] = rside;\n        }\n        for (let sb = 0; sb < Encoder.SBMAX_s; sb++) {\n            for (let sblock = 0; sblock < 3; sblock++) {\n                const thmL = gfc.thm[0].s[sb][sblock]; const thmR = gfc.thm[1].s[sb][sblock];\n                if (thmL > 1.58 * thmR || thmR > 1.58 * thmL) continue;\n                const thmM = gfc.thm[2].s[sb][sblock]; const thmS = gfc.thm[3].s[sb][sblock];\n                const enM = gfc.en[2].s[sb][sblock]; const enS = gfc.en[3].s[sb][sblock];\n                const mld_sb = gfc.mld_s[sb];\n                const mld_mid = mld_sb * enS; const rmid = Math.max(thmM, Math.min(thmS, mld_mid));\n                const mld_side = mld_sb * enM; const rside = Math.max(thmS, Math.min(thmM, mld_side));\n                gfc.thm[2].s[sb][sblock] = rmid; gfc.thm[3].s[sb][sblock] = rside;\n            }\n        }\n    }\n\n    /** @private */\n    _ns_msfix(gfc, msfix, athadjust) {\n        const msfix2 = msfix * 2.0;\n        let athlower = Math.pow(10, athadjust); // Expects linear adjustment factor\n        for (let sb = 0; sb < Encoder.SBMAX_l; sb++) {\n            const ath = gfc.ATH.cb_l[gfc.bm_l[sb]] * athlower;\n            const thmL = Math.max(gfc.thm[0].l[sb], ath);\n            const thmR = Math.max(gfc.thm[1].l[sb], ath);\n            let thmM = Math.max(gfc.thm[2].l[sb], ath);\n            let thmS = Math.max(gfc.thm[3].l[sb], ath);\n            const thmLR_min = Math.min(thmL, thmR);\n            const thmMS_sum = thmM + thmS;\n            if (thmMS_sum > 0 && thmLR_min * msfix2 < thmMS_sum) {\n                const f = thmLR_min * msfix2 / thmMS_sum;\n                thmM *= f; thmS *= f;\n                assert(thmM + thmS >= 0); // Allow zero\n            }\n            gfc.thm[2].l[sb] = Math.min(thmM, gfc.thm[2].l[sb]);\n            gfc.thm[3].l[sb] = Math.min(thmS, gfc.thm[3].l[sb]);\n        }\n        athlower *= (Encoder.BLKSIZE_s / Encoder.BLKSIZE);\n        for (let sb = 0; sb < Encoder.SBMAX_s; sb++) {\n            for (let sblock = 0; sblock < 3; sblock++) {\n                const ath = gfc.ATH.cb_s[gfc.bm_s[sb]] * athlower;\n                const thmL = Math.max(gfc.thm[0].s[sb][sblock], ath);\n                const thmR = Math.max(gfc.thm[1].s[sb][sblock], ath);\n                let thmM = Math.max(gfc.thm[2].s[sb][sblock], ath);\n                let thmS = Math.max(gfc.thm[3].s[sb][sblock], ath);\n                const thmLR_min = Math.min(thmL, thmR);\n                const thmMS_sum = thmM + thmS;\n                // Check C code again: NS uses msfix, VBR uses msfix2 here... Let's follow C for NSPSY\n                 if (thmMS_sum > 0 && thmLR_min * msfix < thmMS_sum) { // Using msfix here\n                    const f = thmLR_min * msfix / thmMS_sum;\n                    thmM *= f; thmS *= f;\n                    assert(thmM + thmS >= 0); // Allow zero\n                }\n                gfc.thm[2].s[sb][sblock] = Math.min(gfc.thm[2].s[sb][sblock], thmM);\n                gfc.thm[3].s[sb][sblock] = Math.min(gfc.thm[3].s[sb][sblock], thmS);\n            }\n        }\n    }\n\n    /** @private */\n    _convert_partition2scalefac_s(gfc, eb, thr, chn, sblock) {\n        let sb, b; let enn = 0.0; let thmm = 0.0; const npart_s = gfc.npart_s;\n        for (sb = b = 0; sb < Encoder.SBMAX_s; ++sb) {\n            const bo_s_sb = gfc.bo_s[sb]; const b_lim = bo_s_sb < npart_s ? bo_s_sb : npart_s;\n            while (b < b_lim) { assert(eb[b] >= 0); assert(thr[b] >= 0); enn += eb[b]; thmm += thr[b]; b++; }\n            gfc.en[chn].s[sb][sblock] = enn; gfc.thm[chn].s[sb][sblock] = thmm;\n            if (b >= npart_s) { ++sb; break; }\n            assert(eb[b] >= 0); assert(thr[b] >= 0);\n            {\n                const w_curr = gfc.PSY.bo_s_weight[sb]; const w_next = 1.0 - w_curr;\n                const enn_curr = w_curr * eb[b]; const thmm_curr = w_curr * thr[b];\n                gfc.en[chn].s[sb][sblock] += enn_curr; gfc.thm[chn].s[sb][sblock] += thmm_curr;\n                enn = w_next * eb[b]; thmm = w_next * thr[b];\n            }\n            b++;\n        }\n        for (; sb < Encoder.SBMAX_s; ++sb) { gfc.en[chn].s[sb][sblock] = 0; gfc.thm[chn].s[sb][sblock] = 0; }\n    }\n\n    /** @private */\n    _convert_partition2scalefac_l(gfc, eb, thr, chn) {\n        let sb, b; let enn = 0.0; let thmm = 0.0; const npart_l = gfc.npart_l;\n        for (sb = b = 0; sb < Encoder.SBMAX_l; ++sb) {\n            const bo_l_sb = gfc.bo_l[sb]; const b_lim = bo_l_sb < npart_l ? bo_l_sb : npart_l;\n            while (b < b_lim) { assert(eb[b] >= 0); assert(thr[b] >= 0); enn += eb[b]; thmm += thr[b]; b++; }\n            gfc.en[chn].l[sb] = enn; gfc.thm[chn].l[sb] = thmm;\n            if (b >= npart_l) { ++sb; break; }\n            assert(eb[b] >= 0); assert(thr[b] >= 0);\n            {\n                const w_curr = gfc.PSY.bo_l_weight[sb]; const w_next = 1.0 - w_curr;\n                const enn_curr = w_curr * eb[b]; const thmm_curr = w_curr * thr[b];\n                gfc.en[chn].l[sb] += enn_curr; gfc.thm[chn].l[sb] += thmm_curr;\n                enn = w_next * eb[b]; thmm = w_next * thr[b];\n            }\n             b++;\n        }\n        for (; sb < Encoder.SBMAX_l; ++sb) { gfc.en[chn].l[sb] = 0; gfc.thm[chn].l[sb] = 0; }\n    }\n\n    /** @private */\n    _compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        const gfc = gfp.internal_flags; let j, b;\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            let ebb = 0; const n = gfc.numlines_s[b];\n            for (let i = 0; i < n; ++i, ++j) ebb += fftenergy_s[sblock][j];\n            eb[b] = ebb;\n        }\n        assert(b === gfc.npart_s); assert(j === Encoder.HBLKSIZE_s);\n        let s3_idx = 0;\n        for (b = 0; b < gfc.npart_s; b++) {\n            const first_masker_idx = gfc.s3ind_s[b][0]; const last_masker_idx = gfc.s3ind_s[b][1];\n            let kk = first_masker_idx; let ecb = 0;\n            while (kk <= last_masker_idx) { ecb += gfc.s3_ss[s3_idx] * eb[kk]; s3_idx++; kk++; }\n            {\n                const limit1 = rpelev_s * gfc.nb_s1[chn][b];\n                thr[b] = Math.min(ecb, limit1);\n                if (gfc.blocktype_old[chn & 1] === Encoder.SHORT_TYPE) {\n                    const limit2 = rpelev2_s * gfc.nb_s2[chn][b];\n                    thr[b] = Math.min(thr[b], limit2);\n                }\n            }\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b]; gfc.nb_s1[chn][b] = ecb;\n            assert(thr[b] >= 0);\n        }\n        assert(b === gfc.npart_s);\n        for (; b <= Encoder.CBANDS; ++b) { eb[b] = 0; thr[b] = 0; }\n        if (b <= Encoder.CBANDS + 1) thr[b] = 0;\n    }\n\n    /** @private */\n    _block_type_set(gfp, uselongblock, blocktype_d, blocktype) {\n        const gfc = gfp.internal_flags;\n        if (gfp.short_blocks === ShortBlock.short_block_coupled && !(uselongblock[0] !== 0 && uselongblock[1] !== 0)) {\n            uselongblock[0] = uselongblock[1] = 0;\n        }\n        for (let chn = 0; chn < gfc.channels_out; chn++) {\n            if (gfp.short_blocks === ShortBlock.short_block_dispensed) uselongblock[chn] = 1;\n            if (gfp.short_blocks === ShortBlock.short_block_forced) uselongblock[chn] = 0;\n            blocktype[chn] = Encoder.NORM_TYPE;\n            let final_prev_type = gfc.blocktype_old[chn]; // Start assuming previous state persists\n\n            if (uselongblock[chn] !== 0) { // Current is LONG\n                 assert(gfc.blocktype_old[chn] !== Encoder.START_TYPE);\n                 if (gfc.blocktype_old[chn] === Encoder.SHORT_TYPE) {\n                      blocktype[chn] = Encoder.STOP_TYPE; // Current logic determines STOP\n                      final_prev_type = Encoder.STOP_TYPE; // Previous becomes STOP\n                 }\n                  // else: Previous was NORM or STOP, current is NORM. final_prev_type remains NORM or STOP. blocktype[chn] is NORM.\n            } else { // Current is SHORT\n                 blocktype[chn] = Encoder.SHORT_TYPE;\n                 if (gfc.blocktype_old[chn] === Encoder.NORM_TYPE) {\n                     // Previous was NORM, becomes START\n                     final_prev_type = Encoder.START_TYPE;\n                 } else if (gfc.blocktype_old[chn] === Encoder.STOP_TYPE) {\n                     // Previous was STOP, becomes SHORT\n                     final_prev_type = Encoder.SHORT_TYPE;\n                 }\n                 // else: Previous was START or SHORT, remains START or SHORT. final_prev_type = gfc.blocktype_old[chn]. blocktype[chn] is SHORT.\n            }\n            blocktype_d[chn] = final_prev_type;\n            gfc.blocktype_old[chn] = blocktype[chn]; // Save current decision as history\n        }\n    }\n\n    /** @private */\n    _NS_INTERP(x, y, r) {\n        if (r >= 1.0) return x;\n        if (r <= 0.0) return y;\n        if (y > 0.0) return (Math.pow(x / y, r) * y);\n        return 0.0;\n    }\n\n    /** @private */\n    _pecalc_s(mr, masking_lower) {\n        let pe_s = 309.07;\n        for (let sb = 0; sb < Encoder.SBMAX_s - 1; sb++) {\n            assert(sb < regcoef_s.length);\n            for (let sblock = 0; sblock < 3; sblock++) {\n                const thm = mr.thm.s[sb][sblock];\n                if (thm > 0.0) {\n                    const x = thm * masking_lower; const en = mr.en.s[sb][sblock];\n                    if (en > x) {\n                        if (en > x * 1e10) { pe_s += regcoef_s[sb] * (10.0 * LOG10); }\n                        else { assert(x > 0); pe_s += regcoef_s[sb] * Util.FAST_LOG10(en / x); }\n                    }\n                }\n            }\n        }\n        return pe_s;\n    }\n\n    /** @private */\n    _pecalc_l(mr, masking_lower) {\n        let pe_l = 281.0575;\n        for (let sb = 0; sb < Encoder.SBMAX_l - 1; sb++) {\n            assert(sb < regcoef_l.length);\n            const thm = mr.thm.l[sb];\n            if (thm > 0.0) {\n                const x = thm * masking_lower; const en = mr.en.l[sb];\n                if (en > x) {\n                    if (en > x * 1e10) { pe_l += regcoef_l[sb] * (10.0 * LOG10); }\n                    else { assert(x > 0); pe_l += regcoef_l[sb] * Util.FAST_LOG10(en / x); }\n                }\n            }\n        }\n        return pe_l;\n    }\n\n    /** @private */\n    _calc_energy(gfc, fftenergy, eb, max, avg) {\n        let b, j;\n        for (b = j = 0; b < gfc.npart_l; ++b) {\n            let ebb = 0, m = 0; const numlines = gfc.numlines_l[b];\n            for (let i = 0; i < numlines; ++i, ++j) { const el = fftenergy[j]; assert(el >= 0); ebb += el; if (m < el) m = el; }\n            eb[b] = ebb; max[b] = m; avg[b] = ebb * gfc.rnumlines_l[b];\n            assert(gfc.rnumlines_l[b] >= 0); assert(ebb >= 0); assert(eb[b] >= 0); assert(max[b] >= 0); assert(avg[b] >= 0);\n        }\n         assert(b === gfc.npart_l); assert(j === Encoder.HBLKSIZE);\n    }\n\n    /** @private */\n    _calc_mask_index_l(gfc, max, avg, mask_idx) {\n        const last_tab_entry = tab.length - 1; let b = 0;\n        let a = avg[b] + avg[b + 1]; assert(a >= 0);\n        if (a > 0.0) {\n            let m = max[b]; if (m < max[b + 1]) m = max[b + 1];\n            const nl = gfc.numlines_l[b] + gfc.numlines_l[b + 1]; assert(nl - 1 > 0);\n            a = 20.0 * (m * 2.0 - a) / (a * (nl - 1));\n            let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n        } else mask_idx[b] = 0;\n        for (b = 1; b < gfc.npart_l - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1]; assert(a >= 0);\n            if (a > 0.0) {\n                let m = max[b - 1]; if (m < max[b]) m = max[b]; if (m < max[b + 1]) m = max[b + 1];\n                const nl = gfc.numlines_l[b - 1] + gfc.numlines_l[b] + gfc.numlines_l[b + 1]; assert(nl - 1 > 0);\n                a = 20.0 * (m * 3.0 - a) / (a * (nl - 1));\n                let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n            } else mask_idx[b] = 0;\n        }\n        assert(b > 0); assert(b === gfc.npart_l - 1);\n        a = avg[b - 1] + avg[b]; assert(a >= 0);\n        if (a > 0.0) {\n            let m = max[b - 1]; if (m < max[b]) m = max[b];\n            const nl = gfc.numlines_l[b - 1] + gfc.numlines_l[b]; assert(nl - 1 > 0);\n            a = 20.0 * (m * 2.0 - a) / (a * (nl - 1));\n            let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n        } else mask_idx[b] = 0;\n        assert(b === (gfc.npart_l - 1));\n    }\n\n    /** @private */\n    _psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx) {\n        const last_tab_entry = tab.length - 1; let b = 0;\n        let a = avg[b] + avg[b + 1]; assert(a >= 0);\n        if (a > 0.0) {\n            let m = max[b]; if (m < max[b + 1]) m = max[b + 1];\n            const nl = gfc.numlines_s[b] + gfc.numlines_s[b + 1]; assert(nl - 1 > 0);\n            a = 20.0 * (m * 2.0 - a) / (a * (nl - 1));\n            let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n        } else mask_idx[b] = 0;\n        for (b = 1; b < gfc.npart_s - 1; b++) {\n            a = avg[b - 1] + avg[b] + avg[b + 1]; assert(b + 1 < gfc.npart_s); assert(a >= 0);\n            if (a > 0.0) {\n                let m = max[b - 1]; if (m < max[b]) m = max[b]; if (m < max[b + 1]) m = max[b + 1];\n                const nl = gfc.numlines_s[b - 1] + gfc.numlines_s[b] + gfc.numlines_s[b + 1]; assert(nl - 1 > 0);\n                a = 20.0 * (m * 3.0 - a) / (a * (nl - 1));\n                let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n            } else mask_idx[b] = 0;\n        }\n        assert(b > 0); assert(b === gfc.npart_s - 1);\n        a = avg[b - 1] + avg[b]; assert(a >= 0);\n        if (a > 0.0) {\n            let m = max[b - 1]; if (m < max[b]) m = max[b];\n            const nl = gfc.numlines_s[b - 1] + gfc.numlines_s[b]; assert(nl - 1 > 0);\n            a = 20.0 * (m * 2.0 - a) / (a * (nl - 1));\n            let k = 0 | a; if(k<0)k=0; if (k > last_tab_entry) k = last_tab_entry; mask_idx[b] = k;\n        } else mask_idx[b] = 0;\n        assert(b === (gfc.npart_s - 1));\n    }\n\n    /** @private */\n    _vbrpsy_compute_masking_s(gfp, fftenergy_s, eb, thr, chn, sblock) {\n        const gfc = gfp.internal_flags;\n        const max = new_float(Encoder.CBANDS); const avg = new_float(Encoder.CBANDS);\n        const mask_idx_s = new_int(Encoder.CBANDS);\n        let i, j, b;\n        for (b = j = 0; b < gfc.npart_s; ++b) {\n            let ebb = 0, m = 0; const n = gfc.numlines_s[b];\n            for (i = 0; i < n; ++i, ++j) { const el = fftenergy_s[sblock][j]; ebb += el; if (m < el) m = el; }\n            eb[b] = ebb; assert(ebb >= 0); max[b] = m; assert(n > 0); avg[b] = ebb / n; assert(avg[b] >= 0);\n        }\n        assert(b === gfc.npart_s); assert(j === Encoder.HBLKSIZE_s);\n        for (; b < Encoder.CBANDS; ++b) { max[b] = 0; avg[b] = 0; }\n        this._psyvbr_calc_mask_index_s(gfc, max, avg, mask_idx_s);\n        let s3_idx = 0;\n        for (b = 0; b < gfc.npart_s; b++) {\n            const first_masker_idx = gfc.s3ind_s[b][0]; const last_masker_idx = gfc.s3ind_s[b][1];\n            let kk = first_masker_idx; let ecb = 0; let dd = 0; let dd_n = 0;\n            if (kk <= last_masker_idx) {\n                 dd = mask_idx_s[kk]; dd_n = 1;\n                 ecb = gfc.s3_ss[s3_idx] * eb[kk] * tab[mask_idx_s[kk]]; s3_idx++; kk++;\n                 while (kk <= last_masker_idx) {\n                     dd += mask_idx_s[kk]; dd_n += 1;\n                     const masker_contribution = gfc.s3_ss[s3_idx] * eb[kk] * tab[mask_idx_s[kk]];\n                     ecb = this._vbrpsy_mask_add(ecb, masker_contribution, kk - b); s3_idx++; kk++;\n                 }\n                 dd = (1 + 2 * dd) / (2 * dd_n); const avg_mask = tab[dd] * 0.5; ecb *= avg_mask;\n            } else { ecb = 0; }\n            thr[b] = ecb;\n            gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b]; gfc.nb_s1[chn][b] = ecb;\n            {\n                 let max_energy_limit = max[b] * gfc.minval_s[b] * tab[(1 + 2 * dd) / (2 * dd_n)] * 0.5;\n                 if (thr[b] > max_energy_limit) thr[b] = max_energy_limit;\n            }\n            if (gfc.masking_lower > 1) thr[b] *= gfc.masking_lower;\n            if (thr[b] > eb[b]) thr[b] = eb[b];\n            if (gfc.masking_lower < 1) thr[b] *= gfc.masking_lower;\n            assert(thr[b] >= 0);\n        }\n         assert(b === gfc.npart_s);\n         for (; b < Encoder.CBANDS; ++b) { eb[b] = 0; thr[b] = 0; }\n         for (; b <= Encoder.CBANDS + 1; ++b) { thr[b] = 0; }\n    }\n\n    /** @private */\n    _vbrpsy_compute_masking_l(gfc, fftenergy, eb_l, thr, chn) {\n        const max = new_float(Encoder.CBANDS); const avg = new_float(Encoder.CBANDS);\n        const mask_idx_l = new_int(Encoder.CBANDS + 2); let b;\n        this._calc_energy(gfc, fftenergy, eb_l, max, avg);\n        this._calc_mask_index_l(gfc, max, avg, mask_idx_l);\n        let s3_idx = 0;\n        for (b = 0; b < gfc.npart_l; b++) {\n            let ecb = 0; let dd = 0; let dd_n = 0;\n            const first_masker_idx = gfc.s3ind[b][0]; const last_masker_idx = gfc.s3ind[b][1];\n            let kk = first_masker_idx;\n            if (kk <= last_masker_idx) {\n                 dd = mask_idx_l[kk]; dd_n = 1;\n                 ecb = gfc.s3_ll[s3_idx] * eb_l[kk] * tab[mask_idx_l[kk]]; s3_idx++; kk++;\n                 while (kk <= last_masker_idx) {\n                     dd += mask_idx_l[kk]; dd_n += 1;\n                     const masker_contribution = gfc.s3_ll[s3_idx] * eb_l[kk] * tab[mask_idx_l[kk]];\n                     ecb = this._vbrpsy_mask_add(ecb, masker_contribution, kk - b); s3_idx++; kk++;\n                 }\n                 dd = (1 + 2 * dd) / (2 * dd_n); const avg_mask = tab[dd] * 0.5; ecb *= avg_mask;\n             } else { ecb = 0; }\n\n            const prev_blocktype = gfc.blocktype_old[chn & 0x01];\n            if (prev_blocktype === Encoder.SHORT_TYPE || prev_blocktype === Encoder.START_TYPE) {\n                const ecb_limit_1 = rpelev * gfc.nb_1[chn][b];\n                if (ecb_limit_1 > 0) thr[b] = Math.min(ecb, ecb_limit_1);\n                else thr[b] = Math.min(ecb, eb_l[b] * NS_PREECHO_ATT2);\n            } else {\n                let ecb_limit_2 = rpelev2 * gfc.nb_2[chn][b]; let ecb_limit_1 = rpelev * gfc.nb_1[chn][b];\n                if (ecb_limit_2 <= 0) ecb_limit_2 = ecb; if (ecb_limit_1 <= 0) ecb_limit_1 = ecb;\n                let ecb_limit = (prev_blocktype === Encoder.NORM_TYPE) ? Math.min(ecb_limit_1, ecb_limit_2) : ecb_limit_1;\n                thr[b] = Math.min(ecb, ecb_limit);\n            }\n            gfc.nb_2[chn][b] = gfc.nb_1[chn][b]; gfc.nb_1[chn][b] = ecb;\n            {\n                 let max_energy_limit = max[b] * gfc.minval_l[b] * tab[(1 + 2 * dd) / (2 * dd_n)] * 0.5;\n                 if (thr[b] > max_energy_limit) thr[b] = max_energy_limit;\n            }\n            if (gfc.masking_lower > 1) thr[b] *= gfc.masking_lower;\n            if (thr[b] > eb_l[b]) thr[b] = eb_l[b];\n            if (gfc.masking_lower < 1) thr[b] *= gfc.masking_lower;\n            assert(thr[b] >= 0);\n        }\n        assert(b === gfc.npart_l);\n        for (; b < Encoder.CBANDS; ++b) { eb_l[b] = 0; thr[b] = 0; }\n        for (; b <= Encoder.CBANDS + 1; ++b) { thr[b] = 0; }\n    }\n\n    /** @private */\n    _vbrpsy_compute_block_type(gfp, uselongblock) {\n        const gfc = gfp.internal_flags;\n        if (gfp.short_blocks === ShortBlock.short_block_coupled && !(uselongblock[0] !== 0 && uselongblock[1] !== 0)) {\n            uselongblock[0] = uselongblock[1] = 0;\n        }\n        for (let chn = 0; chn < gfc.channels_out; chn++) {\n            if (gfp.short_blocks === ShortBlock.short_block_dispensed) uselongblock[chn] = 1;\n            if (gfp.short_blocks === ShortBlock.short_block_forced) uselongblock[chn] = 0;\n        }\n    }\n\n    /** @private */\n    _vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d) {\n        const gfc = gfp.internal_flags;\n        for (let chn = 0; chn < gfc.channels_out; chn++) {\n            let current_blocktype = Encoder.NORM_TYPE;\n            let final_prev_type = gfc.blocktype_old[chn]; // Start assuming previous state persists\n            if (uselongblock[chn] !== 0) { // Current wants LONG\n                 assert(gfc.blocktype_old[chn] !== Encoder.START_TYPE);\n                 if (gfc.blocktype_old[chn] === Encoder.SHORT_TYPE) {\n                      current_blocktype = Encoder.STOP_TYPE;\n                      final_prev_type = Encoder.STOP_TYPE;\n                 }\n            } else { // Current wants SHORT\n                 current_blocktype = Encoder.SHORT_TYPE;\n                 if (gfc.blocktype_old[chn] === Encoder.NORM_TYPE) final_prev_type = Encoder.START_TYPE;\n                 else if (gfc.blocktype_old[chn] === Encoder.STOP_TYPE) final_prev_type = Encoder.SHORT_TYPE;\n            }\n            blocktype_d[chn] = final_prev_type;\n            gfc.blocktype_old[chn] = current_blocktype;\n        }\n    }\n\n    /** @private */\n    _vbrpsy_compute_MS_thresholds(eb, thr, cb_mld, ath_cb, athadjust, msfix, n) {\n        const msfix2 = msfix * 2.0;\n        const athlower = msfix > 0 ? athadjust : 1.0; // athadjust is already linear\n        let rside, rmid;\n        for (let b = 0; b < n; ++b) {\n            const ebM = eb[2][b]; const ebS = eb[3][b];\n            const thmL = thr[0][b]; const thmR = thr[1][b];\n            const thmM_orig = thr[2][b]; const thmS_orig = thr[3][b];\n            if (thmL <= 1.58 * thmR && thmR <= 1.58 * thmL) {\n                const mld_factor = cb_mld[b];\n                const mld_mid = mld_factor * ebS; const mld_side = mld_factor * ebM;\n                rmid = Math.max(thmM_orig, Math.min(thmS_orig, mld_mid));\n                rside = Math.max(thmS_orig, Math.min(thmM_orig, mld_side));\n            } else { rmid = thmM_orig; rside = thmS_orig; }\n            if (msfix > 0) {\n                const ath = ath_cb[b] * athlower;\n                const thmL_ath = Math.max(thmL, ath); const thmR_ath = Math.max(thmR, ath);\n                let thmM_ath = Math.max(rmid, ath); let thmS_ath = Math.max(rside, ath);\n                const thmLR_min_ath = Math.min(thmL_ath, thmR_ath);\n                const thmMS_sum_ath = thmM_ath + thmS_ath;\n                if (thmMS_sum_ath > 0 && (thmLR_min_ath * msfix2) < thmMS_sum_ath) { // VBR uses msfix2 here\n                    const f = thmLR_min_ath * msfix2 / thmMS_sum_ath;\n                    thmM_ath *= f; thmS_ath *= f;\n                     assert(thmM_ath + thmS_ath >= 0);\n                }\n                rmid = Math.min(thmM_ath, rmid); rside = Math.min(thmS_ath, rside);\n            }\n            if (rmid > ebM) rmid = ebM; if (rside > ebS) rside = ebS;\n            thr[2][b] = rmid; thr[3][b] = rside;\n        }\n    }\n\n    /** @private */\n    _vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out, fftenergy, wsamp_l, wsamp_lPos) {\n        const gfc = gfp.internal_flags;\n        const target_fft_l = wsamp_l[wsamp_lPos];\n        if (chn < 2) {\n            this.fft.fft_long(gfc, target_fft_l, chn, buffer, bufPos);\n        } else if (chn === 2) {\n            const left_fft_l = wsamp_l[0]; const right_fft_l = wsamp_l[1];\n            for (let j = Encoder.BLKSIZE - 1; j >= 0; --j) {\n                const l = left_fft_l[j]; const r = right_fft_l[j];\n                wsamp_l[0][j] = (l + r) * Util.SQRT2 * 0.5; wsamp_l[1][j] = (l - r) * Util.SQRT2 * 0.5;\n            }\n        }\n        fftenergy[0] = NON_LINEAR_SCALE_ENERGY(target_fft_l[0]); fftenergy[0] *= fftenergy[0];\n        for (let j = Encoder.BLKSIZE / 2 - 1; j >= 0; --j) {\n            const re = target_fft_l[Encoder.BLKSIZE / 2 - j]; const im = target_fft_l[Encoder.BLKSIZE / 2 + j];\n            fftenergy[Encoder.BLKSIZE / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);\n        }\n        { let totalenergy = 0.0; for (let j = 11; j < Encoder.HBLKSIZE; j++) totalenergy += fftenergy[j]; gfc.tot_ener[chn] = totalenergy; }\n        if (gfp.analysis) {\n            for (let j = 0; j < Encoder.HBLKSIZE; j++) { gfc.pinfo.energy[gr_out][chn][j] = gfc.pinfo.energy_save[chn][j]; gfc.pinfo.energy_save[chn][j] = fftenergy[j]; }\n             gfc.pinfo.pe[gr_out][chn] = gfc.pe[chn];\n        }\n    }\n\n    /** @private */\n    _vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock, fftenergy_s, wsamp_s, wsamp_sPos) {\n        const gfc = gfp.internal_flags;\n        const target_fft_s = wsamp_s[wsamp_sPos];\n        if (sblock === 0 && chn < 2) {\n            this.fft.fft_short(gfc, target_fft_s, chn, buffer, bufPos);\n        }\n        if (chn === 2) {\n            const left_fft_s = wsamp_s[0]; const right_fft_s = wsamp_s[1];\n            for (let j = Encoder.BLKSIZE_s - 1; j >= 0; --j) {\n                const l = left_fft_s[sblock][j]; const r = right_fft_s[sblock][j];\n                wsamp_s[0][sblock][j] = (l + r) * Util.SQRT2 * 0.5; wsamp_s[1][sblock][j] = (l - r) * Util.SQRT2 * 0.5;\n            }\n        }\n        const current_sblock_fft = target_fft_s[sblock];\n        fftenergy_s[sblock][0] = current_sblock_fft[0]; fftenergy_s[sblock][0] *= fftenergy_s[sblock][0];\n        for (let j = Encoder.BLKSIZE_s / 2 - 1; j >= 0; --j) {\n            const re = current_sblock_fft[Encoder.BLKSIZE_s / 2 - j]; const im = current_sblock_fft[Encoder.BLKSIZE_s / 2 + j];\n            fftenergy_s[sblock][Encoder.BLKSIZE_s / 2 - j] = NON_LINEAR_SCALE_ENERGY((re * re + im * im) * 0.5);\n        }\n    }\n\n    /** @private */\n    _vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn, fftenergy) {\n        const gfc = gfp.internal_flags;\n        if (gfp.athaa_loudapprox === 2 && chn < 2) {\n            gfc.loudness_sq[gr_out][chn] = gfc.loudness_sq_save[chn];\n            gfc.loudness_sq_save[chn] = this._psycho_loudness_approx(fftenergy, gfc);\n        }\n    }\n\n    /** @private */\n    _vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, energy, sub_short_factor, ns_attacks, uselongblock) {\n        const ns_hpfsmpl = new_float_n([2, 576]);\n        const gfc = gfp.internal_flags;\n        const n_chn_out = gfc.channels_out;\n        const n_chn_psy = (gfp.mode === MPEGMode.JOINT_STEREO) ? 4 : n_chn_out;\n        for (let chn = 0; chn < n_chn_out; chn++) {\n            const firbuf = buffer[chn]; const input_start_index = bufPos + 288 - (NSFIRLEN - 1) / 2;\n            for (let i = 0; i < 576; i++) {\n                let c_sum1 = 0.0, c_sum2 = 0.0; const base_idx = input_start_index + i;\n                c_sum1 = firbuf[base_idx + 10];\n                for (let j = 0; j < (NSFIRLEN - 1) / 2; j += 2) {\n                    c_sum1 += fircoef_[j] * (firbuf[base_idx + j] + firbuf[base_idx + NSFIRLEN - 1 - j]);\n                    c_sum2 += fircoef_[j + 1] * (firbuf[base_idx + j + 1] + firbuf[base_idx + NSFIRLEN - 1 - (j + 1)]);\n                } ns_hpfsmpl[chn][i] = c_sum1 + c_sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]); masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (n_chn_psy > 2) { masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]); masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]); }\n        }\n        for (let chn = 0; chn < n_chn_psy; chn++) {\n            const attack_intensity = new_float(12); const en_subshort = new_float(12); const en_short = [0.0, 0.0, 0.0, 0.0];\n            const attackThreshold = (chn === 3) ? NSATTACKTHRE_S : NSATTACKTHRE; let ns_uselongblock = 1;\n            if (chn === 2) { for (let i = 0; i < 576; ++i) { const l = ns_hpfsmpl[0][i]; const r = ns_hpfsmpl[1][i]; ns_hpfsmpl[0][i] = l + r; ns_hpfsmpl[1][i] = l - r; } }\n             const pf = ns_hpfsmpl[chn & 1];\n            let pfPos = 0;\n            for (let i = 0; i < 3; i++) { en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6]; assert(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0); attack_intensity[i] = en_subshort[i] / gfc.nsPsy.last_en_subshort[chn][i + 4]; en_short[0] += en_subshort[i]; }\n            for (let i = 0; i < 9; i++) {\n                const pfe = pfPos + 64; let p = 1.0; for (; pfPos < pfe; pfPos++) { const abs_sample = Math.abs(pf[pfPos]); if (p < abs_sample) p = abs_sample; }\n                gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p; en_short[1 + Math.floor(i / 3)] += p;\n                const prev_en = en_subshort[i + 3 - 2];\n                if (p > prev_en) { assert(prev_en > 0); attack_intensity[i + 3] = p / prev_en; }\n                else if (prev_en > p * 10.0) { assert(p > 0); attack_intensity[i + 3] = prev_en / (p * 10.0); }\n                else attack_intensity[i + 3] = 0.0;\n            }\n            for (let i = 0; i < 3; ++i) {\n                const sub_idx = i * 3 + 3; const enn = en_subshort[sub_idx] + en_subshort[sub_idx + 1] + en_subshort[sub_idx + 2]; let factor = 1.0;\n                if(enn > 0) { if (en_subshort[sub_idx + 2] * 6 < enn) { factor *= 0.5; if (en_subshort[sub_idx + 1] * 6 < enn) factor *= 0.5; } }\n                sub_short_factor[chn][i] = factor;\n            }\n            if (gfp.analysis) { let max_attack = attack_intensity[0]; for (let i = 1; i < 12; i++) if (max_attack < attack_intensity[i]) max_attack = attack_intensity[i]; gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn]; gfc.pinfo.ers_save[chn] = max_attack; }\n            Arrays.fill(ns_attacks[chn], 0);\n            for (let i = 0; i < 12; i++) { const block_idx = Math.floor(i / 3); if (ns_attacks[chn][block_idx] === 0 && attack_intensity[i] > attackThreshold) ns_attacks[chn][block_idx] = (i % 3) + 1; }\n            for (let i = 1; i < 4; i++) {\n                const u = en_short[i - 1]; const v = en_short[i]; const m = Math.max(u, v);\n                if (m < 40000) { if (u < 1.7 * v && v < 1.7 * u) { if (i === 1 && ns_attacks[chn][0] <= ns_attacks[chn][i]) ns_attacks[chn][0] = 0; ns_attacks[chn][i] = 0; } }\n            }\n            if (ns_attacks[chn][0] <= gfc.nsPsy.lastAttacks[chn]) ns_attacks[chn][0] = 0;\n            if (gfc.nsPsy.lastAttacks[chn] === 3 || (ns_attacks[chn][0] + ns_attacks[chn][1] + ns_attacks[chn][2] + ns_attacks[chn][3]) !== 0) {\n                ns_uselongblock = 0;\n                if (ns_attacks[chn][1] !== 0 && ns_attacks[chn][0] !== 0) ns_attacks[chn][1] = 0;\n                if (ns_attacks[chn][2] !== 0 && ns_attacks[chn][1] !== 0) ns_attacks[chn][2] = 0;\n                if (ns_attacks[chn][3] !== 0 && ns_attacks[chn][2] !== 0) ns_attacks[chn][3] = 0;\n            }\n            if (chn < 2) uselongblock[chn] = ns_uselongblock;\n            else if (ns_uselongblock === 0) uselongblock[0] = uselongblock[1] = 0;\n            energy[chn] = gfc.tot_ener[chn];\n        }\n    }\n\n    /** @private */\n    _vbrpsy_skip_masking_s(gfc, chn, sblock) {\n        if (sblock === 0) { for (let b = 0; b < gfc.npart_s; b++) { gfc.nb_s2[chn][b] = gfc.nb_s1[chn][b]; gfc.nb_s1[chn][b] = 0; } }\n    }\n\n    /** @private */\n    _vbrpsy_skip_masking_l(gfc, chn) {\n        for (let b = 0; b < gfc.npart_l; b++) { gfc.nb_2[chn][b] = gfc.nb_1[chn][b]; gfc.nb_1[chn][b] = 0; }\n    }\n\n    /** @private */\n    _s3_func_x(bark, hf_slope) {\n        let tempx = bark; let tempy;\n        if (tempx >= 0) tempy = -tempx * 27.0;\n        else tempy = tempx * hf_slope;\n        if (tempy <= -72.0) return 0.0;\n        return Math.exp(tempy * LN_TO_LOG10);\n    }\n\n    /** @private */\n    _norm_s3_func_x(hf_slope) {\n        let lim_a = 0, lim_b = 0;\n        { let x = 0, l, h; for (x = 0; this._s3_func_x(x, hf_slope) > 1e-20; x -= 1) ; l = x; h = 0; while (Math.abs(h - l) > 1e-12) { x = (h + l) / 2.0; if (this._s3_func_x(x, hf_slope) > 0) h = x; else l = x; } lim_a = l; }\n        { let x = 0, l, h; for (x = 0; this._s3_func_x(x, hf_slope) > 1e-20; x += 1) ; l = 0; h = x; while (Math.abs(h - l) > 1e-12) { x = (h + l) / 2.0; if (this._s3_func_x(x, hf_slope) > 0) l = x; else h = x; } lim_b = h; }\n        { let sum = 0; const m = 1000; const step = (lim_b - lim_a) / m; for (let i = 0; i <= m; ++i) { const x = lim_a + i * step; sum += this._s3_func_x(x, hf_slope); } if (sum === 0 || lim_b === lim_a) return 1.0; const norm = (m + 1) / (sum * (lim_b - lim_a)); return norm; }\n    }\n\n    /** @private */\n    _s3_func(bark) {\n        let tempx, x, tempy, temp; tempx = bark;\n        if (tempx >= 0) tempx *= 3.0; else tempx *= 1.5;\n        if (tempx >= 0.5 && tempx <= 2.5) { temp = tempx - 0.5; x = 8.0 * (temp * temp - 2.0 * temp); } else x = 0.0;\n        tempx += 0.474; tempy = 15.811389 + 7.5 * tempx - 17.5 * Math.sqrt(1.0 + tempx * tempx);\n        if (tempy <= -60.0) return 0.0;\n        tempx = Math.exp((x + tempy) * LN_TO_LOG10); tempx /= 0.6609193; return tempx;\n    }\n\n    /** @private */\n    _freq2bark(freq) {\n        if (freq < 0) freq = 0; freq = freq * 0.001;\n        return 13.0 * Math.atan(0.76 * freq) + 3.5 * Math.atan(freq * freq / (7.5 * 7.5));\n    }\n\n    /** @private */\n    _init_numline(numlines, bo, bm, bval, bval_width, mld, bo_w, sfreq, blksize, scalepos, deltafreq, sbmax) {\n        const b_frq = new_float(Encoder.CBANDS + 1);\n        const granule_samples = (sbmax > 15) ? 576 : 192;\n        const sample_freq_frac = sfreq / (2.0 * granule_samples);\n        const partition = new_int(Encoder.HBLKSIZE);\n        let ni = 0;\n        const freq_per_line = sfreq / blksize;\n        let fft_line_idx = 0;\n        for (let part_idx = 0; part_idx < Encoder.CBANDS; part_idx++) {\n            const bark_start = this._freq2bark(freq_per_line * fft_line_idx);\n            b_frq[part_idx] = freq_per_line * fft_line_idx;\n            let fft_line_end = fft_line_idx;\n            while (this._freq2bark(freq_per_line * fft_line_end) - bark_start < DELBARK && fft_line_end <= blksize / 2) { fft_line_end++; }\n            numlines[part_idx] = fft_line_end - fft_line_idx;\n            ni = part_idx + 1;\n            while (fft_line_idx < fft_line_end) { assert(fft_line_idx < Encoder.HBLKSIZE); partition[fft_line_idx++] = part_idx; }\n            if (fft_line_idx > blksize / 2) { fft_line_idx = blksize / 2; break; }\n        }\n        assert(ni < Encoder.CBANDS);\n        b_frq[ni] = freq_per_line * fft_line_idx;\n        for (let sfb = 0; sfb < sbmax; sfb++) {\n            const sfb_start_line = scalepos[sfb]; const sfb_end_line = scalepos[sfb + 1];\n            let i1 = 0 | Math.floor(0.5 + deltafreq * (sfb_start_line - 0.5)); if (i1 < 0) i1 = 0;\n            let i2 = 0 | Math.floor(0.5 + deltafreq * (sfb_end_line - 0.5)); if (i2 >= blksize / 2) i2 = blksize / 2 -1; if(i2 < i1) i2 = i1;\n            const part1 = (i1 < Encoder.HBLKSIZE) ? partition[i1] : ni - 1; const part2 = (i2 < Encoder.HBLKSIZE) ? partition[i2] : ni - 1;\n            bm[sfb] = Math.floor((part1 + part2) / 2); bo[sfb] = part2;\n            const f_sfb_end = sample_freq_frac * sfb_end_line;\n            const f_part_start = b_frq[bo[sfb]]; const f_part_end = b_frq[bo[sfb] + 1];\n             if (f_part_end > f_part_start) bo_w[sfb] = (f_sfb_end - f_part_start) / (f_part_end - f_part_start);\n             else bo_w[sfb] = (f_sfb_end >= f_part_start) ? 1.0 : 0.0;\n             if (bo_w[sfb] < 0) bo_w[sfb] = 0.0; else if (bo_w[sfb] > 1) bo_w[sfb] = 1.0;\n             const mld_freq = freq_per_line * i1; mld[sfb] = this._stereo_demask(mld_freq);\n        }\n        let current_fft_line = 0;\n        for (let k = 0; k < ni; k++) {\n            const w = numlines[k];\n            if (w > 0) {\n                 const bark1 = this._freq2bark(freq_per_line * current_fft_line); const bark2 = this._freq2bark(freq_per_line * (current_fft_line + w - 1));\n                 bval[k] = 0.5 * (bark1 + bark2);\n                 const bark_edge1 = this._freq2bark(freq_per_line * (current_fft_line - 0.5)); const bark_edge2 = this._freq2bark(freq_per_line * (current_fft_line + w - 0.5));\n                 bval_width[k] = bark_edge2 - bark_edge1;\n            } else { bval[k] = (k > 0) ? bval[k-1] : 0; bval_width[k] = 0; }\n            current_fft_line += w;\n        }\n        return ni;\n    }\n\n    /** @private */\n    _init_s3_values(npart, bval, bval_width, norm, use_old_s3) {\n        const s3 = new_float_n([Encoder.CBANDS, Encoder.CBANDS]); let numberOfNoneZero = 0;\n        if (use_old_s3) {\n             for (let i = 0; i < npart; i++) for (let j = 0; j < npart; j++) s3[i][j] = this._s3_func(bval[i] - bval[j]) * bval_width[j] * norm[i];\n        } else {\n            for (let j = 0; j < npart; j++) {\n                const hf_slope = 15.0 + Math.min(21.0 / (bval[j]>0?bval[j]:1e-6), 12.0); // Avoid div by zero\n                const s3_x_norm = this._norm_s3_func_x(hf_slope);\n                for (let i = 0; i < npart; i++) s3[i][j] = s3_x_norm * this._s3_func_x(bval[i] - bval[j], hf_slope) * bval_width[j] * norm[i];\n            }\n        }\n\n        // Initialize s3ind with default values\n        for (let i = 0; i < npart; i++) {\n            this.s3ind[i][0] = 0;\n            this.s3ind[i][1] = npart - 1;\n        }\n\n        // Then update with actual masking ranges\n        for (let i = 0; i < npart; i++) {\n             let start_masker, end_masker;\n             for (start_masker = 0; start_masker < npart; start_masker++) if (s3[i][start_masker] > 1e-20) break; // Use threshold\n             for (end_masker = npart - 1; end_masker >= start_masker; end_masker--) if (s3[i][end_masker] > 1e-20) break;\n             if (start_masker <= end_masker) { this.s3ind[i][0] = start_masker; this.s3ind[i][1] = end_masker; numberOfNoneZero += (end_masker - start_masker + 1); }\n             else { this.s3ind[i][0] = 0; this.s3ind[i][1] = -1; }\n        }\n        const p = new_float(numberOfNoneZero); let k = 0;\n        for (let i = 0; i < npart; i++) { const start = this.s3ind[i][0]; const end = this.s3ind[i][1]; if (start <= end) for (let j = start; j <= end; j++) p[k++] = s3[i][j]; }\n        assert(k === numberOfNoneZero); return p;\n    }\n\n    /** @private */\n    _stereo_demask(f) {\n        let arg = this._freq2bark(f); arg = (Math.min(arg, 15.5) / 15.5);\n        return Math.pow(10.0, 1.25 * (1.0 - Math.cos(Math.PI * arg)) - 2.5);\n    }\n\n    /** @private */\n    _ATHformula_GB(f, value) {\n        if (f < -0.3) f = 3410.0;\n        f /= 1000.0; f = Math.max(0.1, f);\n        const ath = 3.640 * Math.pow(f, -0.8) - 6.800 * Math.exp(-0.6 * Math.pow(f - 3.4, 2.0)) + 6.000 * Math.exp(-0.15 * Math.pow(f - 8.7, 2.0)) + (0.6 + 0.04 * value) * 0.001 * Math.pow(f, 4.0);\n        return ath;\n    }\n\n\n    // --- Public Methods ---\n\n    /**\n     * Performs psychoacoustic analysis using the NSPSYTUNE model modifications.\n     * Computes masking thresholds, perceptual entropy, and determines block types\n     * based on attack detection using a high-pass filtered signal.\n     * Returns results delayed by one granule.\n     *\n     * @public\n     * @param {object} gfp - LAME global flags and settings.\n     * @param {Array<Float32Array>} buffer - Input PCM buffer [channels][samples]. Contains 1152 samples per channel.\n     * @param {number} bufPos - Starting index within the buffer (typically 0).\n     * @param {number} gr_out - Granule index (0 or 1) for storing output results.\n     * @param {Array<Array<object>>} masking_ratio - Output: Array [2][2] storing masking results (en/thm) for L/R channels of the *previous* granule. Each element has `.en` and `.thm` properties, which are themselves objects with `.l` (Float32Array[SBMAX_l]) and `.s` (Array<Float32Array>[SBMAX_s][3]) properties.\n     * @param {Array<Array<object>>} masking_MS_ratio - Output: Array [2][2] storing masking results (en/thm) for M/S channels of the *previous* granule. Structure same as `masking_ratio`.\n     * @param {Float32Array} percep_entropy - Output: Array [2] for perceptual entropy (PE) for L/R channels of the *previous* granule.\n     * @param {Float32Array} percep_MS_entropy - Output: Array [2] for perceptual entropy (PE) for M/S channels of the *previous* granule.\n     * @param {Float32Array} energy - Output: Array [4] for total energy (L, R, M, S) of the *previous* granule.\n     * @param {Int32Array} blocktype_d - Output: Array [2] indicating the determined block type (see `Encoder` constants like `NORM_TYPE`, `SHORT_TYPE` etc.) for L/R channels of the *previous* granule.\n     * @returns {number} Status code (0 for success).\n     */\n    L3psycho_anal_ns(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        const gfc = gfp.internal_flags;\n        const wsamp_L = new_float_n([2, Encoder.BLKSIZE]);\n        const wsamp_S = new_float_n([2, 3, Encoder.BLKSIZE_s]);\n        const eb_l = new_float(Encoder.CBANDS + 1);\n        const eb_s = new_float(Encoder.CBANDS + 1);\n        const thr = new_float(Encoder.CBANDS + 2);\n        const blocktype = new_int(2);\n        const uselongblock = new_int(2);\n        const ns_hpfsmpl = new_float_n([2, 576]);\n        let pcfact;\n        const mask_idx_l = new_int(Encoder.CBANDS + 2);\n\n        let numchn = gfc.channels_out;\n        if (gfp.mode === MPEGMode.JOINT_STEREO) numchn = 4;\n\n        if (gfp.VBR === VbrMode.vbr_off) pcfact = gfc.ResvMax === 0 ? 0 : (gfc.ResvSize / gfc.ResvMax) * 0.5;\n        else if (gfp.VBR === VbrMode.vbr_rh || gfp.VBR === VbrMode.vbr_mtrh || gfp.VBR === VbrMode.vbr_mt) pcfact = 0.6;\n        else pcfact = 1.0;\n\n        // Apply HPF and copy previous results\n        for (let chn = 0; chn < gfc.channels_out; chn++) {\n            const firbuf = buffer[chn];\n            const input_start_index = bufPos + 288 - (NSFIRLEN - 1) / 2; // Center 576 samples start at 288 in 1152 buffer\n            for (let i = 0; i < 576; i++) {\n                let c_sum1 = 0.0, c_sum2 = 0.0;\n                const base_idx = input_start_index + i;\n                c_sum1 = firbuf[base_idx + 10];\n                for (let j = 0; j < (NSFIRLEN - 1) / 2; j += 2) {\n                    c_sum1 += fircoef[j] * (firbuf[base_idx + j] + firbuf[base_idx + NSFIRLEN - 1 - j]);\n                    c_sum2 += fircoef[j + 1] * (firbuf[base_idx + j + 1] + firbuf[base_idx + NSFIRLEN - 1 - (j + 1)]);\n                }\n                ns_hpfsmpl[chn][i] = c_sum1 + c_sum2;\n            }\n            masking_ratio[gr_out][chn].en.assign(gfc.en[chn]);\n            masking_ratio[gr_out][chn].thm.assign(gfc.thm[chn]);\n            if (numchn > 2) {\n                masking_MS_ratio[gr_out][chn].en.assign(gfc.en[chn + 2]);\n                masking_MS_ratio[gr_out][chn].thm.assign(gfc.thm[chn + 2]);\n            }\n        }\n\n        // Main processing loop per channel\n        for (let chn = 0; chn < numchn; chn++) {\n            const current_wsamp_l_idx = chn & 1;\n            const current_wsamp_s_idx = chn & 1;\n            const en_subshort = new_float(12);\n            const en_short = [0.0, 0.0, 0.0, 0.0];\n            const attack_intensity = new_float(12);\n            let ns_uselongblock = 1;\n            const max = new_float(Encoder.CBANDS);\n            const avg = new_float(Encoder.CBANDS);\n            const ns_attacks = [0, 0, 0, 0]; // Renamed from C's static/global-like array\n            const fftenergy = new_float(Encoder.HBLKSIZE);\n            const fftenergy_s = new_float_n([3, Encoder.HBLKSIZE_s]);\n\n            // Block Type Determination (Attack Detection)\n             for (let i = 0; i < 3; i++) { en_subshort[i] = gfc.nsPsy.last_en_subshort[chn][i + 6]; assert(gfc.nsPsy.last_en_subshort[chn][i + 4] > 0); attack_intensity[i] = en_subshort[i] / gfc.nsPsy.last_en_subshort[chn][i + 4]; en_short[0] += en_subshort[i]; }\n             if (chn === 2) { for (let i = 0; i < 576; i++) { const l = ns_hpfsmpl[0][i]; const r = ns_hpfsmpl[1][i]; ns_hpfsmpl[0][i] = l + r; ns_hpfsmpl[1][i] = l - r; } }\n             { const pf = ns_hpfsmpl[chn & 1]; let pfPos = 0; for (let i = 0; i < 9; i++) { const pfe = pfPos + 64; let p = 1.0; for (; pfPos < pfe; pfPos++) { const abs_sample = Math.abs(pf[pfPos]); if (p < abs_sample) p = abs_sample; } gfc.nsPsy.last_en_subshort[chn][i] = en_subshort[i + 3] = p; en_short[1 + Math.floor(i / 3)] += p; const prev_en = en_subshort[i + 3 - 2]; if (p > prev_en) { assert(prev_en > 0); attack_intensity[i + 3] = p / prev_en; } else if (prev_en > p * 10.0) { assert(p > 0); attack_intensity[i + 3] = prev_en / (p * 10.0); } else attack_intensity[i + 3] = 0.0; } assert(pfPos === 576);}\n             if (gfp.analysis) { let max_attack = attack_intensity[0]; for (let i = 1; i < 12; i++) if (max_attack < attack_intensity[i]) max_attack = attack_intensity[i]; gfc.pinfo.ers[gr_out][chn] = gfc.pinfo.ers_save[chn]; gfc.pinfo.ers_save[chn] = max_attack; }\n             const attackThreshold = (chn === 3) ? NSATTACKTHRE_S : NSATTACKTHRE; for (let i = 0; i < 12; i++) { if (ns_attacks[Math.floor(i / 3)] === 0 && attack_intensity[i] > attackThreshold) ns_attacks[Math.floor(i / 3)] = (i % 3) + 1; }\n             for (let i = 1; i < 4; i++) { const en_curr = en_short[i]; const en_prev = en_short[i - 1]; let ratio = 1.0; if (en_prev > 0 && en_curr > 0) ratio = (en_prev > en_curr) ? (en_prev / en_curr) : (en_curr / en_prev); else if (en_prev > 0 || en_curr > 0) ratio = 100; if (ratio < 1.7) { ns_attacks[i] = 0; if (i === 1) ns_attacks[0] = 0; } }\n             if (ns_attacks[0] !== 0 && gfc.nsPsy.lastAttacks[chn] !== 0) ns_attacks[0] = 0;\n             if (gfc.nsPsy.lastAttacks[chn] === 3 || (ns_attacks[0] + ns_attacks[1] + ns_attacks[2] + ns_attacks[3]) !== 0) { ns_uselongblock = 0; if (ns_attacks[1] !== 0 && ns_attacks[0] !== 0) ns_attacks[1] = 0; if (ns_attacks[2] !== 0 && ns_attacks[1] !== 0) ns_attacks[2] = 0; if (ns_attacks[3] !== 0 && ns_attacks[2] !== 0) ns_attacks[3] = 0; }\n             if (chn < 2) uselongblock[chn] = ns_uselongblock; else if (ns_uselongblock === 0) uselongblock[0] = uselongblock[1] = 0;\n\n            energy[chn] = gfc.tot_ener[chn]; // Store previous granule's energy\n\n            // Compute FFTs\n            this._compute_ffts(gfp, fftenergy, fftenergy_s, wsamp_L, current_wsamp_l_idx, wsamp_S, current_wsamp_s_idx, gr_out, chn, buffer, bufPos);\n\n            // Compute Masking Thresholds - Short Blocks\n            for (let sblock = 0; sblock < 3; sblock++) {\n                this._compute_masking_s(gfp, fftenergy_s, eb_s, thr, chn, sblock);\n                this._convert_partition2scalefac_s(gfc, eb_s, thr, chn, sblock);\n                // Short block pre-echo control\n                 for (let sb = 0; sb < Encoder.SBMAX_s; sb++) { let thmm = gfc.thm[chn].s[sb][sblock]; thmm *= NS_PREECHO_ATT0; if (ns_attacks[sblock] >= 2 || ns_attacks[sblock + 1] === 1) { const idx = (sblock !== 0) ? sblock - 1 : 2; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT1 * pcfact); thmm = Math.min(thmm, p); } if (ns_attacks[sblock] === 1) { const idx = (sblock !== 0) ? sblock - 1 : 2; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT2 * pcfact); thmm = Math.min(thmm, p); } else if ((sblock !== 0 && ns_attacks[sblock - 1] === 3) || (sblock === 0 && gfc.nsPsy.lastAttacks[chn] === 3)) { const idx = (sblock !== 2) ? sblock + 1 : 0; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT2 * pcfact); thmm = Math.min(thmm, p); } const sub_en_idx = sblock * 3 + 3; const enn = en_subshort[sub_en_idx] + en_subshort[sub_en_idx + 1] + en_subshort[sub_en_idx + 2]; if (enn > 0 && en_subshort[sub_en_idx + 2] * 6 < enn) { thmm *= 0.5; if (en_subshort[sub_en_idx + 1] * 6 < enn) thmm *= 0.5; } gfc.thm[chn].s[sb][sblock] = thmm; }\n            }\n            gfc.nsPsy.lastAttacks[chn] = ns_attacks[2]; // Store attack state of last short block\n\n            // Compute Masking Thresholds - Long Blocks\n            this._calc_energy(gfc, fftenergy, eb_l, max, avg);\n            this._calc_mask_index_l(gfc, max, avg, mask_idx_l);\n            let s3_idx = 0;\n            for (let b = 0; b < gfc.npart_l; b++) {\n                 const first_masker_idx = gfc.s3ind[b][0]; const last_masker_idx = gfc.s3ind[b][1]; let kk = first_masker_idx; let ecb = 0;\n                 if (kk <= last_masker_idx) { let masker_energy = eb_l[kk] * tab[mask_idx_l[kk]]; ecb = gfc.s3_ll[s3_idx] * masker_energy; s3_idx++; kk++; while (kk <= last_masker_idx) { masker_energy = eb_l[kk] * tab[mask_idx_l[kk]]; const term = gfc.s3_ll[s3_idx] * masker_energy; ecb = this._mask_add(ecb, term, kk, kk - b, gfc, 0); s3_idx++; kk++; } }\n                 ecb *= 0.158489319246111;\n                 // Long block pre-echo control\n                 if (gfc.blocktype_old[chn & 1] === Encoder.SHORT_TYPE) thr[b] = ecb; else { const min_limit = Math.min(rpelev * gfc.nb_1[chn][b], rpelev2 * gfc.nb_2[chn][b]); const clamped_ecb = Math.min(ecb, min_limit); thr[b] = this._NS_INTERP(clamped_ecb, ecb, pcfact); }\n                 gfc.nb_2[chn][b] = gfc.nb_1[chn][b]; gfc.nb_1[chn][b] = ecb;\n            }\n             for (let b = gfc.npart_l; b <= Encoder.CBANDS; ++b) { eb_l[b] = 0; thr[b] = 0; } if (gfc.npart_l <= Encoder.CBANDS + 1) thr[gfc.npart_l+1]=0;\n\n            this._convert_partition2scalefac_l(gfc, eb_l, thr, chn);\n\n        } // End loop over chn\n\n        // Post-processing\n        if (gfp.mode === MPEGMode.STEREO || gfp.mode === MPEGMode.JOINT_STEREO) {\n            if (gfp.interChRatio > 0.0) this._calc_interchannel_masking(gfp, gfp.interChRatio);\n        }\n        if (gfp.mode === MPEGMode.JOINT_STEREO) {\n            this._msfix1(gfc);\n            const msfix = gfp.msfix;\n            if (Math.abs(msfix) > 0.0) {\n                const ath_adj_factor = Math.pow(10, gfp.ATHlower * gfc.ATH.adjust); // Calculate linear factor\n                this._ns_msfix(gfc, msfix, ath_adj_factor);\n            }\n        }\n\n        // Determine final block type for previous granule\n        this._block_type_set(gfp, uselongblock, blocktype_d, blocktype);\n\n        // Compute PE for previous granule\n        for (let chn = 0; chn < numchn; chn++) {\n            let ppe_array, ppe_offset, granule_block_type, mr;\n            if (chn > 1) { ppe_array = percep_MS_entropy; ppe_offset = -2; granule_block_type = Encoder.NORM_TYPE; if (blocktype_d[0] === Encoder.SHORT_TYPE || blocktype_d[1] === Encoder.SHORT_TYPE) granule_block_type = Encoder.SHORT_TYPE; mr = masking_MS_ratio[gr_out][chn - 2]; }\n            else { ppe_array = percep_entropy; ppe_offset = 0; granule_block_type = blocktype_d[chn]; mr = masking_ratio[gr_out][chn]; }\n            if (granule_block_type === Encoder.SHORT_TYPE || granule_block_type === Encoder.STOP_TYPE || granule_block_type === Encoder.START_TYPE) ppe_array[ppe_offset + chn] = this._pecalc_s(mr, gfc.masking_lower);\n            else ppe_array[ppe_offset + chn] = this._pecalc_l(mr, gfc.masking_lower);\n            if (gfp.analysis) gfc.pinfo.pe[gr_out][chn] = ppe_array[ppe_offset + chn];\n        }\n\n        return 0; // Success\n    }\n\n    /**\n     * Performs psychoacoustic analysis using the VBR model.\n     * This version optimizes by calculating only the necessary block type (long or short)\n     * based on attack detection. It uses VBR-specific masking calculations and adjustments.\n     * Returns results delayed by one granule.\n     *\n     * @public\n     * @param {object} gfp - LAME global flags and settings.\n     * @param {Array<Float32Array>} buffer - Input PCM buffer [channels][samples]. Contains 1152 samples per channel.\n     * @param {number} bufPos - Starting index within the buffer (typically 0).\n     * @param {number} gr_out - Granule index (0 or 1) for storing output results.\n     * @param {Array<Array<object>>} masking_ratio - Output: Array [2][2] storing masking results (en/thm) for L/R channels of the *previous* granule. Structure same as `L3psycho_anal_ns`.\n     * @param {Array<Array<object>>} masking_MS_ratio - Output: Array [2][2] storing masking results (en/thm) for M/S channels of the *previous* granule. Structure same as `L3psycho_anal_ns`.\n     * @param {Float32Array} percep_entropy - Output: Array [2] for perceptual entropy (PE) for L/R channels of the *previous* granule.\n     * @param {Float32Array} percep_MS_entropy - Output: Array [2] for perceptual entropy (PE) for M/S channels of the *previous* granule.\n     * @param {Float32Array} energy - Output: Array [4] for total energy (L, R, M, S) of the *previous* granule.\n     * @param {Int32Array} blocktype_d - Output: Array [2] indicating the determined block type (see `Encoder` constants) for L/R channels of the *previous* granule.\n     * @returns {number} Status code (0 for success).\n     */\n    L3psycho_anal_vbr(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, percep_entropy, percep_MS_entropy, energy, blocktype_d) {\n        const gfc = gfp.internal_flags;\n        const wsamp_L = new_float_n([2, Encoder.BLKSIZE]);\n        const wsamp_S = new_float_n([2, 3, Encoder.BLKSIZE_s]);\n        const fftenergy = new_float(Encoder.HBLKSIZE);\n        const fftenergy_s = new_float_n([3, Encoder.HBLKSIZE_s]);\n        const eb = new_float_n([4, Encoder.CBANDS + 1]);\n        const thr = new_float_n([4, Encoder.CBANDS + 2]);\n        const sub_short_factor = new_float_n([4, 3]);\n        const pcfact = 0.6; // Fixed for VBR?\n        const ns_attacks = new_array_n([4], () => new_int(4));\n        const uselongblock = new_int(2);\n        const n_chn_psy = (gfp.mode === MPEGMode.JOINT_STEREO) ? 4 : gfc.channels_out;\n\n        // 1. Attack detection\n        this._vbrpsy_attack_detection(gfp, buffer, bufPos, gr_out, masking_ratio, masking_MS_ratio, energy, sub_short_factor, ns_attacks, uselongblock);\n\n        // 2. Compute initial block type choice\n        this._vbrpsy_compute_block_type(gfp, uselongblock);\n\n        // 3. Compute Masking - Long Blocks (conditional)\n        for (let chn = 0; chn < n_chn_psy; chn++) {\n             const ch01 = chn & 0x01;\n             this._vbrpsy_compute_fft_l(gfp, buffer, bufPos, chn, gr_out, fftenergy, wsamp_L, ch01);\n             this._vbrpsy_compute_loudness_approximation_l(gfp, gr_out, chn, fftenergy);\n             if (uselongblock[ch01] !== 0) this._vbrpsy_compute_masking_l(gfc, fftenergy, eb[chn], thr[chn], chn);\n             else this._vbrpsy_skip_masking_l(gfc, chn);\n        }\n        if (uselongblock[0] !== 0 && uselongblock[1] !== 0) {\n            if (gfp.mode === MPEGMode.JOINT_STEREO) {\n                 const ath_adj_factor = Math.pow(10, gfp.ATHlower * gfc.ATH.adjust); // Linear factor\n                 this._vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_l, gfc.ATH.cb_l, ath_adj_factor, gfp.msfix, gfc.npart_l);\n            }\n             for (let chn = 0; chn < n_chn_psy; chn++) this._convert_partition2scalefac_l(gfc, eb[chn], thr[chn], chn);\n        }\n\n\n        // 4. Compute Masking - Short Blocks (conditional)\n        const compute_short = (uselongblock[0] === 0 || uselongblock[1] === 0);\n        if (compute_short) {\n            for (let sblock = 0; sblock < 3; sblock++) {\n                for (let chn = 0; chn < n_chn_psy; ++chn) {\n                    const ch01 = chn & 0x01;\n                    if (uselongblock[ch01] === 0) {\n                        this._vbrpsy_compute_fft_s(gfp, buffer, bufPos, chn, sblock, fftenergy_s, wsamp_S, ch01);\n                        this._vbrpsy_compute_masking_s(gfp, fftenergy_s, eb[chn], thr[chn], chn, sblock);\n                    } else { this._vbrpsy_skip_masking_s(gfc, chn, sblock); }\n                }\n                if (uselongblock[0] === 0 && uselongblock[1] === 0) {\n                    if (gfp.mode === MPEGMode.JOINT_STEREO) {\n                         const ath_adj_factor = Math.pow(10, gfp.ATHlower * gfc.ATH.adjust) * (Encoder.BLKSIZE_s / Encoder.BLKSIZE); // Scaled linear factor\n                         this._vbrpsy_compute_MS_thresholds(eb, thr, gfc.mld_cb_s, gfc.ATH.cb_s, ath_adj_factor, gfp.msfix, gfc.npart_s);\n                    }\n                     for (let chn = 0; chn < n_chn_psy; ++chn) this._convert_partition2scalefac_s(gfc, eb[chn], thr[chn], chn, sblock);\n                } else {\n                     for (let chn = 0; chn < n_chn_psy; ++chn) if (uselongblock[chn & 0x01] === 0) this._convert_partition2scalefac_s(gfc, eb[chn], thr[chn], chn, sblock);\n                }\n            }\n            // Short block pre-echo control\n            for (let chn = 0; chn < n_chn_psy; chn++) {\n                const ch01 = chn & 0x01; if (uselongblock[ch01] === 0) {\n                    const new_thmm = new_float(3);\n                    for (let sb = 0; sb < Encoder.SBMAX_s; sb++) {\n                        for (let sblock = 0; sblock < 3; sblock++) {\n                            let thmm = gfc.thm[chn].s[sb][sblock]; thmm *= NS_PREECHO_ATT0;\n                             if (ns_attacks[chn][sblock] >= 2 || ns_attacks[chn][sblock + 1] === 1) { const idx = (sblock !== 0) ? sblock - 1 : 2; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT1 * pcfact); thmm = Math.min(thmm, p); }\n                             else if (ns_attacks[chn][sblock] === 1) { const idx = (sblock !== 0) ? sblock - 1 : 2; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT2 * pcfact); thmm = Math.min(thmm, p); }\n                             else if ((sblock !== 0 && ns_attacks[chn][sblock - 1] === 3) || (sblock === 0 && gfc.nsPsy.lastAttacks[chn] === 3)) { const idx = (sblock !== 2) ? sblock + 1 : 0; const p = this._NS_INTERP(gfc.thm[chn].s[sb][idx], thmm, NS_PREECHO_ATT2 * pcfact); thmm = Math.min(thmm, p); }\n                             thmm *= sub_short_factor[chn][sblock]; new_thmm[sblock] = thmm;\n                        }\n                        for (let sblock = 0; sblock < 3; sblock++) gfc.thm[chn].s[sb][sblock] = new_thmm[sblock];\n                    }\n                }\n            }\n        }\n\n        // Store last attack state\n        for (let chn = 0; chn < n_chn_psy; chn++) gfc.nsPsy.lastAttacks[chn] = ns_attacks[chn][2];\n\n        // 5. Determine final block type for previous granule\n        this._vbrpsy_apply_block_type(gfp, uselongblock, blocktype_d);\n\n        // 6. Compute PE for previous granule\n        for (let chn = 0; chn < n_chn_psy; chn++) {\n            let ppe_array, ppe_offset, granule_block_type, mr;\n            if (chn > 1) { ppe_array = percep_MS_entropy; ppe_offset = -2; granule_block_type = Encoder.NORM_TYPE; if (blocktype_d[0] === Encoder.SHORT_TYPE || blocktype_d[1] === Encoder.SHORT_TYPE) granule_block_type = Encoder.SHORT_TYPE; mr = masking_MS_ratio[gr_out][chn - 2]; }\n            else { ppe_array = percep_entropy; ppe_offset = 0; granule_block_type = blocktype_d[chn]; mr = masking_ratio[gr_out][chn]; }\n            if (granule_block_type === Encoder.SHORT_TYPE || granule_block_type === Encoder.STOP_TYPE || granule_block_type === Encoder.START_TYPE) ppe_array[ppe_offset + chn] = this._pecalc_s(mr, gfc.masking_lower);\n            else ppe_array[ppe_offset + chn] = this._pecalc_l(mr, gfc.masking_lower);\n            if (gfp.analysis) gfc.pinfo.pe[gr_out][chn] = ppe_array[ppe_offset + chn];\n        }\n\n        return 0; // Success\n    }\n\n    /**\n     * Initializes the psychoacoustic model constants and workspaces.\n     * Must be called before analysis. Calculates partition bands, spreading functions,\n     * ATH, MLD, etc., based on sample rate and encoding parameters.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags and settings. Holds encoding parameters like sample rate, mode, quality settings, ATH type etc.\n     * @returns {number} Status code (0 for success).\n     */\n    psymodel_init(gfp) {\n        const gfc = gfp.internal_flags;\n        let i, j, k;    \n        let useOldS3 = true; let bvl_a = 13.0, bvl_b = 24.0;\n        let snr_l_a = 0.0, snr_l_b = 0.0; let snr_s_a = -8.25, snr_s_b = -4.5;\n        const bval = new_float(Encoder.CBANDS); const bval_width = new_float(Encoder.CBANDS);\n        const norm = new_float(Encoder.CBANDS); const sfreq = gfp.out_samplerate;\n\n        switch (gfp.experimentalZ) {\n            default: case 0: useOldS3 = true; break;\n            case 1: useOldS3 = !(gfp.VBR === VbrMode.vbr_mtrh || gfp.VBR === VbrMode.vbr_mt); break;\n            case 2: useOldS3 = false; break;\n            case 3: bvl_a = 8; snr_l_a = -1.75; snr_l_b = -0.0125; snr_s_a = -8.25; snr_s_b = -2.25; break;\n        }\n        gfc.ms_ener_ratio_old = .25; gfc.blocktype_old[0] = gfc.blocktype_old[1] = Encoder.NORM_TYPE;\n        for (i = 0; i < 4; ++i) {\n            for (j = 0; j < Encoder.CBANDS; ++j) { gfc.nb_1[i][j] = 1e20; gfc.nb_2[i][j] = 1e20; gfc.nb_s1[i][j] = gfc.nb_s2[i][j] = 1.0; }\n            if (gfc.en[i] && gfc.thm[i]) { // Check both en and thm\n                for (let sb = 0; sb < Encoder.SBMAX_l; sb++) { gfc.en[i].l[sb] = 1e20; gfc.thm[i].l[sb] = 1e20; }\n                for (j = 0; j < 3; ++j) for (let sb = 0; sb < Encoder.SBMAX_s; sb++) { gfc.en[i].s[sb][j] = 1e20; gfc.thm[i].s[sb][j] = 1e20; }\n            } else {\n                console.error(`gfc.en[${i}] or gfc.thm[${i}] is undefined in psymodel_init!`);\n                return -1; // Critical error\n            }\n             gfc.nsPsy.lastAttacks[i] = 0;\n             for (j = 0; j < 9; j++) gfc.nsPsy.last_en_subshort[i][j] = 10.;\n        }\n        gfc.loudness_sq_save[0] = gfc.loudness_sq_save[1] = 0.0;\n\n        // Compute partition mappings, bark values, MLD for LONG blocks\n        gfc.npart_l = this._init_numline(gfc.numlines_l, gfc.bo_l, gfc.bm_l, bval, bval_width, gfc.mld_l, gfc.PSY.bo_l_weight, sfreq, Encoder.BLKSIZE, gfc.scalefac_band.l, Encoder.BLKSIZE / (2.0 * 576), Encoder.SBMAX_l);\n        assert(gfc.npart_l < Encoder.CBANDS);\n        // Compute normalization factors (based on SNR) and reciprocal line counts\n        for (i = 0; i < gfc.npart_l; i++) {\n            let snr = snr_l_a; if (bval[i] >= bvl_a) snr = snr_l_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_l_a * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n            norm[i] = Math.pow(10.0, snr / 10.0);\n            gfc.rnumlines_l[i] = (gfc.numlines_l[i] > 0) ? 1.0 / gfc.numlines_l[i] : 0;\n        }\n        // Compute spreading function values (flattened array)\n        gfc.s3_ll = this._init_s3_values(gfc.npart_l, bval, bval_width, norm, useOldS3);\n\n        // Compute long block ATH and MINVAL per partition\n        j = 0;\n        for (i = 0; i < gfc.npart_l; i++) {\n            let minval = Util.FLOAT_MAX;\n            for (let l = 0; l < gfc.numlines_l[i]; l++, j++) {\n                const freq = sfreq * j / (1000.0 * Encoder.BLKSIZE);\n                let level = this.ATHformula(freq * 1000, gfp) - 20;\n                level = Math.pow(10, 0.1 * level) * gfc.numlines_l[i];\n                minval = Math.min(minval, level);\n            }\n            gfc.minval_l[i] = minval;\n        }\n\n        // Compute partition mappings, bark values, MLD for SHORT blocks\n        gfc.npart_s = this._init_numline(gfc.numlines_s, gfc.bo_s, gfc.bm_s, bval, bval_width, gfc.mld_s, gfc.PSY.bo_s_weight, sfreq, Encoder.BLKSIZE_s, gfc.scalefac_band.s, Encoder.BLKSIZE_s / (2.0 * 192), Encoder.SBMAX_s);\n        assert(gfc.npart_s < Encoder.CBANDS);\n        // Compute short block normalization factors, ATH, MINVAL per partition\n        j = 0;\n        for (i = 0; i < gfc.npart_s; i++) {\n             let x; let snr = snr_s_a; if (bval[i] >= bvl_a) snr = snr_s_b * (bval[i] - bvl_a) / (bvl_b - bvl_a) + snr_s_a * (bvl_b - bval[i]) / (bvl_b - bvl_a);\n             norm[i] = Math.pow(10.0, snr / 10.0);\n             x = Float.MAX_VALUE;\n             for (k = 0; k < gfc.numlines_s[i]; k++, j++) { const freq = sfreq * j / (1000.0 * Encoder.BLKSIZE_s); let level = this.ATHformula(freq * 1000, gfp) - 20; level = Math.pow(10., 0.1 * level) * gfc.numlines_s[i]; if (x > level) x = level; }\n             gfc.ATH.cb_s[i] = x;\n             x = (-7.0 + bval[i] * 7.0 / 12.0); if (bval[i] > 12) x *= 1 + Math.log(1 + x) * 3.1; if (bval[i] < 12) x *= 1 + Math.log(1 - x) * 2.3; if (x < -15) x = -15; x -= 8; gfc.minval_s[i] = Math.pow(10.0, x / 10) * gfc.numlines_s[i];\n        }\n        // Compute short block spreading function values\n        gfc.s3_ss = this._init_s3_values(gfc.npart_s, bval, bval_width, norm, useOldS3);\n\n        // Initialize other parameters\n        init_mask_add_max_values();\n        this.fft.init_fft(gfc);\n        gfc.decay = Math.exp(-1.0 * LOG10 / (temporalmask_sustain_sec * sfreq / 192.0));\n        let msfix = NS_MSFIX; if ((gfp.exp_nspsytune & 2) != 0) msfix = 1.0; if (Math.abs(gfp.msfix) > 0.0) msfix = gfp.msfix; gfp.msfix = msfix;\n        for (let b = 0; b < gfc.npart_l; b++) if (gfc.s3ind[b][1] > gfc.npart_l - 1) gfc.s3ind[b][1] = gfc.npart_l - 1;\n\n        // ATH auto adjustment init\n        const frame_duration = (576. * gfc.mode_gr / sfreq);\n        gfc.ATH.decay = Math.pow(10., -12. / 10. * frame_duration);\n        gfc.ATH.adjust = 0.01; gfc.ATH.adjustLimit = 1.0;\n\n        // Equal loudness weights init\n        if (gfp.ATHtype != -1) {\n            const freq_inc = gfp.out_samplerate / (Encoder.BLKSIZE); let eql_balance = 0.0; let freq = 0.0;\n            for (i = 0; i < Encoder.BLKSIZE / 2; ++i) { freq += freq_inc; gfc.ATH.eql_w[i] = 1. / Math.pow(10, this.ATHformula(freq, gfp) / 10); eql_balance += gfc.ATH.eql_w[i]; }\n             if(eql_balance > 0) eql_balance = 1.0 / eql_balance; else eql_balance = 0; // Avoid division by zero\n            for (i = Encoder.BLKSIZE / 2; --i >= 0;) gfc.ATH.eql_w[i] *= eql_balance;\n        }\n\n        // Partition band MLD calculation (using center frequency)\n         j = 0; for (i = 0; i < gfc.npart_l; i++) { const freq = sfreq * (j + gfc.numlines_l[i] / 2.0) / (1.0 * Encoder.BLKSIZE); gfc.mld_cb_l[i] = this._stereo_demask(freq); j += gfc.numlines_l[i]; } for (; i < Encoder.CBANDS; ++i) gfc.mld_cb_l[i] = 1;\n         j = 0; for (i = 0; i < gfc.npart_s; i++) { const freq = sfreq * (j + gfc.numlines_s[i] / 2.0) / (1.0 * Encoder.BLKSIZE_s); gfc.mld_cb_s[i] = this._stereo_demask(freq); j += gfc.numlines_s[i]; } for (; i < Encoder.CBANDS; ++i) gfc.mld_cb_s[i] = 1;\n\n        return 0; // Success\n    }\n\n\n    /**\n     * Calculates the Absolute Threshold of Hearing (ATH) in dB SPL for a given frequency.\n     * Selects the appropriate formula based on `gfp.ATHtype`.\n     * Provides options for different ATH curves (e.g., Painter/Spanias, Bouvigne).\n     * Includes a special input `f < -0.3` to request the minimum ATH value.\n     *\n     * @public\n     * @param {number} f - Frequency in Hz. Use f < -0.3 to get the minimum ATH.\n     * @param {object} gfp - LAME global flags (used to select ATH type and curve).\n     * @returns {number} ATH level in dB SPL.\n     */\n    ATHformula(f, gfp) {\n        let ath;\n        switch (gfp.ATHtype) {\n            case 0: ath = this._ATHformula_GB(f, 9.0); break;\n            case 1: ath = this._ATHformula_GB(f, -1.0); break;\n            case 2: ath = this._ATHformula_GB(f, 0.0); break;\n            case 3: ath = this._ATHformula_GB(f, 1.0) + 6.0; break;\n            case 4: ath = this._ATHformula_GB(f, gfp.ATHcurve); break;\n            default: ath = this._ATHformula_GB(f, 0.0); break;\n        }\n        return ath;\n    }\n\n}\n\n// Export the class\nexport { PsyModel };","/**\n * @fileoverview Global flags and settings for the LAME encoder.\n * Ported from lame.h. Defines parameters controlling the encoding process.\n * Uses ES Module syntax.\n *\n * @module LameGlobalFlags\n */\n\nimport { MPEGMode } from './MPEGMode.js';\n// Import common and destructure needed parts\nimport * as common from './common.js';\nconst { VbrMode, ShortBlock } = common; // Destructure needed enums/objects\n\n// Assuming LameInternalFlags is defined elsewhere and imported if needed for type info\n/** @typedef {import('./LameInternalFlags.js').default} LameInternalFlags */\n/** @typedef {import('./VbrMode.js').default} VbrMode */ // Assuming VbrMode enum/object exists\n/** @typedef {import('./ShortBlock.js').default} ShortBlock */ // Assuming ShortBlock enum/object exists\n\n/**\n * @classdesc Global flags and settings controlling the LAME encoding process.\n * This structure holds configuration parameters set by the user application,\n * defining input audio properties, encoding mode, quality, VBR settings,\n * psychoacoustic parameters, filtering, etc. It also contains some internal\n * state variables populated by LAME during initialization and encoding.\n * @constructs LameGlobalFlags\n */\nclass LameGlobalFlags {\n\n    /**\n     * Internal flags and state variables used by the encoder.\n     * @public\n     * @type {LameInternalFlags|null}\n     */\n    internal_flags = null;\n\n    /**\n     * Class identifier (unused in JS version).\n     * @public\n     * @type {number}\n     */\n    class_id = 0;\n\n    /* input description */\n\n    /**\n     * Total number of PCM samples in the input audio. Set by the application.\n     * Default: -1 (unknown)\n     * @public\n     * @type {number}\n     */\n    num_samples = 0;\n\n    /**\n     * Number of channels in the input audio (e.g., 1 for mono, 2 for stereo).\n     * Default: 2\n     * @public\n     * @type {number}\n     */\n    num_channels = 0;\n\n    /**\n     * Sample rate of the input audio in Hz.\n     * Default: 44100\n     * @public\n     * @type {number}\n     */\n    in_samplerate = 0;\n\n    /**\n     * Sample rate of the output MP3 file in Hz. LAME usually chooses the best rate\n     * based on the input rate and MPEG standards unless explicitly set.\n     * Default: 0 (LAME chooses)\n     * @public\n     * @type {number}\n     */\n    out_samplerate = 0;\n\n    /**\n     * Global scaling factor applied to the input PCM data before encoding.\n     * Default: 0.95 (historical?) - often set to 1.0.\n     * @public\n     * @type {number}\n     */\n    scale = 0.0;\n\n    /**\n     * Scaling factor applied specifically to the left channel (channel 0).\n     * Overrides `scale` if set.\n     * @public\n     * @type {number}\n     */\n    scale_left = 0.0;\n\n    /**\n     * Scaling factor applied specifically to the right channel (channel 1).\n     * Overrides `scale` if set.\n     * @public\n     * @type {number}\n     */\n    scale_right = 0.0;\n\n    /* general control params */\n\n    /**\n     * Enable frame analysis for debugging/informational purposes.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    analysis = false;\n\n    /**\n     * Add an Xing VBR header to the MP3 file for accurate duration/seeking.\n     * Automatically enabled for VBR modes.\n     * Default: false (but often enabled automatically)\n     * @public\n     * @type {boolean}\n     */\n    bWriteVbrTag = false;\n\n    /**\n     * Use LAME for decoding MP3 to WAV instead of encoding.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    decode_only = false;\n\n    /**\n     * Encoding quality setting. Range: 0 (highest quality, slowest) to 9 (lowest quality, fastest).\n     * Affects algorithm choices and speed/quality trade-offs.\n     * Default: 5\n     * @public\n     * @type {number}\n     */\n    quality = 0;\n\n    /**\n     * MPEG encoding mode (e.g., STEREO, JOINT_STEREO, MONO). See `MPEGMode` enum.\n     * Default: LAME chooses based on input channels and other settings.\n     * @public\n     * @type {MPEGMode}\n     */\n    mode = MPEGMode.STEREO; // Assuming MPEGMode.STEREO is the default intended\n\n    /**\n     * Force the use of Mid/Side stereo encoding. Only effective if `mode` is JOINT_STEREO.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    force_ms = false;\n\n    /**\n     * Use the MP3 free format, which allows arbitrary bitrates.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    free_format = false;\n\n    /**\n     * Calculate and store ReplayGain information in the output file.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    findReplayGain = false;\n\n    /**\n     * Decode the MP3 stream during encoding (e.g., for gapless playback calculation).\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    decode_on_the_fly = false;\n\n    /**\n     * Automatically write ID3v2 tags (and potentially ID3v1) to the output file.\n     * Default: true\n     * @public\n     * @type {boolean}\n     */\n    write_id3tag_automatic = false;\n\n    /* Bitrate / Compression settings */\n\n    /**\n     * Target bitrate in kbps for CBR (Constant BitRate) mode. Set this *or* `compression_ratio`.\n     * Default: 0 (use compression_ratio)\n     * @public\n     * @type {number}\n     */\n    brate = 0;\n\n    /**\n     * Target compression ratio (input size / output size). Set this *or* `brate`.\n     * Default: 11.025 (approximates 128kbps for 44.1kHz stereo)\n     * @public\n     * @type {number}\n     */\n    compression_ratio = 0.0;\n\n    /* frame params */\n\n    /**\n     * Mark the MP3 frame header's copyright bit.\n     * Default: 0 (false)\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    copyright = 0;\n\n    /**\n     * Mark the MP3 frame header's original bit.\n     * Default: 1 (true)\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    original = 0;\n\n    /**\n     * Set the MP3 frame header's 'private extension' bit (rarely used).\n     * Default: 0\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    extension = 0;\n\n    /**\n     * Indicate that the input PCM data has pre-emphasis applied (rare).\n     * Note: LAME's psychoacoustic model does not account for this.\n     * Default: 0 (false)\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    emphasis = 0;\n\n    /**\n     * Add a CRC checksum to each MP3 frame for error detection. Adds 2 bytes per frame.\n     * Default: 0 (false)\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    error_protection = 0;\n\n    /**\n     * Enforce strict adherence to ISO MPEG standards where possible.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    strict_ISO = false;\n\n    /* Bit Reservoir */\n\n    /**\n     * Disable the use of the bit reservoir. Primarily for debugging/analysis.\n     * Default: false (reservoir enabled)\n     * @public\n     * @type {boolean}\n     */\n    disable_reservoir = false;\n\n    /* quantization/noise shaping */\n\n    /**\n     * Quantization noise shaping comparison mode (for long blocks). See LAME documentation.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    quant_comp = 0;\n\n    /**\n     * Quantization noise shaping comparison mode (for short blocks). See LAME documentation.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    quant_comp_short = 0;\n\n    /**\n     * Enable experimental psychoacoustic tuning 'Y'.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    experimentalY = false;\n\n    /**\n     * Select experimental psychoacoustic tuning 'Z' mode (0, 1, 2, 3).\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    experimentalZ = 0;\n\n    /**\n     * Bitfield for activating various NSPSYTUNE experimental features.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    exp_nspsytune = 0;\n\n    /**\n     * LAME preset value used (if any). Informational. See LAME documentation for preset values.\n     * Default: 0 (no preset specified)\n     * @public\n     * @type {number}\n     */\n    preset = 0;\n\n    /* VBR control */\n\n    /**\n     * Variable BitRate mode selection. See `VbrMode` enum.\n     * Default: `VbrMode.vbr_off` (CBR)\n     * @public\n     * @type {VbrMode}\n     */\n    VBR = null; // Should be initialized, e.g., VbrMode.vbr_off\n\n    /**\n     * Fractional part of VBR quality setting (for finer control between VBR_q levels). Range [0, 1).\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    VBR_q_frac = 0.0;\n\n    /**\n     * VBR quality setting. Range [0=highest, 9=lowest]. Lower values use more bits.\n     * Default: 4\n     * @public\n     * @type {number}\n     */\n    VBR_q = 0;\n\n    /**\n     * Target average bitrate in kbps for ABR (Average BitRate) mode.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    VBR_mean_bitrate_kbps = 0;\n\n    /**\n     * Minimum allowed bitrate in kbps for VBR/ABR modes.\n     * Default: 0 (use LAME default, e.g., 8 or 32)\n     * @public\n     * @type {number}\n     */\n    VBR_min_bitrate_kbps = 0;\n\n    /**\n     * Maximum allowed bitrate in kbps for VBR/ABR modes.\n     * Default: 0 (use LAME default, e.g., 320)\n     * @public\n     * @type {number}\n     */\n    VBR_max_bitrate_kbps = 0;\n\n    /**\n     * Strictly enforce `VBR_min_bitrate_kbps`. If false (default), the minimum\n     * can be violated for periods of analog silence.\n     * Default: 0 (false)\n     * @public\n     * @type {number|boolean} // Typically 0 or 1\n     */\n    VBR_hard_min = 0;\n\n    /* resampling and filtering */\n\n    /**\n     * Lowpass filter cutoff frequency in Hz. 0 means LAME chooses based on bitrate/samplerate. -1 disables filter.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    lowpassfreq = 0;\n\n    /**\n     * Highpass filter cutoff frequency in Hz. 0 means LAME chooses. -1 disables filter.\n     * Default: 0\n     * @public\n     * @type {number}\n     */\n    highpassfreq = 0;\n\n    /**\n     * Width of the lowpass filter transition band in Hz.\n     * Default: 0 (use LAME default, typically 15% of cutoff freq)\n     * @public\n     * @type {number}\n     */\n    lowpasswidth = 0;\n\n    /**\n     * Width of the highpass filter transition band in Hz.\n     * Default: 0 (use LAME default, typically 15% of cutoff freq)\n     * @public\n     * @type {number}\n     */\n    highpasswidth = 0;\n\n    /* Psychoacoustics and advanced settings */\n\n    /**\n     * Masking adjustment (dB) for long blocks. Positive values lower thresholds (more masking).\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    maskingadjust = 0.0;\n\n    /**\n     * Masking adjustment (dB) for short blocks.\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    maskingadjust_short = 0.0;\n\n    /**\n     * Use only the Absolute Threshold of Hearing (ATH) for masking, ignore signal masking.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    ATHonly = false;\n\n    /**\n     * Use only ATH for short blocks.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    ATHshort = false;\n\n    /**\n     * Disable the use of the ATH entirely.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    noATH = false;\n\n    /**\n     * Selects the ATH formula to use (0-4). See `ATHformula` documentation.\n     * Default: 4 (uses ATHcurve) ? Check LAME defaults. Often defaults based on quality.\n     * @public\n     * @type {number}\n     */\n    ATHtype = 0;\n\n    /**\n     * Shape adjustment parameter for ATH formula type 4. Range [-100, 10].\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    ATHcurve = 0.0;\n\n    /**\n     * Lower the calculated ATH by this amount in dB. Can compensate for quiet environments.\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    ATHlower = 0.0;\n\n    /**\n     * Selects the ATH auto-adjustment algorithm type.\n     * Default: -1 (disabled) ? Check LAME defaults.\n     * @public\n     * @type {number}\n     */\n    athaa_type = 0;\n\n    /**\n     * Selects the loudness calculation method for ATH auto-adjustment.\n     * Default: 0 ? Check LAME defaults.\n     * @public\n     * @type {number}\n     */\n    athaa_loudapprox = 0;\n\n    /**\n     * Sensitivity parameter for ATH auto-adjustment (dB). Tunes the active region.\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    athaa_sensitivity = 0.0;\n\n    /**\n     * Controls short block switching behavior. See `ShortBlock` enum.\n     * Default: `short_block_t.short_block_allowed` ? Check LAME defaults.\n     * @public\n     * @type {ShortBlock}\n     */\n    short_blocks = null; // Should be initialized, e.g., ShortBlock.short_block_mixed\n\n    /**\n     * Enable the use of temporal masking psychoacoustic effects.\n     * Default: true ? Check LAME defaults.\n     * @public\n     * @type {boolean}\n     */\n    useTemporal = false;\n\n    /**\n     * Inter-channel masking ratio. Reduces masking difference between channels. Range [0, 1].\n     * Default: 0.0 (disabled)\n     * @public\n     * @type {number}\n     */\n    interChRatio = 0.0;\n\n    /**\n     * Naoki Shibata's Mid/Side masking adjustment factor. Range [-10, 10].\n     * Positive values increase Side channel masking.\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    msfix = 0.0;\n\n    /**\n     * Enable specific psychoacoustic tuning based on the `--tune` option in command-line LAME.\n     * Default: false\n     * @public\n     * @type {boolean}\n     */\n    tune = false;\n\n    /**\n     * Auxiliary value used by the `--tune` option for specific adjustments.\n     * Default: 0.0\n     * @public\n     * @type {number}\n     */\n    tune_value_a = 0.0;\n\n    /* Internal variables (read-only for application) */\n\n    /**\n     * MPEG version used (0=MPEG-2/2.5, 1=MPEG-1). Set internally by LAME.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    version = 0;\n\n    /**\n     * Encoder delay in samples (due to MDCT overlap). Set internally.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    encoder_delay = 0;\n\n    /**\n     * Number of padding samples added at the end of the input stream. Set internally.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    encoder_padding = 0;\n\n    /**\n     * Number of samples per MP3 frame. Set internally based on version and sample rate.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    framesize = 0;\n\n    /**\n     * Counter for the number of frames encoded so far. Updated internally.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    frameNum = 0;\n\n    /**\n     * Internal flag indicating if LAME allocated this structure.\n     * @public\n     * @readonly\n     * @type {number}\n     */\n    lame_allocated_gfp = 0;\n\n    // Constructor logic can initialize defaults if needed\n    constructor() {\n        // Set default values matching comments where available\n        this.num_samples = -1;\n        this.num_channels = 2;\n        this.in_samplerate = 44100;\n        this.out_samplerate = 0;\n        this.scale = 1.0; // Changed from 0 to 1 based on common usage\n        this.scale_left = 1.0;\n        this.scale_right = 1.0;\n        this.analysis = false;\n        this.bWriteVbrTag = false; // Will be set automatically for VBR\n        this.decode_only = false;\n        this.quality = 5;\n        this.mode = MPEGMode.STEREO; // Default mode\n        this.force_ms = false;\n        this.free_format = false;\n        this.findReplayGain = false;\n        this.decode_on_the_fly = false;\n        this.write_id3tag_automatic = true; // Common default\n        this.brate = 0;\n        this.compression_ratio = 11.025; // ~128kbps default\n        this.copyright = 0;\n        this.original = 1;\n        this.extension = 0;\n        this.emphasis = 0;\n        this.error_protection = 0;\n        this.strict_ISO = false;\n        this.disable_reservoir = false;\n        this.quant_comp = 0;\n        this.quant_comp_short = 0;\n        this.experimentalY = false;\n        this.experimentalZ = 0;\n        this.exp_nspsytune = 0;\n        this.preset = 0;\n        this.VBR = 0; // Use imported VbrMode\n        this.VBR_q_frac = 0.0;\n        this.VBR_q = 4; // Common VBR default\n        this.VBR_mean_bitrate_kbps = 0;\n        this.VBR_min_bitrate_kbps = 0;\n        this.VBR_max_bitrate_kbps = 0;\n        this.VBR_hard_min = 0;\n        this.lowpassfreq = 0;\n        this.highpassfreq = 0;\n        this.lowpasswidth = 0;\n        this.highpasswidth = 0;\n        this.maskingadjust = 0.0;\n        this.maskingadjust_short = 0.0;\n        this.ATHonly = false;\n        this.ATHshort = false;\n        this.noATH = false;\n        this.ATHtype = 4; // Default to type 4 / ATHcurve ? Check LAME behavior\n        this.ATHcurve = 0.0;\n        this.ATHlower = 0.0;\n        this.athaa_type = -1; // Default disabled?\n        this.athaa_loudapprox = 0;\n        this.athaa_sensitivity = 0.0;\n        this.short_blocks = common.ShortBlock.short_block_allowed; // Sensible default? Or mixed?\n        this.useTemporal = true; // Often enabled by default?\n        this.interChRatio = 0.0;\n        this.msfix = 0.0;\n        this.tune = false;\n        this.tune_value_a = 0.0;\n\n        // Internal vars are initialized by LAME itself\n        this.version = 0;\n        this.encoder_delay = 0;\n        this.encoder_padding = 0;\n        this.framesize = 0;\n        this.frameNum = 0;\n        this.lame_allocated_gfp = 0;\n        this.internal_flags = null;\n    }\n}\n\nexport { LameGlobalFlags }; // Use named export\nexport default LameGlobalFlags; // Also provide default export if needed","import * as common from './common.js';\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nimport { Encoder } from './Encoder.js';\n\n/**\n * ATH related stuff, if something new ATH related has to be added, please plug\n * it here into the ATH.\n */\nfunction ATH() {\n    /**\n     * Method for the auto adjustment.\n     */\n    this.useAdjust = 0;\n    /**\n     * factor for tuning the (sample power) point below which adaptive threshold\n     * of hearing adjustment occurs\n     */\n    this.aaSensitivityP = 0.;\n    /**\n     * Lowering based on peak volume, 1 = no lowering.\n     */\n    this.adjust = 0.;\n    /**\n     * Limit for dynamic ATH adjust.\n     */\n    this.adjustLimit = 0.;\n    /**\n     * Determined to lower x dB each second.\n     */\n    this.decay = 0.;\n    /**\n     * Lowest ATH value.\n     */\n    this.floor = 0.;\n    /**\n     * ATH for sfbs in long blocks.\n     */\n    this.l = new_float(Encoder.SBMAX_l);\n    /**\n     * ATH for sfbs in short blocks.\n     */\n    this.s = new_float(Encoder.SBMAX_s);\n    /**\n     * ATH for partitioned sfb21 in long blocks.\n     */\n    this.psfb21 = new_float(Encoder.PSFB21);\n    /**\n     * ATH for partitioned sfb12 in short blocks.\n     */\n    this.psfb12 = new_float(Encoder.PSFB12);\n    /**\n     * ATH for long block convolution bands.\n     */\n    this.cb_l = new_float(Encoder.CBANDS);\n    /**\n     * ATH for short block convolution bands.\n     */\n    this.cb_s = new_float(Encoder.CBANDS);\n    /**\n     * Equal loudness weights (based on ATH).\n     */\n    this.eql_w = new_float(Encoder.BLKSIZE / 2);\n}\n\nexport { ATH };\n","/*\n *  ReplayGainAnalysis - analyzes input samples and give the recommended dB change\n *  Copyright (C) 2001 David Robinson and Glen Sawyer\n *  Improvements and optimizations added by Frank Klemm, and by Marcel Muller \n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  concept and filter values by David Robinson (David@Robinson.org)\n *    -- blame him if you think the idea is flawed\n *  original coding by Glen Sawyer (mp3gain@hotmail.com)\n *    -- blame him if you think this runs too slowly, or the coding is otherwise flawed\n *\n *  lots of code improvements by Frank Klemm ( http://www.uni-jena.de/~pfk/mpp/ )\n *    -- credit him for all the _good_ programming ;)\n *\n *\n *  For an explanation of the concepts and the basic algorithms involved, go to:\n *    http://www.replaygain.org/\n */\n\n/*\n *  Here's the deal. Call\n *\n *    InitGainAnalysis ( long samplefreq );\n *\n *  to initialize everything. Call\n *\n *    AnalyzeSamples ( var Float_t*  left_samples,\n *                     var Float_t*  right_samples,\n *                     size_t          num_samples,\n *                     int             num_channels );\n *\n *  as many times as you want, with as many or as few samples as you want.\n *  If mono, pass the sample buffer in through left_samples, leave\n *  right_samples NULL, and make sure num_channels = 1.\n *\n *    GetTitleGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  SINCE THE LAST TIME you called GetTitleGain() OR InitGainAnalysis().\n *\n *    GetAlbumGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  since InitGainAnalysis() was called and finalized with GetTitleGain().\n *\n *  Pseudo-code to process an album:\n *\n *    Float_t       l_samples [4096];\n *    Float_t       r_samples [4096];\n *    size_t        num_samples;\n *    unsigned int  num_songs;\n *    unsigned int  i;\n *\n *    InitGainAnalysis ( 44100 );\n *    for ( i = 1; i <= num_songs; i++ ) {\n *        while ( ( num_samples = getSongSamples ( song[i], left_samples, right_samples ) ) > 0 )\n *            AnalyzeSamples ( left_samples, right_samples, num_samples, 2 );\n *        fprintf (\"Recommended dB change for song %2d: %+6.2 dB\\n\", i, GetTitleGain() );\n *    }\n *    fprintf (\"Recommended dB change for whole album: %+6.2 dB\\n\", GetAlbumGain() );\n */\n\n/*\n *  So here's the main source of potential code confusion:\n *\n *  The filters applied to the incoming samples are IIR filters,\n *  meaning they rely on up to <filter order> number of previous samples\n *  AND up to <filter order> number of previous filtered samples.\n *\n *  I set up the AnalyzeSamples routine to minimize memory usage and interface\n *  complexity. The speed isn't compromised too much (I don't think), but the\n *  internal complexity is higher than it should be for such a relatively\n *  simple routine.\n *\n *  Optimization/clarity suggestions are welcome.\n */\nimport * as common from './common.js';\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * Table entries per dB\n */\nGainAnalysis.STEPS_per_dB = 100.;\n/**\n * Table entries for 0...MAX_dB (normal max. values are 70...80 dB)\n */\nGainAnalysis.MAX_dB = 120.;\nGainAnalysis.GAIN_NOT_ENOUGH_SAMPLES = -24601;\nGainAnalysis.GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.GAIN_ANALYSIS_OK = 1;\nGainAnalysis.INIT_GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.INIT_GAIN_ANALYSIS_OK = 1;\n\nGainAnalysis.YULE_ORDER = 10;\nGainAnalysis.MAX_ORDER = GainAnalysis.YULE_ORDER;\n\nGainAnalysis.MAX_SAMP_FREQ = 48000;\nGainAnalysis.RMS_WINDOW_TIME_NUMERATOR = 1;\nGainAnalysis.RMS_WINDOW_TIME_DENOMINATOR = 20;\nGainAnalysis.MAX_SAMPLES_PER_WINDOW = ((GainAnalysis.MAX_SAMP_FREQ * GainAnalysis.RMS_WINDOW_TIME_NUMERATOR) / GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR + 1);\n\nfunction GainAnalysis() {\n    /**\n     * calibration value for 89dB\n     */\n    var PINK_REF = 64.82;\n\n    var YULE_ORDER = GainAnalysis.YULE_ORDER;\n    /**\n     * percentile which is louder than the proposed level\n     */\n    var RMS_PERCENTILE = 0.95;\n    /**\n     * maximum allowed sample frequency [Hz]\n     */\n    var MAX_SAMP_FREQ = GainAnalysis.MAX_SAMP_FREQ;\n    var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis.RMS_WINDOW_TIME_NUMERATOR;\n    /**\n     * numerator / denominator = time slice size [s]\n     */\n    var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR;\n    /**\n     * max. Samples per Time slice\n     */\n    var MAX_SAMPLES_PER_WINDOW = GainAnalysis.MAX_SAMPLES_PER_WINDOW;\n\n\n    var ABYule = [\n        [0.03857599435200, -3.84664617118067, -0.02160367184185,\n            7.81501653005538, -0.00123395316851, -11.34170355132042,\n            -0.00009291677959, 13.05504219327545, -0.01655260341619,\n            -12.28759895145294, 0.02161526843274, 9.48293806319790,\n            -0.02074045215285, -5.87257861775999, 0.00594298065125,\n            2.75465861874613, 0.00306428023191, -0.86984376593551,\n            0.00012025322027, 0.13919314567432, 0.00288463683916],\n        [0.05418656406430, -3.47845948550071, -0.02911007808948,\n            6.36317777566148, -0.00848709379851, -8.54751527471874,\n            -0.00851165645469, 9.47693607801280, -0.00834990904936,\n            -8.81498681370155, 0.02245293253339, 6.85401540936998,\n            -0.02596338512915, -4.39470996079559, 0.01624864962975,\n            2.19611684890774, -0.00240879051584, -0.75104302451432,\n            0.00674613682247, 0.13149317958808, -0.00187763777362],\n        [0.15457299681924, -2.37898834973084, -0.09331049056315,\n            2.84868151156327, -0.06247880153653, -2.64577170229825,\n            0.02163541888798, 2.23697657451713, -0.05588393329856,\n            -1.67148153367602, 0.04781476674921, 1.00595954808547,\n            0.00222312597743, -0.45953458054983, 0.03174092540049,\n            0.16378164858596, -0.01390589421898, -0.05032077717131,\n            0.00651420667831, 0.02347897407020, -0.00881362733839],\n        [0.30296907319327, -1.61273165137247, -0.22613988682123,\n            1.07977492259970, -0.08587323730772, -0.25656257754070,\n            0.03282930172664, -0.16276719120440, -0.00915702933434,\n            -0.22638893773906, -0.02364141202522, 0.39120800788284,\n            -0.00584456039913, -0.22138138954925, 0.06276101321749,\n            0.04500235387352, -0.00000828086748, 0.02005851806501,\n            0.00205861885564, 0.00302439095741, -0.02950134983287],\n        [0.33642304856132, -1.49858979367799, -0.25572241425570,\n            0.87350271418188, -0.11828570177555, 0.12205022308084,\n            0.11921148675203, -0.80774944671438, -0.07834489609479,\n            0.47854794562326, -0.00469977914380, -0.12453458140019,\n            -0.00589500224440, -0.04067510197014, 0.05724228140351,\n            0.08333755284107, 0.00832043980773, -0.04237348025746,\n            -0.01635381384540, 0.02977207319925, -0.01760176568150],\n        [0.44915256608450, -0.62820619233671, -0.14351757464547,\n            0.29661783706366, -0.22784394429749, -0.37256372942400,\n            -0.01419140100551, 0.00213767857124, 0.04078262797139,\n            -0.42029820170918, -0.12398163381748, 0.22199650564824,\n            0.04097565135648, 0.00613424350682, 0.10478503600251,\n            0.06747620744683, -0.01863887810927, 0.05784820375801,\n            -0.03193428438915, 0.03222754072173, 0.00541907748707],\n        [0.56619470757641, -1.04800335126349, -0.75464456939302,\n            0.29156311971249, 0.16242137742230, -0.26806001042947,\n            0.16744243493672, 0.00819999645858, -0.18901604199609,\n            0.45054734505008, 0.30931782841830, -0.33032403314006,\n            -0.27562961986224, 0.06739368333110, 0.00647310677246,\n            -0.04784254229033, 0.08647503780351, 0.01639907836189,\n            -0.03788984554840, 0.01807364323573, -0.00588215443421],\n        [0.58100494960553, -0.51035327095184, -0.53174909058578,\n            -0.31863563325245, -0.14289799034253, -0.20256413484477,\n            0.17520704835522, 0.14728154134330, 0.02377945217615,\n            0.38952639978999, 0.15558449135573, -0.23313271880868,\n            -0.25344790059353, -0.05246019024463, 0.01628462406333,\n            -0.02505961724053, 0.06920467763959, 0.02442357316099,\n            -0.03721611395801, 0.01818801111503, -0.00749618797172],\n        [0.53648789255105, -0.25049871956020, -0.42163034350696,\n            -0.43193942311114, -0.00275953611929, -0.03424681017675,\n            0.04267842219415, -0.04678328784242, -0.10214864179676,\n            0.26408300200955, 0.14590772289388, 0.15113130533216,\n            -0.02459864859345, -0.17556493366449, -0.11202315195388,\n            -0.18823009262115, -0.04060034127000, 0.05477720428674,\n            0.04788665548180, 0.04704409688120, -0.02217936801134]];\n\n    var ABButter = [\n        [0.98621192462708, -1.97223372919527, -1.97242384925416,\n            0.97261396931306, 0.98621192462708],\n        [0.98500175787242, -1.96977855582618, -1.97000351574484,\n            0.97022847566350, 0.98500175787242],\n        [0.97938932735214, -1.95835380975398, -1.95877865470428,\n            0.95920349965459, 0.97938932735214],\n        [0.97531843204928, -1.95002759149878, -1.95063686409857,\n            0.95124613669835, 0.97531843204928],\n        [0.97316523498161, -1.94561023566527, -1.94633046996323,\n            0.94705070426118, 0.97316523498161],\n        [0.96454515552826, -1.92783286977036, -1.92909031105652,\n            0.93034775234268, 0.96454515552826],\n        [0.96009142950541, -1.91858953033784, -1.92018285901082,\n            0.92177618768381, 0.96009142950541],\n        [0.95856916599601, -1.91542108074780, -1.91713833199203,\n            0.91885558323625, 0.95856916599601],\n        [0.94597685600279, -1.88903307939452, -1.89195371200558,\n            0.89487434461664, 0.94597685600279]];\n\n\n    /**\n     * When calling this procedure, make sure that ip[-order] and op[-order]\n     * point to real data\n     */\n    //private void filterYule(final float[] input, int inputPos, float[] output,\n    //int outputPos, int nSamples, final float[] kernel) {\n    function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            /* 1e-10 is a hack to avoid slowdown because of denormals */\n            output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4] - output[outputPos - 3]\n                * kernel[5] + input[inputPos - 3] * kernel[6]\n                - output[outputPos - 4] * kernel[7] + input[inputPos - 4]\n                * kernel[8] - output[outputPos - 5] * kernel[9]\n                + input[inputPos - 5] * kernel[10] - output[outputPos - 6]\n                * kernel[11] + input[inputPos - 6] * kernel[12]\n                - output[outputPos - 7] * kernel[13] + input[inputPos - 7]\n                * kernel[14] - output[outputPos - 8] * kernel[15]\n                + input[inputPos - 8] * kernel[16] - output[outputPos - 9]\n                * kernel[17] + input[inputPos - 9] * kernel[18]\n                - output[outputPos - 10] * kernel[19]\n                + input[inputPos - 10] * kernel[20];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n//private void filterButter(final float[] input, int inputPos,\n//    float[] output, int outputPos, int nSamples, final float[] kernel) {\n    function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            output[outputPos] = input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n    /**\n     * @return INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if\n     *         not\n     */\n    function ResetSampleFrequency(rgData, samplefreq) {\n        /* zero out initial values */\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        switch (0 | (samplefreq)) {\n            case 48000:\n                rgData.reqindex = 0;\n                break;\n            case 44100:\n                rgData.reqindex = 1;\n                break;\n            case 32000:\n                rgData.reqindex = 2;\n                break;\n            case 24000:\n                rgData.reqindex = 3;\n                break;\n            case 22050:\n                rgData.reqindex = 4;\n                break;\n            case 16000:\n                rgData.reqindex = 5;\n                break;\n            case 12000:\n                rgData.reqindex = 6;\n                break;\n            case 11025:\n                rgData.reqindex = 7;\n                break;\n            case 8000:\n                rgData.reqindex = 8;\n                break;\n            default:\n                return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.sampleWindow = 0 | ((samplefreq * RMS_WINDOW_TIME_NUMERATOR\n            + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR);\n\n        rgData.lsum = 0.;\n        rgData.rsum = 0.;\n        rgData.totsamp = 0;\n\n        Arrays.ill(rgData.A, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    }\n\n    this.InitGainAnalysis = function (rgData, samplefreq) {\n        if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {\n            return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.linpre = MAX_ORDER;\n        rgData.rinpre = MAX_ORDER;\n        rgData.lstep = MAX_ORDER;\n        rgData.rstep = MAX_ORDER;\n        rgData.lout = MAX_ORDER;\n        rgData.rout = MAX_ORDER;\n\n        Arrays.fill(rgData.B, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    };\n\n    /**\n     * square\n     */\n    function fsqr(d) {\n        return d * d;\n    }\n\n    this.AnalyzeSamples = function (rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples,\n                                    num_channels) {\n        var curleft;\n        var curleftBase;\n        var curright;\n        var currightBase;\n        var batchsamples;\n        var cursamples;\n        var cursamplepos;\n\n        if (num_samples == 0)\n            return GAIN_ANALYSIS_OK;\n\n        cursamplepos = 0;\n        batchsamples = num_samples;\n\n        switch (num_channels) {\n            case 1:\n                right_samples = left_samples;\n                right_samplesPos = left_samplesPos;\n                break;\n            case 2:\n                break;\n            default:\n                return GAIN_ANALYSIS_ERROR;\n        }\n\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, MAX_ORDER);\n        }\n\n        while (batchsamples > 0) {\n            cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow\n            - rgData.totsamp\n                : batchsamples;\n            if (cursamplepos < MAX_ORDER) {\n                curleft = rgData.linpre + cursamplepos;\n                curleftBase = rgData.linprebuf;\n                curright = rgData.rinpre + cursamplepos;\n                currightBase = rgData.rinprebuf;\n                if (cursamples > MAX_ORDER - cursamplepos)\n                    cursamples = MAX_ORDER - cursamplepos;\n            } else {\n                curleft = left_samplesPos + cursamplepos;\n                curleftBase = left_samples;\n                curright = right_samplesPos + cursamplepos;\n                currightBase = right_samples;\n            }\n\n            filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n            filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n\n            filterButter(rgData.lstepbuf, rgData.lstep + rgData.totsamp,\n                rgData.loutbuf, rgData.lout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n            filterButter(rgData.rstepbuf, rgData.rstep + rgData.totsamp,\n                rgData.routbuf, rgData.rout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n\n            curleft = rgData.lout + rgData.totsamp;\n            /* Get the squared values */\n            curleftBase = rgData.loutbuf;\n            curright = rgData.rout + rgData.totsamp;\n            currightBase = rgData.routbuf;\n\n            var i = cursamples % 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft++]);\n                rgData.rsum += fsqr(currightBase[curright++]);\n            }\n            i = cursamples / 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft + 0])\n                    + fsqr(curleftBase[curleft + 1])\n                    + fsqr(curleftBase[curleft + 2])\n                    + fsqr(curleftBase[curleft + 3])\n                    + fsqr(curleftBase[curleft + 4])\n                    + fsqr(curleftBase[curleft + 5])\n                    + fsqr(curleftBase[curleft + 6])\n                    + fsqr(curleftBase[curleft + 7]);\n                curleft += 8;\n                rgData.rsum += fsqr(currightBase[curright + 0])\n                    + fsqr(currightBase[curright + 1])\n                    + fsqr(currightBase[curright + 2])\n                    + fsqr(currightBase[curright + 3])\n                    + fsqr(currightBase[curright + 4])\n                    + fsqr(currightBase[curright + 5])\n                    + fsqr(currightBase[curright + 6])\n                    + fsqr(currightBase[curright + 7]);\n                curright += 8;\n            }\n\n            batchsamples -= cursamples;\n            cursamplepos += cursamples;\n            rgData.totsamp += cursamples;\n            if (rgData.totsamp == rgData.sampleWindow) {\n                /* Get the Root Mean Square (RMS) for this set of samples */\n                var val = GainAnalysis.STEPS_per_dB\n                    * 10.\n                    * Math.log10((rgData.lsum + rgData.rsum)\n                        / rgData.totsamp * 0.5 + 1.e-37);\n                var ival = (val <= 0) ? 0 : 0 | val;\n                if (ival >= rgData.A.length)\n                    ival = rgData.A.length - 1;\n                rgData.A[ival]++;\n                rgData.lsum = rgData.rsum = 0.;\n\n                System.arraycopy(rgData.loutbuf, rgData.totsamp,\n                    rgData.loutbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.routbuf, rgData.totsamp,\n                    rgData.routbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.lstepbuf, rgData.totsamp,\n                    rgData.lstepbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.rstepbuf, rgData.totsamp,\n                    rgData.rstepbuf, 0, MAX_ORDER);\n                rgData.totsamp = 0;\n            }\n            if (rgData.totsamp > rgData.sampleWindow) {\n                /*\n                 * somehow I really screwed up: Error in programming! Contact\n                 * author about totsamp > sampleWindow\n                 */\n                return GAIN_ANALYSIS_ERROR;\n            }\n        }\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(rgData.linprebuf, num_samples, rgData.linprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(rgData.rinprebuf, num_samples, rgData.rinprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER - num_samples, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER - num_samples, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos + num_samples\n                - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos + num_samples\n                - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);\n        }\n\n        return GAIN_ANALYSIS_OK;\n    };\n\n    function analyzeResult(Array, len) {\n        var i;\n\n        var elems = 0;\n        for (i = 0; i < len; i++)\n            elems += Array[i];\n        if (elems == 0)\n            return GAIN_NOT_ENOUGH_SAMPLES;\n\n        var upper = 0 | Math.ceil(elems * (1. - RMS_PERCENTILE));\n        for (i = len; i-- > 0;) {\n            if ((upper -= Array[i]) <= 0)\n                break;\n        }\n\n        //return (float) ((float) PINK_REF - (float) i / (float) STEPS_per_dB);\n        return (PINK_REF - i / GainAnalysis.STEPS_per_dB);\n    }\n\n    this.GetTitleGain = function (rgData) {\n        var retval = analyzeResult(rgData.A, rgData.A.length);\n\n        for (var i = 0; i < rgData.A.length; i++) {\n            rgData.B[i] += rgData.A[i];\n            rgData.A[i] = 0;\n        }\n\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        rgData.totsamp = 0;\n        rgData.lsum = rgData.rsum = 0.;\n        return retval;\n    }\n\n}\n\nexport { GainAnalysis }","/**\n * @fileoverview Data structure for ReplayGain analysis state.\n * Ported from gain_analysis.h/c. Stores buffers and running sums for\n * calculating ReplayGain values.\n * Uses ES Module syntax.\n *\n * @module ReplayGain\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { GainAnalysis } from './GainAnalysis.js'; // Assuming GainAnalysis exports constants\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used\n    // VbrMode, // Not used\n    // Float, // Not used\n    // ShortBlock, // Not used\n    // Util, // Not used\n    // Arrays, // Not used\n    // new_array_n, // Used indirectly\n    // new_byte, // Not used\n    // new_double, // Not used\n    new_float,\n    // new_float_n, // Not used\n    new_int,\n    // new_int_n, // Not used directly\n    // assert // Not used\n} = common;\n\n\n/**\n * @classdesc Holds the state variables and buffers required for performing\n * ReplayGain analysis during MP3 encoding or analysis. This includes\n * input buffers with pre-padding for filters, intermediate filter results,\n * windowing information, and running sums for RMS calculations.\n * @constructs ReplayGain\n */\nclass ReplayGain {\n    /**\n     * Pre-buffer for left channel input samples, used by filters.\n     * Size: `GainAnalysis.MAX_ORDER * 2`\n     * @public\n     * @type {Float32Array}\n     */\n    linprebuf;\n    /**\n     * Current write index within `linprebuf`.\n     * @public\n     * @type {number}\n     */\n    linpre = 0;\n\n    /**\n     * Buffer for left channel samples after the first filter stage.\n     * Size: `GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER`\n     * @public\n     * @type {Float32Array}\n     */\n    lstepbuf;\n    /**\n     * Current write index within `lstepbuf`.\n     * @public\n     * @type {number}\n     */\n    lstep = 0;\n\n    /**\n     * Buffer for left channel samples after the second filter stage (\"out\").\n     * Size: `GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER`\n     * @public\n     * @type {Float32Array}\n     */\n    loutbuf;\n    /**\n     * Current write index within `loutbuf`.\n     * @public\n     * @type {number}\n     */\n    lout = 0;\n\n    /**\n     * Pre-buffer for right channel input samples, used by filters.\n     * Size: `GainAnalysis.MAX_ORDER * 2`\n     * @public\n     * @type {Float32Array}\n     */\n    rinprebuf;\n    /**\n     * Current write index within `rinprebuf`.\n     * @public\n     * @type {number}\n     */\n    rinpre = 0;\n\n    /**\n     * Buffer for right channel samples after the first filter stage.\n     * Size: `GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER`\n     * @public\n     * @type {Float32Array}\n     */\n    rstepbuf;\n    /**\n     * Current write index within `rstepbuf`.\n     * @public\n     * @type {number}\n     */\n    rstep = 0;\n\n    /**\n     * Buffer for right channel samples after the second filter stage (\"out\").\n     * Size: `GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER`\n     * @public\n     * @type {Float32Array}\n     */\n    routbuf;\n    /**\n     * Current write index within `routbuf`.\n     * @public\n     * @type {number}\n     */\n    rout = 0;\n\n    /**\n     * Number of samples required for the RMS window duration (e.g., 50ms).\n     * Calculated based on sample rate.\n     * @public\n     * @type {number}\n     */\n    sampleWindow = 0;\n\n    /**\n     * Total number of samples processed so far.\n     * @public\n     * @type {number}\n     */\n    totsamp = 0;\n\n    /**\n     * Running sum of squared samples for the left channel within the current window.\n     * @public\n     * @type {number}\n     */\n    lsum = 0.0;\n\n    /**\n     * Running sum of squared samples for the right channel within the current window.\n     * @public\n     * @type {number}\n     */\n    rsum = 0.0;\n\n    /**\n     * Index indicating the current frequency weighting step (related to K-weighting).\n     * @public\n     * @type {number}\n     */\n    freqindex = 0;\n\n    /**\n     * Flag indicating if this is the first block being processed (used for filter initialization).\n     * @public\n     * @type {number} // Typically 0 or 1\n     */\n    first = 0;\n\n    /**\n     * Histogram A for loudness distribution analysis.\n     * Size determined by `GainAnalysis.STEPS_per_dB * GainAnalysis.MAX_dB`.\n     * @public\n     * @type {Int32Array}\n     */\n    A;\n\n    /**\n     * Histogram B for loudness distribution analysis.\n     * Size determined by `GainAnalysis.STEPS_per_dB * GainAnalysis.MAX_dB`.\n     * @public\n     * @type {Int32Array}\n     */\n    B;\n\n    constructor() {\n        // Initialize arrays\n        this.linprebuf = new_float(GainAnalysis.MAX_ORDER * 2);\n        this.lstepbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n        this.loutbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n        this.rinprebuf = new_float(GainAnalysis.MAX_ORDER * 2);\n        this.rstepbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n        this.routbuf = new_float(GainAnalysis.MAX_SAMPLES_PER_WINDOW + GainAnalysis.MAX_ORDER);\n\n        // Ensure histogram arrays have non-zero size if constants are zero initially\n        const histogramSize = Math.max(1, Math.floor(GainAnalysis.STEPS_per_dB * GainAnalysis.MAX_dB));\n        this.A = new_int(histogramSize);\n        this.B = new_int(histogramSize);\n\n        // Other properties are initialized to defaults (0 or 0.0) by class field initializers\n    }\n}\n\nexport { ReplayGain };\n// export default ReplayG","/**\n * @fileoverview CBR (Constant BitRate) iteration loop implementation for LAME.\n * This module handles the quantization process specifically for CBR encoding,\n * aiming to meet the target bitrate for each frame.\n * Uses ES Module syntax.\n *\n * @module CBRNewIterationLoop\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { MeanBits } from './MeanBits.js';\nimport { Encoder } from './Encoder.js';\nimport { L3Side } from './L3Side.js';\nimport { LameInternalFlags } from './LameInternalFlags.js';\n// Assuming these types are defined elsewhere and imported if needed for full type safety\n/** @typedef {import('./Quantize.js').Quantize} Quantize */\n/** @typedef {import('./LameGlobalFlags.js').LameGlobalFlags} LameGlobalFlags */\n/** @typedef {import('./Reservoir.js').Reservoir} Reservoir */ // Accessed via quantize.rv\n/** @typedef {import('./QuantizePVT.js').QuantizePVT} QuantizePVT */ // Accessed via quantize.qupvt\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used\n    // VbrMode, // Not used directly, but present in common\n    // Float, // Not used\n    ShortBlock, // Not used directly, but present in common\n    // Util, // Not used\n    // Arrays, // Not used\n    // new_array_n, // Used indirectly\n    // new_byte, // Not used\n    // new_double, // Not used\n    new_float,\n    // new_float_n, // Not used\n    new_int,\n    // new_int_n, // Not used\n    assert\n} = common;\n\n/**\n * @classdesc Implements the iteration loop for Constant BitRate (CBR) encoding.\n * This loop adjusts quantization parameters for each granule to meet the\n * target bitrate determined by the reservoir and psychoacoustic model.\n * @constructs CBRNewIterationLoop\n * @param {Quantize} _quantize - An instance of the main Quantize class.\n */\nclass CBRNewIterationLoop {\n    /**\n     * @private\n     * @type {Quantize}\n     */\n    quantize;\n\n    /**\n     * @param {Quantize} _quantize - An instance of the main Quantize class.\n     */\n    constructor(_quantize) {\n        /** @public */ // Make accessible for JSDoc link? Or keep private? Let's assume internal usage mostly.\n        this.quantize = _quantize;\n    }\n\n    /**\n     * Executes the CBR iteration loop for a frame.\n     * Determines target bits per granule/channel based on the bit reservoir,\n     * performs psychoacoustic analysis (`calc_xmin`), runs the quantization\n     * outer loop (`outer_loop`), and finalizes reservoir calculations.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags and settings.\n     * @param {Array<Float32Array>} pe - Perceptual entropy per granule/channel `[gr][ch]`.\n     * @param {Float32Array} ms_ener_ratio - Mid/Side energy ratio per granule `[gr]`.\n     * @param {Array<Array<object>>} ratio - Masking ratio info per granule/channel `[gr][ch]`.\n     */\n    iteration_loop(gfp, pe, ms_ener_ratio, ratio) {\n        const gfc = gfp.internal_flags;\n        const l3_xmin = new_float(L3Side.SFBMAX); // Allowed noise buffer\n        const xrpow = new_float(576); // Spectral energy buffer\n        const targ_bits = new_int(2); // Target bits per channel for a granule\n        let mean_bits = 0; // Average bits available from reservoir\n        let max_bits; // Max bits allowed for a granule\n        const l3_side = gfc.l3_side;\n\n        // Get mean bits available from reservoir for this frame\n        const mb = new MeanBits(mean_bits);\n        this.quantize.rv.ResvFrameBegin(gfp, mb);\n        mean_bits = mb.bits;\n\n        // Process each granule in the frame\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n\n            // Calculate needed bits per channel based on PE and reservoir state\n            max_bits = this.quantize.qupvt.on_pe(gfp, pe, targ_bits, mean_bits, gr, gr); // Pass gr as cbr flag? Check C code. Assume yes.\n\n            // Handle Mid/Side stereo processing\n            if (gfc.mode_ext === Encoder.MPG_MD_MS_LR) { // Using mode_ext check\n                this.quantize.ms_convert(gfc.l3_side, gr); // Convert L/R to M/S\n                this.quantize.qupvt.reduce_side(targ_bits, ms_ener_ratio[gr], mean_bits, max_bits); // Adjust M/S target bits\n            }\n\n            // Process each channel within the granule\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                let adjust, masking_lower_db;\n                const cod_info = l3_side.tt[gr][ch];\n\n                // Set masking adjustment based on block type (simplified for CBR?)\n                if (cod_info.block_type !== Encoder.SHORT_TYPE) { // Long block types\n                    adjust = 0; // CBR adjustment factor? Usually 0?\n                    masking_lower_db = gfc.PSY.mask_adjust - adjust;\n                } else { // Short blocks\n                    adjust = 0;\n                    masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n                }\n                gfc.masking_lower = Math.pow(10.0, masking_lower_db * 0.1);\n\n                // Initialize granule info for outer loop\n                this.quantize.init_outer_loop(gfc, cod_info);\n\n                // Check if there's energy to encode and initialize xrpow\n                if (this.quantize.init_xrpow(gfc, cod_info, xrpow)) {\n                    // Calculate allowed noise based on psychoacoustics\n                    this.quantize.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin);\n\n                    // Run the main quantization outer loop to find best scalefactors/gain\n                    this.quantize.outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, targ_bits[ch]);\n                }\n                // else: granule/channel is silent, init_xrpow already zeroed l3_enc\n\n                // Finalize quantization results for this granule/channel\n                this.quantize.iteration_finish_one(gfc, gr, ch);\n\n                // Assert that bit limits were respected\n                assert(cod_info.part2_3_length <= LameInternalFlags.MAX_BITS_PER_CHANNEL, `Channel ${ch} bits ${cod_info.part2_3_length} exceed MAX_BITS_PER_CHANNEL`);\n                // For CBR, the final bits *should* be <= target bits after reservoir adjustment\n                // assert(cod_info.part2_3_length <= targ_bits[ch], `Channel ${ch} bits ${cod_info.part2_3_length} exceed target ${targ_bits[ch]}`);\n                // Let's relax this assertion slightly, as the outer loop might slightly exceed targ_bits sometimes before reservoir corrects it.\n                 assert(cod_info.part2_3_length <= targ_bits[ch] + 100, `Channel ${ch} bits ${cod_info.part2_3_length} significantly exceed target ${targ_bits[ch]}`);\n\n            } /* for ch */\n        } /* for gr */\n\n        // Finalize reservoir calculations for the frame\n        this.quantize.rv.ResvFrameEnd(gfc, mean_bits);\n    }\n}\n\nexport { CBRNewIterationLoop };\nexport default CBRNewIterationLoop; // Also provide default export if needed","/**\n * @fileoverview Main LAME encoder class definition and initialization logic.\n * Ported from lame.c. Provides the top-level API for initializing the encoder,\n * setting parameters, and encoding audio frames.\n * Uses ES Module syntax.\n *\n * @module Lame\n */\n\n// Import necessary modules using ES Module syntax\nimport * as common from './common.js';\nimport { PsyModel } from './PsyModel.js';\nimport { LameGlobalFlags } from './LameGlobalFlags.js';\nimport { LameInternalFlags } from './LameInternalFlags.js';\nimport { ATH } from './ATH.js';\nimport { ReplayGain } from './ReplayGain.js';\nimport { CBRNewIterationLoop } from './CBRNewIterationLoop.js';\n// Comment out imports for non-existent classes\n// import VBROldIterationLoop from './VBROldIterationLoop.js'; // Assuming this exists\n// import ABRIterationLoop from './ABRIterationLoop.js';   // Assuming this exists\nimport { BitStream } from './BitStream.js';\nimport { bitrate_table } from './Tables.js';\nimport { Encoder } from './Encoder.js';\nimport { MPEGMode } from './MPEGMode.js';\n\n// Assuming these types are defined elsewhere and imported if needed for full type safety\n/** @typedef {import('./GainAnalysis.js').default} GainAnalysis */\n/** @typedef {import('./Presets.js').default} Presets */\n/** @typedef {import('./QuantizePVT.js').QuantizePVT} QuantizePVT */\n/** @typedef {import('./Quantize.js').Quantize} Quantize */\n/** @typedef {import('./VBRTag.js').default} VBRTag */\n/** @typedef {import('./Version.js').default} Version */\n/** @typedef {import('./ID3Tag.js').default} ID3Tag */\n/** @typedef {import('./MPGLib.js').default} MPGLib */ // Assuming MPGLib module exists\n/** @typedef {import('./Takehiro.js').default} Takehiro */ // Assuming Takehiro module exists\n\n// Destructure common utilities for easier access\nconst {\n    VbrMode,\n    Float,\n    ShortBlock,\n    Util,\n    Arrays, // Keep for potential fill/sort usage\n    new_array_n,\n    new_byte,\n    // new_double, // Not used\n    new_float,\n    new_float_n,\n    new_int,\n    new_int_n,\n    new_short_n,\n    assert\n    // System, // Remove System from destructuring\n} = common;\n\n// --- Internal Helper Classes (No JSDoc as requested) ---\n/** @private */\nclass _PSY { // Renamed to match usage\n    mask_adjust = 0.0;\n    mask_adjust_short = 0.0;\n    bo_l_weight = new_float(Encoder.SBMAX_l);\n    bo_s_weight = new_float(Encoder.SBMAX_s);\n}\n/** @private */\nclass _LowPassHighPass { lowerlimit = 0.0; };\n/** @private */\nclass _BandPass { constructor(bitrate, lPass) { this.lowpass = lPass;} };\n\n\n/**\n * @classdesc The main LAME MP3 encoder class. Provides methods to initialize\n * the encoder, set parameters, encode PCM data buffers, and finalize the MP3 stream.\n * @constructs Lame\n */\nclass Lame {\n    // --- Static Constants ---\n    static LAME_MAXALBUMART = (128 * 1024);\n    static V9 = 410; static V8 = 420; static V7 = 430; static V6 = 440; static V5 = 450;\n    static V4 = 460; static V3 = 470; static V2 = 480; static V1 = 490; static V0 = 500;\n    static R3MIX = 1000; static STANDARD = 1001; static EXTREME = 1002;\n    static INSANE = 1003; static STANDARD_FAST = 1004; static EXTREME_FAST = 1005;\n    static MEDIUM = 1006; static MEDIUM_FAST = 1007;\n    static LAME_MAXMP3BUFFER = (16384 + Lame.LAME_MAXALBUMART);\n    static BLACKSIZE = 32; // Maximum filter length + 1\n\n    /** @private @type {GainAnalysis|null} */\n    ga = null;\n    /** @private @type {BitStream|null} */\n    bs = null;\n    /** @private @type {Presets|null} */\n    p = null;\n    /** @private @type {QuantizePVT|null} */\n    qupvt = null;\n    /** @private @type {Quantize|null} */\n    qu = null;\n    /** @private @type {PsyModel} */\n    psy = new PsyModel();\n    /** @private @type {VBRTag|null} */\n    vbr = null;\n    /** @private @type {Version|null} */\n    ver = null;\n    /** @private @type {ID3Tag|null} */\n    id3 = null;\n    /** @private @type {MPGLib|null} */\n    mpglib = null;\n    /** @public @type {Encoder} Core encoder logic. */\n    enc = new Encoder();\n    /** @private Internal constant */\n    _LAME_ID = 0xFFF88E3B;\n\n    // Internal helper classes (defined outside or passed in)\n    /** @private */ _InOut = class InOut { constructor() { this.n_in = 0; this.n_out = 0; } };\n    /** @private */ _NumUsed = class NumUsed { constructor() { this.num_used = 0; } };\n\n\n    constructor() {\n        // Modules are set externally via setModules\n    }\n\n    /**\n     * Sets the internal module dependencies for the Lame instance.\n     * Must be called after instantiating Lame and its dependencies.\n     *\n     * @public\n     * @param {GainAnalysis} _ga - Gain Analysis module instance.\n     * @param {BitStream} _bs - BitStream module instance.\n     * @param {Presets} _p - Presets module instance.\n     * @param {QuantizePVT} _qupvt - QuantizePVT module instance.\n     * @param {Quantize} _qu - Quantize module instance.\n     * @param {VBRTag} _vbr - VBRTag module instance.\n     * @param {Version} _ver - Version module instance.\n     * @param {ID3Tag} _id3 - ID3Tag module instance.\n     * @param {MPGLib} _mpglib - MPGLib module instance.\n     */\n    setModules(_ga, _bs, _p, _qupvt, _qu, _vbr, _ver, _id3, _mpglib) {\n        this.ga = _ga;\n        this.bs = _bs;\n        this.p = _p;\n        this.qupvt = _qupvt;\n        this.qu = _qu;\n        this.vbr = _vbr;\n        this.ver = _ver;\n        this.id3 = _id3;\n        this.mpglib = _mpglib;\n        // Pass necessary modules down to Encoder\n        this.enc.setModules(this.bs, this.psy, this.qupvt, this.vbr);\n    }\n\n    // --- Internal Helper Methods (Private JSDoc omitted) ---\n    /** @private */\n    _lame_init_old(gfp) { /* ... (implementation as before) ... */\n        let gfc;\n        gfp.class_id = this._LAME_ID;\n        gfc = gfp.internal_flags = new LameInternalFlags();\n        gfp.mode = MPEGMode.NOT_SET; gfp.original = 1; gfp.in_samplerate = 44100;\n        gfp.num_channels = 2; gfp.num_samples = -1; gfp.bWriteVbrTag = true;\n        gfp.quality = -1; gfp.short_blocks = null; gfc.subblock_gain = -1;\n        gfp.lowpassfreq = 0; gfp.highpassfreq = 0; gfp.lowpasswidth = -1; gfp.highpasswidth = -1;\n        gfp.VBR = VbrMode.vbr_off; gfp.VBR_q = 4; gfp.ATHcurve = -1;\n        gfp.VBR_mean_bitrate_kbps = 128; gfp.VBR_min_bitrate_kbps = 0; gfp.VBR_max_bitrate_kbps = 0;\n        gfp.VBR_hard_min = 0; gfc.VBR_min_bitrate = 1; gfc.VBR_max_bitrate = 14;\n        gfp.quant_comp = -1; gfp.quant_comp_short = -1; gfp.msfix = -1.0;\n        gfc.resample_ratio = 1.0; gfc.OldValue[0] = 180; gfc.OldValue[1] = 180;\n        gfc.CurrentStep[0] = 4; gfc.CurrentStep[1] = 4; gfc.masking_lower = 1.0;\n        gfc.nsPsy.attackthre = -1; gfc.nsPsy.attackthre_s = -1; gfp.scale = -1.0;\n        gfp.athaa_type = -1; gfp.ATHtype = -1; gfp.athaa_loudapprox = -1;\n        gfp.athaa_sensitivity = 0.0; gfp.useTemporal = null; gfp.interChRatio = -1.0;\n        gfc.mf_samples_to_encode = Encoder.ENCDELAY + Encoder.POSTDELAY;\n        gfp.encoder_padding = 0; gfc.mf_size = Encoder.ENCDELAY - Encoder.MDCTDELAY;\n        gfp.findReplayGain = false; gfp.decode_on_the_fly = false;\n        gfc.decode_on_the_fly = false; gfc.findReplayGain = false; gfc.findPeakSample = false;\n        gfc.RadioGain = 0; gfc.AudiophileGain = 0; gfc.noclipGainChange = 0; gfc.noclipScale = -1.0;\n        gfp.preset = 0; gfp.write_id3tag_automatic = true;\n        return 0;\n     }\n    /** @private */\n    _filter_coef(x) { if (x > 1.0) return 0.0; if (x <= 0.0) return 1.0; return Math.cos(Math.PI / 2.0 * x); }\n    /** @private */\n    _nearestBitrateFullIndex(bitrate) { /* ... (implementation as before) ... */\n        const full_bitrate_table = [8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320];\n        let lower_range = 16, lower_range_kbps = 320; let upper_range = 16, upper_range_kbps = 320;\n        for (let b = 0; b < 16; b++) { if (full_bitrate_table[b + 1] >= bitrate) { upper_range_kbps = full_bitrate_table[b + 1]; upper_range = b + 1; lower_range_kbps = full_bitrate_table[b]; lower_range = b; break; } }\n        return ((upper_range_kbps - bitrate) > (bitrate - lower_range_kbps)) ? lower_range : upper_range;\n     }\n    /** @private */\n    _optimum_samplefreq(lowpassfreq, input_samplefreq) { /* ... (implementation as before) ... */\n        let suggested_samplefreq = 44100;\n        if (input_samplefreq >= 48000) suggested_samplefreq = 48000;\n        else if (input_samplefreq >= 44100) suggested_samplefreq = 44100;\n        else if (input_samplefreq >= 32000) suggested_samplefreq = 32000;\n        else if (input_samplefreq >= 24000) suggested_samplefreq = 24000;\n        else if (input_samplefreq >= 22050) suggested_samplefreq = 22050;\n        else if (input_samplefreq >= 16000) suggested_samplefreq = 16000;\n        else if (input_samplefreq >= 12000) suggested_samplefreq = 12000;\n        else if (input_samplefreq >= 11025) suggested_samplefreq = 11025;\n        else if (input_samplefreq >= 8000) suggested_samplefreq = 8000;\n        else suggested_samplefreq = 8000;\n        if (lowpassfreq === -1) return suggested_samplefreq;\n        if (lowpassfreq <= 3970) suggested_samplefreq = 8000;\n        else if (lowpassfreq <= 4510) suggested_samplefreq = 11025;\n        else if (lowpassfreq <= 5420) suggested_samplefreq = 12000;\n        else if (lowpassfreq <= 7230) suggested_samplefreq = 16000;\n        else if (lowpassfreq <= 9970) suggested_samplefreq = 22050;\n        else if (lowpassfreq <= 11220) suggested_samplefreq = 24000;\n        else if (lowpassfreq <= 15250) suggested_samplefreq = 32000;\n        else if (lowpassfreq <= 15960) suggested_samplefreq = 44100;\n        else suggested_samplefreq = 48000;\n        if (input_samplefreq > suggested_samplefreq) {\n            if (input_samplefreq > 44100) return 48000; if (input_samplefreq > 32000) return 44100;\n            if (input_samplefreq > 24000) return 32000; if (input_samplefreq > 22050) return 24000;\n            if (input_samplefreq > 16000) return 22050; if (input_samplefreq > 12000) return 16000;\n            if (input_samplefreq > 11025) return 12000; if (input_samplefreq > 8000) return 11025;\n            return 8000;\n        }\n        return suggested_samplefreq;\n    }\n    /** @private */\n    _SmpFrqIndex(sample_freq, gfp) { /* ... (implementation as before) ... */\n        switch (sample_freq) {\n            case 44100: gfp.version = 1; return 0; case 48000: gfp.version = 1; return 1; case 32000: gfp.version = 1; return 2;\n            case 22050: gfp.version = 0; return 0; case 24000: gfp.version = 0; return 1; case 16000: gfp.version = 0; return 2;\n            case 11025: gfp.version = 0; return 0; case 12000: gfp.version = 0; return 1; case 8000: gfp.version = 0; return 2;\n            default: gfp.version=0; return -1;\n        }\n     }\n    /** @private */\n    _FindNearestBitrate(bRate, version, samplerate) { /* ... (implementation as before) ... */\n        if (samplerate < 16000) version = 0; else if (samplerate < 32000) version = 0;\n        let nearest_bitrate = bitrate_table[version][1]; let min_diff = Math.abs(nearest_bitrate - bRate);\n        for (let i = 2; i <= 14; i++) { const current_rate = bitrate_table[version][i]; if (current_rate > 0) { const diff = Math.abs(current_rate - bRate); if (diff < min_diff) { min_diff = diff; nearest_bitrate = current_rate; } } }\n        return nearest_bitrate;\n    }\n    /** @private */\n    _BitrateIndex(bRate, version, samplerate) { /* ... (implementation as before) ... */\n        if (samplerate < 16000) version = 0; else if (samplerate < 32000) version = 0;\n        for (let i = 1; i <= 14; i++) { if (bitrate_table[version][i] === bRate) return i; } return -1;\n     }\n    /** @private */\n    _optimum_bandwidth(lh, bitrate) { /* ... (implementation as before) ... */\n         const freq_map = [ new this._BandPass(8, 2000), new this._BandPass(16, 3700), new this._BandPass(24, 3900), new this._BandPass(32, 5500), new this._BandPass(40, 7000), new this._BandPass(48, 7500), new this._BandPass(56, 10000), new this._BandPass(64, 11000), new this._BandPass(80, 13500), new this._BandPass(96, 15100), new this._BandPass(112, 15600), new this._BandPass(128, 17000), new this._BandPass(160, 17500), new this._BandPass(192, 18600), new this._BandPass(224, 19400), new this._BandPass(256, 19700), new this._BandPass(320, 20500) ];\n         const table_index = this._nearestBitrateFullIndex(bitrate); lh.lowerlimit = freq_map[table_index].lowpass;\n     }\n    /** @private */\n    _lame_init_params_ppflt(gfp) { /* ... (implementation as before) ... */\n        const gfc = gfp.internal_flags;\n        let lowpass_band = 32; let highpass_band = -1;\n        if (gfc.lowpass1 > 0) { let minband = 999; for (let band = 0; band <= 31; band++) { const freq = band / 31.0; if (freq >= gfc.lowpass2) lowpass_band = Math.min(lowpass_band, band); if (gfc.lowpass1 < freq && freq < gfc.lowpass2) minband = Math.min(minband, band); } gfc.lowpass1 = (minband === 999) ? (lowpass_band - 0.75) / 31.0 : (minband - 0.75) / 31.0; gfc.lowpass2 = lowpass_band / 31.0; }\n        if (gfc.highpass2 > 0) { if (gfc.highpass2 < 0.9 * (0.75 / 31.0)) { gfc.highpass1 = 0; gfc.highpass2 = 0; console.warn(\"Warning: highpass filter disabled. Frequency too small.\"); } }\n        if (gfc.highpass2 > 0) { let maxband = -1; for (let band = 0; band <= 31; band++) { const freq = band / 31.0; if (freq <= gfc.highpass1) highpass_band = Math.max(highpass_band, band); if (gfc.highpass1 < freq && freq < gfc.highpass2) maxband = Math.max(maxband, band); } gfc.highpass1 = highpass_band / 31.0; gfc.highpass2 = (maxband === -1) ? (highpass_band + 0.75) / 31.0 : (maxband + 0.75) / 31.0; }\n        for (let band = 0; band < 32; band++) { const freq = band / 31.0; const fc1 = (gfc.highpass2 > gfc.highpass1) ? this._filter_coef((gfc.highpass2 - freq) / (gfc.highpass2 - gfc.highpass1 + 1e-20)) : 1.0; const fc2 = (gfc.lowpass2 > gfc.lowpass1) ? this._filter_coef((freq - gfc.lowpass1) / (gfc.lowpass2 - gfc.lowpass1 + 1e-20)) : 1.0; gfc.amp_filter[band] = fc1 * fc2; }\n     }\n    /** @private */\n    _lame_init_qval(gfp) { /* ... (implementation as before) ... */\n        const gfc = gfp.internal_flags; const LAME_DEFAULT_QUALITY = 5;\n        if (gfp.quality < 0) gfp.quality = LAME_DEFAULT_QUALITY;\n        switch (gfp.quality) {\n            default: case 9: gfc.psymodel = 0; gfc.noise_shaping = 0; gfc.noise_shaping_amp = 0; gfc.noise_shaping_stop = 0; gfc.use_best_huffman = 0; gfc.full_outer_loop = 0; break;\n            case 8: gfp.quality = 7; // Fallthrough\n            case 7: gfc.psymodel = 1; gfc.noise_shaping = 0; gfc.noise_shaping_amp = 0; gfc.noise_shaping_stop = 0; gfc.use_best_huffman = 0; gfc.full_outer_loop = 0; break;\n            case 6: case 5: gfc.psymodel = 1; if (gfc.noise_shaping === 0) gfc.noise_shaping = 1; gfc.noise_shaping_amp = 0; gfc.noise_shaping_stop = 0; if (gfc.subblock_gain === -1) gfc.subblock_gain = 1; gfc.use_best_huffman = 0; gfc.full_outer_loop = 0; break;\n            case 4: gfc.psymodel = 1; if (gfc.noise_shaping === 0) gfc.noise_shaping = 1; gfc.noise_shaping_amp = 0; gfc.noise_shaping_stop = 0; if (gfc.subblock_gain === -1) gfc.subblock_gain = 1; gfc.use_best_huffman = 1; gfc.full_outer_loop = 0; break;\n            case 3: gfc.psymodel = 1; if (gfc.noise_shaping === 0) gfc.noise_shaping = 1; gfc.noise_shaping_amp = 1; gfc.noise_shaping_stop = 1; if (gfc.subblock_gain === -1) gfc.subblock_gain = 1; gfc.use_best_huffman = 1; gfc.full_outer_loop = 0; break;\n            case 2: gfc.psymodel = 1; if (gfc.noise_shaping === 0) gfc.noise_shaping = 1; if (gfc.substep_shaping === 0) gfc.substep_shaping = 2; gfc.noise_shaping_amp = 1; gfc.noise_shaping_stop = 1; if (gfc.subblock_gain === -1) gfc.subblock_gain = 1; gfc.use_best_huffman = 1; gfc.full_outer_loop = 0; break;\n            case 1: case 0: gfc.psymodel = 1; if (gfc.noise_shaping === 0) gfc.noise_shaping = 1; if (gfc.substep_shaping === 0) gfc.substep_shaping = 2; gfc.noise_shaping_amp = 2; gfc.noise_shaping_stop = 1; if (gfc.subblock_gain === -1) gfc.subblock_gain = 1; gfc.use_best_huffman = 1; gfc.full_outer_loop = 0; break;\n        }\n     }\n    /** @private */\n    _lame_init_bitstream(gfp) { /* ... (implementation as before) ... */\n        const gfc = gfp.internal_flags; gfp.frameNum = 0;\n        if (gfp.write_id3tag_automatic) { /* this.id3.id3tag_write_v2(gfp); */ console.warn(\"ID3v2 tag writing not implemented.\"); }\n        gfc.bitrate_stereoMode_Hist = new_int_n([16, 5]); gfc.bitrate_blockType_Hist = new_int_n([16, 6]);\n        gfc.PeakSample = 0.0;\n        if (gfp.bWriteVbrTag) { /* this.vbr.InitVbrTag(gfp); */ console.warn(\"VBR tag writing not implemented.\"); }\n     }\n    /** @private */\n    _calcNeeded(gfp) { /* ... (implementation as before) ... */\n        let mf_needed = Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET;\n        mf_needed = Math.max(mf_needed, 512 + gfp.framesize - 32);\n        assert(LameInternalFlags.MFSIZE >= mf_needed, `MFSIZE ${LameInternalFlags.MFSIZE} too small, need ${mf_needed}`);\n        return mf_needed;\n     }\n    /** @private */\n    _lame_encode_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) { /* ... (implementation as before) ... */\n        const ret = this.enc.lame_encode_mp3_frame(gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size);\n        gfp.frameNum++; return ret;\n     }\n    /** @private */\n    _fill_buffer_resample(gfp, outbuf, outbufPos, desired_len, inbuf, in_bufferPos, len, num_used, ch) {\n        const gfc = gfp.internal_flags;\n        let i, j = 0, k;\n        const bpc = Math.min(LameInternalFlags.BPC, gfp.out_samplerate / this._gcd(gfp.out_samplerate, gfp.in_samplerate));\n        const intratio = (Math.abs(gfc.resample_ratio - Math.round(gfc.resample_ratio)) < 0.0001) ? 1 : 0;\n        let fcn = 1.0 / gfc.resample_ratio;\n        if (fcn > 1.0) fcn = 1.0;\n        let filter_l = 31;\n        if (filter_l % 2 === 0) --filter_l;\n        filter_l += intratio;\n\n        if (gfc.fill_buffer_resample_init === 0) {\n            gfc.inbuf_old[0] = new_float(LameInternalFlags.INBUF_SIZE);\n            gfc.inbuf_old[1] = new_float(LameInternalFlags.INBUF_SIZE);\n            for (i = 0; i <= 2 * bpc; ++i) {\n                gfc.blackfilt[i] = new_float(Lame.BLACKSIZE);\n            }\n            gfc.itime[0] = 0;\n            gfc.itime[1] = 0;\n\n            for (j = 0; j <= 2 * bpc; j++) {\n                let sum = 0.0;\n                const offset = (j - bpc) / (2.0 * bpc);\n                for (i = 0; i <= filter_l; i++) {\n                    sum += gfc.blackfilt[j][i] = this._blackman(i - offset, fcn, filter_l);\n                }\n                if (sum !== 0) {\n                    for (i = 0; i <= filter_l; i++) {\n                        gfc.blackfilt[j][i] /= sum;\n                    }\n                }\n            }\n            gfc.fill_buffer_resample_init = 1;\n        }\n\n        const inbuf_old = gfc.inbuf_old[ch];\n        for (k = 0; k < desired_len; k++) {\n            const time0 = k * gfc.resample_ratio;\n            j = Math.floor(time0 - gfc.itime[ch]);\n            if ((filter_l + j - Math.floor(filter_l / 2)) >= len) break;\n\n            const offset = (time0 - gfc.itime[ch] - (j + 0.5 * (filter_l % 2)));\n            assert(Math.abs(offset) <= 0.501, `Resample offset error: ${offset}`);\n            const joff = Math.floor((offset * 2.0 * bpc) + bpc + 0.5);\n            assert(joff >= 0 && joff <= 2 * bpc, `joff out of bounds: ${joff}`);\n\n            let xvalue = 0.0;\n            for (i = 0; i <= filter_l; ++i) {\n                const j2 = Math.floor(i + j - filter_l / 2);\n                const y = (j2 < 0) ? inbuf_old[LameInternalFlags.INBUF_SIZE/2 + j2] : inbuf[in_bufferPos + j2];\n                xvalue += y * gfc.blackfilt[joff][i];\n            }\n            outbuf[outbufPos + k] = xvalue;\n        }\n\n        num_used.num_used = Math.min(len, Math.floor(filter_l + j - filter_l / 2));\n        if (num_used.num_used < 0) num_used.num_used = 0;\n\n        gfc.itime[ch] += num_used.num_used - k * gfc.resample_ratio;\n\n        if (num_used.num_used >= Lame.BLACKSIZE) {\n            for (i = 0; i < Lame.BLACKSIZE; i++) {\n                inbuf_old[i] = inbuf[in_bufferPos + num_used.num_used + i - Lame.BLACKSIZE];\n            }\n        } else {\n            const n_shift = Lame.BLACKSIZE - num_used.num_used;\n            for (i = 0; i < n_shift; ++i) {\n                inbuf_old[i] = inbuf_old[i + num_used.num_used];\n            }\n            for (j = 0; i < Lame.BLACKSIZE; ++i, ++j) {\n                inbuf_old[i] = inbuf[in_bufferPos + j];\n            }\n            assert(j === num_used.num_used, `Resample buffer fill mismatch: ${j} vs ${num_used.num_used}`);\n        }\n        return k;\n    }\n    /** @private */\n    _fill_buffer(gfp, mfbuf, in_buffer, in_bufferPos, nsamples, io) {\n        const gfc = gfp.internal_flags;\n        if (Math.abs(gfc.resample_ratio - 1.0) > 1e-6) {\n            // Resampling logic (assuming it handles buffer limits correctly internally)\n                for (let ch = 0; ch < gfc.channels_out; ch++) {\n                    let numUsed = new this._NumUsed();\n                    // Ensure we don't ask resampler to create more samples than fit\n                    const space_left_out = LameInternalFlags.MFSIZE - gfc.mf_size;\n                    const desired_len = Math.min(gfp.framesize, space_left_out); // Max output needed/possible\n                    if (desired_len <= 0) { // Should not happen if mf_size < mf_needed\n                    io.n_out = 0;\n                    io.n_in = 0;\n                    continue; // Skip channel if no space\n                    }\n                    io.n_out = this._fill_buffer_resample(gfp, mfbuf[ch], gfc.mf_size, desired_len, in_buffer[ch], in_bufferPos, nsamples, numUsed, ch);\n                    io.n_in = numUsed.num_used;\n                    // If stereo, assume n_in is the same for both, check n_out?\n                    // This simplified approach might need review for stereo resampling edge cases.\n                }\n        } else { // No resampling\n            // Determine samples to copy based on input, frame size, AND available buffer space\n            const space_left = LameInternalFlags.MFSIZE - gfc.mf_size;\n            io.n_out = Math.min(gfp.framesize, nsamples, space_left);\n            io.n_in = io.n_out; // Samples consumed = samples output\n\n            // Check if calculation resulted in negative/zero copy, which shouldn't happen if mf_size < mf_needed\n            if (io.n_out <= 0) {\n                io.n_in = 0; // Consume nothing if outputting nothing\n                return; // Nothing to copy\n            }\n\n            // Copy the calculated number of samples\n            for (let i = 0; i < io.n_out; ++i) {\n                    const dest_idx = gfc.mf_size + i;\n                    // Double check bounds just in case\n                    if (dest_idx >= LameInternalFlags.MFSIZE) {\n                        console.error(`Buffer overflow detected in _fill_buffer: index ${dest_idx} >= ${LameInternalFlags.MFSIZE}`);\n                        // Adjust n_out/n_in if an error occurs mid-loop? Unlikely with initial check.\n                        io.n_out = i; // Record how many were actually copied\n                        io.n_in = io.n_out;\n                        break;\n                    }\n                mfbuf[0][dest_idx] = in_buffer[0][in_bufferPos + i];\n                if (gfc.channels_out === 2) {\n                    mfbuf[1][dest_idx] = in_buffer[1][in_bufferPos + i];\n                }\n            }\n        }\n    }\n    /** @private */\n    _lame_encode_buffer_sample(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) { /* ... (implementation as before) ... */\n        const gfc = gfp.internal_flags; let mp3size = 0; let ret; let i; let ch; let mp3out; const mfbuf = [gfc.mfbuf[0], gfc.mfbuf[1]]; const in_buffer = [buffer_l, buffer_r];\n        if (gfc.Class_ID !== this._LAME_ID) return -3; if (nsamples === 0) return 0;\n        mp3out = this.bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 0); if (mp3out < 0) return mp3out; mp3bufPos += mp3out; mp3size += mp3out;\n        const mf_needed = this._calcNeeded(gfp); let in_bufferPos = 0;\n        while (nsamples > 0) { const io = new this._InOut(); this._fill_buffer(gfp, mfbuf, in_buffer, in_bufferPos, nsamples, io); const n_in = io.n_in; const n_out = io.n_out;\n            if (gfc.findReplayGain && !gfc.decode_on_the_fly) { if (this.ga.AnalyzeSamples(gfc.rgdata, mfbuf[0], gfc.mf_size, mfbuf[1], gfc.mf_size, n_out, gfc.channels_out) === GainAnalysis.GAIN_ANALYSIS_ERROR) return -6; }\n            nsamples -= n_in; in_bufferPos += n_in; gfc.mf_size += n_out; assert(gfc.mf_size <= LameInternalFlags.MFSIZE, \"mf_size overflow\");\n            if (gfc.mf_samples_to_encode < 1) gfc.mf_samples_to_encode = Encoder.ENCDELAY + Encoder.POSTDELAY; gfc.mf_samples_to_encode += n_out;\n            if (gfc.mf_size >= mf_needed) { const buf_size = (mp3buf_size === 0) ? 0 : mp3buf_size - mp3size; ret = this._lame_encode_frame(gfp, mfbuf[0], mfbuf[1], mp3buf, mp3bufPos, buf_size); if (ret < 0) return ret; mp3bufPos += ret; mp3size += ret;\n                gfc.mf_size -= gfp.framesize; gfc.mf_samples_to_encode -= gfp.framesize; for (ch = 0; ch < gfc.channels_out; ch++) {\n                    // Use subarray and set for efficient shifting\n                    mfbuf[ch].set(mfbuf[ch].subarray(gfp.framesize, gfc.mf_size + gfp.framesize));\n                 }\n            }\n        } assert(nsamples === 0, \"Not all input samples processed\"); return mp3size;\n     }\n\n\n    // --- Public API Methods ---\n\n    /**\n     * Initializes the LAME encoder global flags structure (`LameGlobalFlags`)\n     * with default values.\n     *\n     * @public\n     * @returns {LameGlobalFlags | null} A new LameGlobalFlags object with defaults set, or null on failure.\n     */\n    lame_init() {\n        const gfp = new LameGlobalFlags();\n        const ret = this._lame_init_old(gfp);\n        if (ret !== 0) return null;\n        gfp.lame_allocated_gfp = 1;\n        return gfp;\n    }\n\n    /**\n     * Initializes the internal encoder parameters based on the settings in the\n     * provided `LameGlobalFlags` structure. Must be called after `lame_init`\n     * and setting desired parameters, but before encoding.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - The configured LameGlobalFlags structure.\n     * @returns {number} 0 on success, negative error code on failure.\n     */\n    lame_init_params(gfp) {\n        if (!gfp || !gfp.internal_flags) { console.error(\"lame_init_params: lame_init() not called?\"); return -1; }\n        const gfc = gfp.internal_flags;\n\n        // --- Parameter Validation and Derivation ---\n        gfc.Class_ID = this._LAME_ID;\n        if (gfc.ATH == null) gfc.ATH = new ATH();\n        if (gfc.PSY == null) gfc.PSY = new _PSY(); // Use internal class _PSY\n        if (gfc.rgdata == null) gfc.rgdata = new ReplayGain();\n\n        // ...(Rest of lame_init_params implementation remains largely the same)...\n        gfc.channels_in = gfp.num_channels;\n        if (gfc.channels_in === 1) gfp.mode = MPEGMode.MONO;\n        gfc.channels_out = (gfp.mode === MPEGMode.MONO) ? 1 : 2;\n        gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        if (gfp.mode === MPEGMode.MONO) gfp.force_ms = false;\n        if (gfp.VBR === VbrMode.vbr_off && gfp.VBR_mean_bitrate_kbps !== 128 && gfp.brate === 0) gfp.brate = gfp.VBR_mean_bitrate_kbps;\n        if (gfp.VBR === VbrMode.vbr_off && gfp.brate === 0) { if (Math.abs(gfp.compression_ratio) < 1e-6) gfp.compression_ratio = 11.025; }\n        if (!(gfp.VBR === VbrMode.vbr_off || gfp.VBR === VbrMode.vbr_mtrh || gfp.VBR === VbrMode.vbr_mt)) gfp.free_format = false;\n        if (gfp.VBR === VbrMode.vbr_off && gfp.compression_ratio > 0) {\n             if (gfp.out_samplerate === 0) { if (gfp.out_samplerate === 0) gfp.out_samplerate = gfp.in_samplerate; }\n             gfp.brate = Math.floor(gfp.out_samplerate * 16 * gfc.channels_out / (1000.0 * gfp.compression_ratio));\n             this._SmpFrqIndex(gfp.out_samplerate, gfp);\n             if (!gfp.free_format) gfp.brate = this._FindNearestBitrate(gfp.brate, gfp.version, gfp.out_samplerate);\n        }\n        if (gfp.out_samplerate === 0) {\n             if (gfp.lowpassfreq === 0) {\n                 let lowpass = 16000.0;\n                 if (gfp.VBR === VbrMode.vbr_off || gfp.VBR === VbrMode.vbr_abr) { const lh = new _LowPassHighPass(); this._optimum_bandwidth(lh, gfp.VBR === VbrMode.vbr_off ? gfp.brate : gfp.VBR_mean_bitrate_kbps); lowpass = lh.lowerlimit; }\n                 else { const x = [19500, 19000, 18500, 18000, 17500, 16500, 15500, 14500, 12500, 9500, 3950]; if (0 <= gfp.VBR_q && gfp.VBR_q <= 9) { const a = x[gfp.VBR_q], b = x[gfp.VBR_q + 1], m = gfp.VBR_q_frac; lowpass = Util.linear_int(a, b, m); } else lowpass = 19500; }\n                 if (gfp.mode === MPEGMode.MONO && (gfp.VBR === VbrMode.vbr_off || gfp.VBR === VbrMode.vbr_abr)) lowpass *= 1.5;\n                 gfp.lowpassfreq = Math.floor(lowpass);\n             }\n             if (2 * gfp.lowpassfreq > gfp.in_samplerate) gfp.lowpassfreq = Math.floor(gfp.in_samplerate / 2);\n             gfp.out_samplerate = this._optimum_samplefreq(gfp.lowpassfreq, gfp.in_samplerate);\n        }\n        gfp.lowpassfreq = Math.min(20500, gfp.lowpassfreq); gfp.lowpassfreq = Math.min(Math.floor(gfp.out_samplerate / 2), gfp.lowpassfreq);\n        if (gfp.VBR === VbrMode.vbr_abr) gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1000.0 * gfp.VBR_mean_bitrate_kbps);\n        else if (gfp.VBR !== VbrMode.vbr_off) { const cmp = [5.7, 6.5, 7.3, 8.2, 10.0, 11.9, 13.0, 14.0, 15.0, 16.5]; gfp.compression_ratio = cmp[gfp.VBR_q] || 8.8; }\n        else { if (gfp.brate > 0) gfp.compression_ratio = gfp.out_samplerate * 16 * gfc.channels_out / (1000.0 * gfp.brate); }\n        gfc.findReplayGain = gfp.findReplayGain && gfp.bWriteVbrTag; gfc.decode_on_the_fly = gfp.decode_on_the_fly && gfp.bWriteVbrTag; gfc.findPeakSample = gfc.decode_on_the_fly;\n        if (gfc.findReplayGain) { if (this.ga.InitGainAnalysis(gfc.rgdata, gfp.out_samplerate) === GainAnalysis.GAIN_ANALYSIS_ERROR) return -6; }\n        if (gfc.decode_on_the_fly && !gfp.decode_only) { /* Initialize mpglib decoder */ console.warn(\"Decode on the fly not implemented.\"); }\n        gfc.mode_gr = (gfp.out_samplerate <= 24000 && gfp.version === 0) ? 1 : 2;\n        gfp.framesize = (gfp.version === 1 ? 1152 : (576 * gfc.mode_gr));\n        gfp.encoder_delay = Encoder.ENCDELAY;\n        gfc.resample_ratio = gfp.in_samplerate / gfp.out_samplerate;\n        if (gfp.mode === MPEGMode.NOT_SET) gfp.mode = MPEGMode.JOINT_STEREO;\n        // this._lame_init_params_ppflt(gfp); // Polyphase filter init\n        gfc.samplerate_index = this._SmpFrqIndex(gfp.out_samplerate, gfp); if (gfc.samplerate_index < 0) return -1;\n        if (gfp.VBR === VbrMode.vbr_off) { if (gfp.free_format) gfc.bitrate_index = 0; else { gfp.brate = this._FindNearestBitrate(gfp.brate, gfp.version, gfp.out_samplerate); gfc.bitrate_index = this._BitrateIndex(gfp.brate, gfp.version, gfp.out_samplerate); if (gfc.bitrate_index <= 0) return -1; } }\n        else { if(gfp.VBR === VbrMode.vbr_abr) { gfc.bitrate_index = this._BitrateIndex(this._FindNearestBitrate(gfp.VBR_mean_bitrate_kbps, gfp.version, gfp.out_samplerate), gfp.version, gfp.out_samplerate); if(gfc.bitrate_index <= 0) gfc.bitrate_index = 1; } else { gfc.bitrate_index = 1; } }\n        if (gfp.VBR !== VbrMode.vbr_off) {\n            gfc.VBR_min_bitrate = 1; gfc.VBR_max_bitrate = 14;\n            if (gfp.out_samplerate < 16000) gfc.VBR_max_bitrate = 8; else if (gfp.out_samplerate < 32000 && gfp.version === 0) gfc.VBR_max_bitrate = 14;\n            if (gfp.VBR_min_bitrate_kbps > 0) { gfp.VBR_min_bitrate_kbps = this._FindNearestBitrate(gfp.VBR_min_bitrate_kbps, gfp.version, gfp.out_samplerate); gfc.VBR_min_bitrate = this._BitrateIndex(gfp.VBR_min_bitrate_kbps, gfp.version, gfp.out_samplerate); if (gfc.VBR_min_bitrate < 0) return -1; }\n            if (gfp.VBR_max_bitrate_kbps > 0) { gfp.VBR_max_bitrate_kbps = this._FindNearestBitrate(gfp.VBR_max_bitrate_kbps, gfp.version, gfp.out_samplerate); gfc.VBR_max_bitrate = this._BitrateIndex(gfp.VBR_max_bitrate_kbps, gfp.version, gfp.out_samplerate); if (gfc.VBR_max_bitrate < 0) return -1; }\n            if (gfc.VBR_min_bitrate > gfc.VBR_max_bitrate) gfc.VBR_min_bitrate = gfc.VBR_max_bitrate;\n            gfp.VBR_min_bitrate_kbps = bitrate_table[gfp.version][gfc.VBR_min_bitrate]; gfp.VBR_max_bitrate_kbps = bitrate_table[gfp.version][gfc.VBR_max_bitrate];\n            if (gfp.VBR === VbrMode.vbr_abr) { gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_max_bitrate_kbps, gfp.VBR_mean_bitrate_kbps); gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_min_bitrate_kbps, gfp.VBR_mean_bitrate_kbps); }\n        }\n        let sfb_idx = gfc.samplerate_index + (3 * gfp.version); if (gfp.out_samplerate < 16000) sfb_idx += 6;\n        if (sfb_idx >= 0 && sfb_idx < this.qupvt.sfBandIndex.length) {\n            const sfb_info = this.qupvt.sfBandIndex[sfb_idx];\n            // Use subarray().set() for copying TypedArrays\n            gfc.scalefac_band.l.set(sfb_info.l.subarray(0, Encoder.SBMAX_l + 1));\n            gfc.scalefac_band.s.set(sfb_info.s.subarray(0, Encoder.SBMAX_s + 1));\n            let size_l = Math.floor((gfc.scalefac_band.l[22] - gfc.scalefac_band.l[21]) / Encoder.PSFB21); for (let i = 0; i < Encoder.PSFB21; i++) gfc.scalefac_band.psfb21[i] = gfc.scalefac_band.l[21] + i * size_l; gfc.scalefac_band.psfb21[Encoder.PSFB21] = gfc.scalefac_band.l[22];\n            let size_s = Math.floor((gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]) / Encoder.PSFB12); for (let i = 0; i < Encoder.PSFB12; i++) gfc.scalefac_band.psfb12[i] = gfc.scalefac_band.s[12] + i * size_s; gfc.scalefac_band.psfb12[Encoder.PSFB12] = gfc.scalefac_band.s[13];\n        } else { console.error(\"Invalid samplerate index for scalefactor bands.\"); return -1; }\n        if (gfp.version === 1) gfc.sideinfo_len = (gfc.channels_out === 1) ? 17 + 4 : 32 + 4; else gfc.sideinfo_len = (gfc.channels_out === 1) ? 9 + 4 : 17 + 4; if (gfp.error_protection) gfc.sideinfo_len += 2;\n        this.bs.init_bit_stream_w(gfc); this._lame_init_bitstream(gfp);\n        // --- Select Iteration Loop ---\n        switch (gfp.VBR) {\n            case VbrMode.vbr_mt: case VbrMode.vbr_mtrh: console.warn(`Using placeholder CBR loop for VBR mode: ${gfp.VBR}`); gfc.iteration_loop = new CBRNewIterationLoop(this.qu); break;\n            case VbrMode.vbr_rh: console.error(\"VBROldIterationLoop not implemented for VBR mode: vbr_rh\"); return -1;\n            case VbrMode.vbr_abr: console.error(\"ABRIterationLoop not implemented for VBR mode: vbr_abr\"); return -1;\n            case VbrMode.vbr_off: default: gfc.iteration_loop = new CBRNewIterationLoop(this.qu); break;\n        }\n        this.qupvt.iteration_init(gfp); this.psy.psymodel_init(gfp); this._lame_init_qval(gfp);\n        // --- Final Param Checks ---\n        if (gfp.scale < 0) gfp.scale = 1.0; if (gfp.scale_left < 0) gfp.scale_left = gfp.scale; if (gfp.scale_right < 0) gfp.scale_right = gfp.scale;\n        if (gfp.athaa_type < 0) gfc.ATH.useAdjust = 3; else gfc.ATH.useAdjust = gfp.athaa_type;\n        gfc.ATH.aaSensitivityP = Math.pow(10.0, gfp.athaa_sensitivity / -10.0);\n        if (gfp.short_blocks == null) gfp.short_blocks = ShortBlock.short_block_allowed;\n        if (gfp.short_blocks === ShortBlock.short_block_allowed && (gfp.mode === MPEGMode.JOINT_STEREO || gfp.mode === MPEGMode.STEREO)) gfp.short_blocks = ShortBlock.short_block_coupled;\n        if (gfp.quant_comp < 0) gfp.quant_comp = 1; if (gfp.quant_comp_short < 0) gfp.quant_comp_short = 0;\n        if (gfp.msfix < -10) gfp.msfix = 0.0;\n        gfp.exp_nspsytune |= 1; if (gfc.nsPsy.attackthre < 0) gfc.nsPsy.attackthre = 4.4; if (gfc.nsPsy.attackthre_s < 0) gfc.nsPsy.attackthre_s = 25.0;\n        if (gfp.ATHtype < 0) gfp.ATHtype = 4; if (gfp.ATHcurve < -99) gfp.ATHcurve = 0.0;\n        if (gfp.athaa_loudapprox < 0) gfp.athaa_loudapprox = 2; if (gfp.interChRatio < 0) gfp.interChRatio = 0.0;\n        if (gfp.useTemporal == null) gfp.useTemporal = true;\n        gfc.slot_lag = 0; gfc.frac_SpF = 0;\n        assert(gfp.scale >= 0, \"Scale not initialized\");\n\n        // Set sfb21_extra based on VBR mode and out_samplerate\n        if (gfp.VBR === VbrMode.vbr_rh || gfp.VBR === VbrMode.vbr_mtrh) {\n            if (gfp.experimentalY) {\n                gfc.sfb21_extra = false;\n            } else {\n                gfc.sfb21_extra = (gfp.out_samplerate > 44000);\n            }\n        } else {\n            // CBR/ABR mode\n            gfc.sfb21_extra = false;\n        }\n\n        return 0; // Success\n    }\n\n\n    /**\n     * Encodes the final buffered samples and writes remaining MP3 data,\n     * including VBR tag and ID3 tags if configured. Call this after processing\n     * all input audio samples.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Uint8Array} mp3buffer - Output buffer to receive the encoded MP3 data.\n     * @param {number} mp3bufPos - Starting position offset within `mp3buffer`.\n     * @param {number} mp3buffer_size - Maximum number of bytes available in `mp3buffer` from `mp3bufferPos`.\n     * @returns {number} The number of bytes written to `mp3buffer`, or a negative error code.\n     */\n    lame_encode_flush(gfp, mp3buffer, mp3bufferPos, mp3buffer_size) {\n        const gfc = gfp.internal_flags;\n        const buffer = [new_float(1152), new_float(1152)];\n        let imp3 = 0, mp3count = 0, mp3buffer_size_remaining;\n\n        if (gfc.mf_samples_to_encode < 1) return 0; // Already flushed\n\n        let samples_to_encode = gfc.mf_samples_to_encode - Encoder.POSTDELAY;\n        const mf_needed = this._calcNeeded(gfp);\n        if (gfp.in_samplerate !== gfp.out_samplerate) samples_to_encode += Math.floor(16.0 * gfp.out_samplerate / gfp.in_samplerate);\n        let end_padding = gfp.framesize - (samples_to_encode % gfp.framesize);\n        if (end_padding < 576 && gfp.framesize >= 576) end_padding += gfp.framesize;\n        else if (end_padding === gfp.framesize) end_padding = 0;\n        gfp.encoder_padding = end_padding;\n        let frames_left = Math.ceil((samples_to_encode + end_padding) / gfp.framesize);\n\n        while (frames_left > 0 && imp3 >= 0) {\n            let bunch = mf_needed - gfc.mf_size;\n            if(gfc.resample_ratio > 1e-6) bunch = Math.ceil(bunch * gfc.resample_ratio); else bunch = Math.ceil(bunch);\n            bunch = Math.min(bunch, 1152); if (bunch < 1) bunch = 1;\n            Arrays.fill(buffer[0], 0, bunch, 0.0); if (gfc.channels_out === 2) Arrays.fill(buffer[1], 0, bunch, 0.0);\n            mp3buffer_size_remaining = (mp3buffer_size === 0) ? 0 : mp3buffer_size - mp3count;\n            const frame_num_before = gfp.frameNum;\n            // Use the public float version here, assumes padding buffer is float\n            imp3 = this.lame_encode_buffer_ieee_float(gfp, buffer[0], buffer[1], bunch, mp3buffer, mp3bufferPos, mp3buffer_size_remaining);\n            if (imp3 < 0) return imp3;\n            mp3bufPos += imp3; mp3count += imp3;\n            if (gfp.frameNum > frame_num_before) frames_left--;\n        }\n        gfc.mf_samples_to_encode = 0;\n        if (imp3 < 0) return imp3;\n\n        mp3buffer_size_remaining = (mp3buf_size === 0) ? 0 : mp3buf_size - mp3count;\n        this.bs.flush_bitstream(gfp);\n        imp3 = this.bs.copy_buffer(gfc, mp3buffer, mp3bufferPos, mp3buffer_size_remaining, 1);\n        if (imp3 < 0) return imp3;\n        mp3bufPos += imp3; mp3count += imp3;\n\n        if (gfp.write_id3tag_automatic) {\n            /* this.id3.id3tag_write_v1(gfp); */ console.warn(\"ID3v1 tag writing not implemented.\");\n            mp3buffer_size_remaining = (mp3buf_size === 0) ? 0 : mp3buf_size - mp3count;\n            imp3 = this.bs.copy_buffer(gfc, mp3buffer, mp3bufferPos, mp3buffer_size_remaining, 0);\n            if (imp3 < 0) return imp3;\n            mp3count += imp3;\n        }\n        return mp3count;\n    }\n\n    /**\n     * Encodes a buffer of PCM audio samples provided as Float32 arrays.\n     * Input samples should be in the range [-1.0, 1.0].\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Float32Array} buffer_l - Buffer for the left channel (or mono).\n     * @param {Float32Array|null} buffer_r - Buffer for the right channel (provide null or same as left if mono).\n     * @param {number} nsamples - Number of samples per channel in the input buffers.\n     * @param {Uint8Array} mp3buf - Output buffer to receive the encoded MP3 data.\n     * @param {number} mp3bufPos - Starting position offset within `mp3buf`.\n     * @param {number} mp3buf_size - Maximum number of bytes available in `mp3buf` from `mp3bufPos`.\n     * @returns {number} The number of bytes written to `mp3buf`, or a negative error code.\n     */\n    lame_encode_buffer_ieee_float(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        const gfc = gfp.internal_flags;\n        if (!gfc || gfc.Class_ID !== this._LAME_ID) return -3;\n\n        let input_r = buffer_r;\n        if (gfc.channels_in > 1 && !input_r) { console.error(\"Right channel buffer required for stereo input.\"); return -1; }\n        if (gfc.channels_in === 1) input_r = buffer_l;\n\n        let working_l = buffer_l; let working_r = input_r; let needs_copy = false;\n        if ((Math.abs(gfp.scale - 1.0) > 1e-6 && gfp.scale > 0) || (Math.abs(gfp.scale_left - 1.0) > 1e-6 && gfp.scale_left > 0) || (gfc.channels_out === 2 && Math.abs(gfp.scale_right - 1.0) > 1e-6 && gfp.scale_right > 0) || (gfp.num_channels === 2 && gfc.channels_out === 1)) {\n            needs_copy = true; working_l = new_float(nsamples); if (gfc.channels_in > 1) working_r = new_float(nsamples);\n        }\n        const eff_scale_l = (Math.abs(gfp.scale_left - 1.0) > 1e-6 && gfp.scale_left > 0) ? gfp.scale_left : gfp.scale;\n        const eff_scale_r = (gfc.channels_in > 1 && Math.abs(gfp.scale_right - 1.0) > 1e-6 && gfp.scale_right > 0) ? gfp.scale_right : gfp.scale;\n        if (gfp.num_channels === 2 && gfc.channels_out === 1) { for (let i = 0; i < nsamples; i++) { working_l[i] = 0.5 * (buffer_l[i] * eff_scale_l + buffer_r[i] * eff_scale_r); } working_r = null; }\n        else { const scale_l = (Math.abs(eff_scale_l - 1.0) > 1e-6 && eff_scale_l > 0); const scale_r = (gfc.channels_in > 1 && Math.abs(eff_scale_r - 1.0) > 1e-6 && eff_scale_r > 0); if (needs_copy) { for (let i = 0; i < nsamples; i++) { working_l[i] = scale_l ? buffer_l[i] * eff_scale_l : buffer_l[i]; if (working_r) working_r[i] = scale_r ? buffer_r[i] * eff_scale_r : buffer_r[i]; } } else { working_l = buffer_l; working_r = buffer_r; } }\n        if (gfc.channels_out === 1) working_r = working_l;\n\n        return this._lame_encode_buffer_sample(gfp, working_l, working_r, nsamples, mp3buf, mp3bufPos, mp3buf_size);\n    }\n\n    /**\n     * Encodes a buffer of PCM audio samples provided as Int16 arrays.\n     * Input samples should be in the range [-32768, 32767].\n     * Converts the input to floating point before encoding.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Int16Array} buffer_l - Buffer for the left channel (or mono).\n     * @param {Int16Array|null} buffer_r - Buffer for the right channel (provide null or same as left if mono).\n     * @param {number} nsamples - Number of samples per channel in the input buffers.\n     * @param {Uint8Array} mp3buf - Output buffer to receive the encoded MP3 data.\n     * @param {number} mp3bufPos - Starting position offset within `mp3buf`.\n     * @param {number} mp3buf_size - Maximum number of bytes available in `mp3buf` from `mp3bufPos`.\n     * @returns {number} The number of bytes written to `mp3buf`, or a negative error code.\n     */\n    lame_encode_buffer(gfp, buffer_l, buffer_r, nsamples, mp3buf, mp3bufPos, mp3buf_size) {\n        const gfc = gfp.internal_flags;\n        if (!gfc || gfc.Class_ID !== this._LAME_ID) return -3;\n        if (nsamples === 0) return 0;\n        const float_buf_l = new_float(nsamples); let float_buf_r = null;\n        if (gfc.channels_in > 1) { if (!buffer_r) { console.error(\"Right channel Int16 buffer required for stereo input.\"); return -1; } float_buf_r = new_float(nsamples); }\n        const scale_factor = 1.0 / 32768.0;\n        for (let i = 0; i < nsamples; i++) { float_buf_l[i] = buffer_l[i] * scale_factor; if (float_buf_r && buffer_r) float_buf_r[i] = buffer_r[i] * scale_factor; }\n        return this.lame_encode_buffer_ieee_float(gfp, float_buf_l, float_buf_r, nsamples, mp3buf, mp3bufPos, mp3buf_size);\n    }\n\n\n} // End class Lame\n\nconst LAME_MAXMP3BUFFER = Lame.LAME_MAXMP3BUFFER; // Assign static to const\nexport { Lame, LAME_MAXMP3BUFFER }; // Export both\nexport default Lame; // Also provide default export if needed","import {\n    System,\n    // VbrMode, // Not used in this snippet\n    // Float, // Not used in this snippet\n    // ShortBlock, // Not used in this snippet\n    Util,\n    Arrays,\n    // new_array_n, // Not used in this snippet\n    new_byte,\n    // new_double, // Not used in this snippet\n    new_float,\n    new_float_n,\n    new_int,\n    // new_int_n, // Not used in this snippet\n    assert\n} from './common.js';\n\n// Use import * for modules accessed like namespaces\nimport { Takehiro, count_bit, slen1_tab, slen2_tab } from './Takehiro.js';\nimport * as Tables from './Tables.js';\nimport * as Encoder from './Encoder.js'; // Corrected import\nimport * as LameInternalFlags from './LameInternalFlags.js';\nimport * as Lame from './Lame.js';\n// Assuming GainAnalysis might be part of another module, e.g., context or a dedicated one\n// If GainAnalysis is globally available or part of 'context', no import needed here.\n// If it's from its own file, add: import { GainAnalysis } from './GainAnalysis.js';\n\n\nclass TotalBytes {\n    constructor() {\n        this.total = 0;\n    }\n}\n\nclass BitStream {\n    constructor(context) {\n        this.context = context; // Keep context for GainAnalysis access\n        this.CRC16_POLYNOMIAL = 0x8005;\n        this.MAX_LENGTH = 32;\n\n        // Initialize instance properties\n        this.buf = null; // Will be initialized in init_bit_stream_w\n        this.totbit = 0;\n        this.bufByteIdx = 0;\n        this.bufBitIdx = 0;\n\n        // Initialize module dependencies (to be set via setModules)\n        this.ga = null; // GainAnalysis module/instance\n        this.mpg = null; // Mp3Encoder instance?\n        this.ver = null; // Version module/instance\n        this.vbr = null; // VBR module/instance\n    }\n\n    // Static helper methods moved inside the class\n    static EQ(a, b) {\n        // Original logic uses relative comparison based on larger magnitude\n        return (Math.abs(a) > Math.abs(b))\n            ? (Math.abs((a) - (b)) <= (Math.abs(a) * 1e-6))\n            : (Math.abs((a) - (b)) <= (Math.abs(b) * 1e-6));\n    }\n\n    static NEQ(a, b) {\n        return !BitStream.EQ(a, b);\n    }\n\n\n    setModules(ga, mpg, ver, vbr) {\n        this.ga = ga;\n        this.mpg = mpg;\n        this.ver = ver;\n        this.vbr = vbr;\n    }\n\n    putbits2(gfc, val, j) {\n        assert(j < this.MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k; // keep var for minimal change, let/const preferred\n            if (this.bufBitIdx == 0) {\n                this.bufBitIdx = 8;\n                this.bufByteIdx++;\n                assert(this.bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                // Ensure header buffer exists and indices are valid\n                assert(gfc.header && gfc.header[gfc.w_ptr]);\n                assert(gfc.header[gfc.w_ptr].write_timing >= this.totbit);\n                if (gfc.header[gfc.w_ptr].write_timing == this.totbit) {\n                    this.putheader_bits(gfc);\n                }\n                assert(this.buf); // Ensure buffer is initialized\n                this.buf[this.bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, this.bufBitIdx);\n            j -= k;\n\n            this.bufBitIdx -= k;\n\n            assert(j < this.MAX_LENGTH);\n            assert(this.bufBitIdx < this.MAX_LENGTH);\n            assert(this.buf);\n\n            // Ensure val >> j doesn't result in unexpected negative numbers if val is large\n            // (though j < MAX_LENGTH-2 should prevent this with standard positive val)\n            this.buf[this.bufByteIdx] |= ((val >>> j) << this.bufBitIdx); // Use >>> for unsigned shift\n            this.totbit += k;\n        }\n    }\n\n    getframebits(gfp) {\n        var gfc = gfp.internal_flags;\n        var bit_rate;\n\n        if (gfc.bitrate_index != 0) {\n            // Ensure Tables structure is correct\n            assert(Tables.bitrate_table && Tables.bitrate_table[gfp.version]);\n            bit_rate = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        }\n        else {\n            bit_rate = gfp.brate;\n        }\n        assert(8 <= bit_rate && bit_rate <= 640);\n\n        // Use Math.floor for explicit integer conversion\n        var bytes = Math.floor((gfp.version + 1) * 72000 * bit_rate / gfp.out_samplerate + gfc.padding);\n        return 8 * bytes;\n    }\n\n    drain_into_ancillary(gfp, remainingBits) {\n        var gfc = gfp.internal_flags;\n        var i;\n        assert(remainingBits >= 0);\n\n        // Simplified writing 'LAME'\n        const lameHeader = [0x4c, 0x41, 0x4d, 0x45]; // L A M E\n        for (let byte of lameHeader) {\n            if (remainingBits >= 8) {\n                 this.putbits2(gfc, byte, 8);\n                 remainingBits -= 8;\n            } else break;\n        }\n\n        // Write version string\n        if (remainingBits >= 32 && this.ver) { // Check if ver module is set\n            var version = this.ver.getLameShortVersion(); // Assuming this method exists\n            if (version) {\n                for (i = 0; i < version.length && remainingBits >= 8; ++i) {\n                     this.putbits2(gfc, version.charCodeAt(i), 8); // Use charCodeAt\n                     remainingBits -= 8;\n                }\n            }\n        }\n\n        // Fill remaining bits\n        for (; remainingBits >= 1; remainingBits -= 1) {\n            this.putbits2(gfc, gfc.ancillary_flag, 1);\n            gfc.ancillary_flag ^= (!gfp.disable_reservoir ? 1 : 0);\n        }\n\n        assert(remainingBits == 0);\n    }\n\n    putheader_bits(gfc) {\n         // Ensure header buffer exists and indices are valid\n        assert(gfc.header && gfc.header[gfc.w_ptr] && gfc.header[gfc.w_ptr].buf);\n        assert(this.buf);\n        // Ensure lengths and indices allow copy\n        assert(this.bufByteIdx + gfc.sideinfo_len < this.buf.length);\n\n        System.arraycopy(gfc.header[gfc.w_ptr].buf, 0, this.buf, this.bufByteIdx, gfc.sideinfo_len);\n        this.bufByteIdx += gfc.sideinfo_len;\n        this.totbit += gfc.sideinfo_len * 8;\n        gfc.w_ptr = (gfc.w_ptr + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n    }\n\n    putbits_noheaders(gfc, val, j) {\n        assert(j < this.MAX_LENGTH - 2);\n\n        while (j > 0) {\n            var k;\n            if (this.bufBitIdx == 0) {\n                this.bufBitIdx = 8;\n                this.bufByteIdx++;\n                assert(this.bufByteIdx < Lame.LAME_MAXMP3BUFFER);\n                assert(this.buf);\n                this.buf[this.bufByteIdx] = 0;\n            }\n\n            k = Math.min(j, this.bufBitIdx);\n            j -= k;\n\n            this.bufBitIdx -= k;\n\n            assert(j < this.MAX_LENGTH);\n            assert(this.bufBitIdx < this.MAX_LENGTH);\n            assert(this.buf);\n\n            this.buf[this.bufByteIdx] |= ((val >>> j) << this.bufBitIdx); // Use >>>\n            this.totbit += k;\n        }\n    }\n\n    writeheader(gfc, val, j) {\n        // Ensure header buffer exists and indices are valid\n        assert(gfc.header && gfc.header[gfc.h_ptr] && gfc.header[gfc.h_ptr].buf);\n        var ptr = gfc.header[gfc.h_ptr].ptr;\n\n        while (j > 0) {\n            var k = Math.min(j, 8 - (ptr & 7));\n            j -= k;\n            assert(j < this.MAX_LENGTH);\n            var byteIndex = ptr >>> 3; // Use unsigned shift for index\n            assert(byteIndex < Lame.LAME_MAXMP3BUFFER); // Check buffer bounds\n            assert(byteIndex < gfc.header[gfc.h_ptr].buf.length);\n\n            // Apply mask to ensure only relevant bits of val are used\n            var shiftAmount = 8 - (ptr & 7) - k;\n            var mask = ( (1 << k) - 1 ); // Create a mask of k bits\n            var bitsToWrite = (val >>> j) & mask; // Get the lowest k bits of (val >>> j)\n\n            gfc.header[gfc.h_ptr].buf[byteIndex] |= (bitsToWrite << shiftAmount);\n            ptr += k;\n        }\n        gfc.header[gfc.h_ptr].ptr = ptr;\n    }\n\n\n    CRC_update(value, crc) {\n        value <<= 8;\n        crc &= 0xFFFF; // Ensure crc is 16 bit before starting\n\n        for (var i = 0; i < 8; i++) {\n            crc <<= 1;\n            value <<= 1; // Shift value along with crc\n\n            // Check the top bit (bit 16) of crc XOR value's relevant bit (now at bit 16)\n            if (((crc ^ value) & 0x10000) !== 0) {\n                 crc ^= this.CRC16_POLYNOMIAL;\n            }\n            crc &= 0xFFFF; // Keep crc within 16 bits\n        }\n        return crc;\n    }\n\n\n    CRC_writeheader(gfc, header) {\n        var crc = 0xffff;\n         // Ensure header exists and is long enough\n        assert(header && header.length >= 6);\n        // Ensure indices are valid for sideinfo_len\n        assert(gfc.sideinfo_len <= header.length);\n\n        // Mask with 0xff to ensure we process byte values\n        crc = this.CRC_update(header[2] & 0xff, crc);\n        crc = this.CRC_update(header[3] & 0xff, crc);\n        for (var i = 6; i < gfc.sideinfo_len; i++) {\n            crc = this.CRC_update(header[i] & 0xff, crc);\n        }\n\n        // Assign low and high bytes of CRC\n        header[4] = (crc >> 8) & 0xff; // High byte\n        header[5] = crc & 0xff;        // Low byte\n    }\n\n    encodeSideInfo2(gfp, bitsPerFrame) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var gr, ch;\n\n        l3_side = gfc.l3_side;\n         // Ensure header buffer exists and indices are valid\n        assert(gfc.header && gfc.header[gfc.h_ptr] && gfc.header[gfc.h_ptr].buf);\n        gfc.header[gfc.h_ptr].ptr = 0;\n        // Use standard fill method if available, otherwise loop\n        Arrays.fill(gfc.header[gfc.h_ptr].buf, 0, gfc.sideinfo_len, 0);\n\n        // Write header fields... (using this.writeheader)\n        if (gfp.out_samplerate < 16000) // MPEG 2/2.5\n            this.writeheader(gfc, 0xffe, 12); // sync\n        else // MPEG 1\n            this.writeheader(gfc, 0xfff, 12); // sync\n\n        this.writeheader(gfc, gfp.version, 1); // ID\n        this.writeheader(gfc, 1, 2); // layer (01 = layer III) Changed from 4-3 logic to direct value\n        this.writeheader(gfc, gfp.error_protection ? 0 : 1, 1); //!protection_bit\n        this.writeheader(gfc, gfc.bitrate_index, 4); // bitrate_index\n        this.writeheader(gfc, gfc.samplerate_index, 2); // sampling_frequency\n        this.writeheader(gfc, gfc.padding, 1); // padding_bit\n        this.writeheader(gfc, gfp.extension, 1); // private_bit\n        this.writeheader(gfc, gfp.mode.ordinal(), 2); // mode\n        this.writeheader(gfc, gfc.mode_ext, 2); // mode_extension\n        this.writeheader(gfc, gfp.copyright, 1); // copyright\n        this.writeheader(gfc, gfp.original, 1); // original/copy\n        this.writeheader(gfc, gfp.emphasis, 2); // emphasis\n\n        if (gfp.error_protection) {\n            this.writeheader(gfc, 0, 16); // CRC (placeholder, filled later)\n        }\n\n        // Write side info based on MPEG version\n        if (gfp.version == 1) { // MPEG 1\n             assert(l3_side.main_data_begin >= 0);\n             this.writeheader(gfc, l3_side.main_data_begin, 9);\n             if (gfc.channels_out == 2)\n                 this.writeheader(gfc, l3_side.private_bits, 3);\n             else\n                 this.writeheader(gfc, l3_side.private_bits, 5);\n\n             for (ch = 0; ch < gfc.channels_out; ch++) {\n                 for (let band = 0; band < 4; band++) { // Use let for block scope\n                     this.writeheader(gfc, l3_side.scfsi[ch][band], 1);\n                 }\n             }\n             for (gr = 0; gr < 2; gr++) {\n                 for (ch = 0; ch < gfc.channels_out; ch++) {\n                     var gi = l3_side.tt[gr][ch]; // Keep var for minimal change\n                     this.writeheader(gfc, gi.part2_3_length, 12); // part2_3_length (adjusted: only huffman bits now)\n                     this.writeheader(gfc, gi.big_values / 2, 9); // big_values\n                     this.writeheader(gfc, gi.global_gain, 8); // global_gain\n                     this.writeheader(gfc, gi.scalefac_compress, 4); // scalefac_compress\n                     this.writeheader(gfc, gi.window_switching_flag, 1); // window_switching_flag\n\n                     if (gi.window_switching_flag) { // Short or Mixed block\n                         this.writeheader(gfc, gi.block_type, 2); // block_type\n                         this.writeheader(gfc, gi.mixed_block_flag, 1); // mixed_block_flag\n                         for (let i = 0; i < 2; i++) { // Use let for block scope\n                             this.writeheader(gfc, gi.table_select[i], 5); // table_select\n                         }\n                          for (let i = 0; i < 3; i++) { // Use let for block scope\n                             this.writeheader(gfc, gi.subblock_gain[i], 3); // subblock_gain\n                         }\n                         // region0_count and region1_count are implicit for short blocks in MPEG1\n                          // For mixed blocks:\n                         if (gi.block_type == 2 && gi.mixed_block_flag == 1) {\n                           this.writeheader(gfc, gi.region0_count, 4); // region0_count for the long part\n                           this.writeheader(gfc, gi.region1_count, 3); // region1_count for the long part\n                         }\n\n                     } else { // Long block (NORM_TYPE)\n                         for (let i = 0; i < 3; i++) { // Use let for block scope\n                             this.writeheader(gfc, gi.table_select[i], 5); // table_select\n                         }\n                         this.writeheader(gfc, gi.region0_count, 4); // region0_count\n                         this.writeheader(gfc, gi.region1_count, 3); // region1_count\n                     }\n                     this.writeheader(gfc, gi.preflag, 1); // preflag\n                     this.writeheader(gfc, gi.scalefac_scale, 1); // scalefac_scale\n                     this.writeheader(gfc, gi.count1table_select, 1); // count1table_select\n                 }\n             }\n        } else { // MPEG 2/2.5\n            assert(l3_side.main_data_begin >= 0);\n            this.writeheader(gfc, l3_side.main_data_begin, 8); // main_data_begin\n            this.writeheader(gfc, l3_side.private_bits, gfc.channels_out); // private_bits (1 per channel)\n\n            gr = 0; // MPEG 2/2.5 only has one granule in side info\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                 var gi = l3_side.tt[gr][ch]; // Keep var\n                 this.writeheader(gfc, gi.part2_3_length, 12); // part2_3_length (adjusted)\n                 this.writeheader(gfc, gi.big_values / 2, 9); // big_values\n                 this.writeheader(gfc, gi.global_gain, 8); // global_gain\n                 this.writeheader(gfc, gi.scalefac_compress, 9); // scalefac_compress (MPEG2 has 9 bits)\n                 this.writeheader(gfc, gi.window_switching_flag, 1); // window_switching_flag\n\n                 if (gi.window_switching_flag) {\n                     this.writeheader(gfc, gi.block_type, 2);\n                     this.writeheader(gfc, gi.mixed_block_flag, 1);\n                     for (let i = 0; i < 2; i++) {\n                         this.writeheader(gfc, gi.table_select[i], 5);\n                     }\n                     for (let i = 0; i < 3; i++) {\n                          this.writeheader(gfc, gi.subblock_gain[i], 3);\n                     }\n                     // region counts implicit/different for MPEG2 short blocks\n                     if (gi.block_type == 2 && gi.mixed_block_flag == 1) { // Mixed block case for MPEG2\n                        // Need table for MPEG2 region count bits (differs from MPEG1)\n                        // Example placeholder - requires exact spec:\n                        this.writeheader(gfc, gi.region0_count, 4); // Example, adjust bits per spec\n                        this.writeheader(gfc, gi.region1_count, 3); // Example, adjust bits per spec\n                     }\n                 } else { // Long blocks\n                     for (let i = 0; i < 3; i++) {\n                         this.writeheader(gfc, gi.table_select[i], 5);\n                     }\n                      // Need table for MPEG2 region count bits (differs from MPEG1)\n                      // Example placeholder - requires exact spec:\n                     this.writeheader(gfc, gi.region0_count, 4); // Example, adjust bits per spec\n                     this.writeheader(gfc, gi.region1_count, 3); // Example, adjust bits per spec\n                 }\n                 // MPEG2 doesn't have preflag bit\n                 this.writeheader(gfc, gi.scalefac_scale, 1); // scalefac_scale\n                 this.writeheader(gfc, gi.count1table_select, 1); // count1table_select\n            }\n        }\n\n\n        // Calculate and write CRC if needed\n        if (gfp.error_protection) {\n            this.CRC_writeheader(gfc, gfc.header[gfc.h_ptr].buf);\n        }\n\n        // Advance header buffer pointers\n        { // Keep block scope for old variable\n            var old = gfc.h_ptr;\n            // Check pointer value consistency (optional sanity check)\n            // assert(gfc.header[old].ptr == gfc.sideinfo_len * 8);\n\n            gfc.h_ptr = (old + 1) & (LameInternalFlags.MAX_HEADER_BUF - 1);\n             // Ensure header buffer exists and indices are valid before accessing write_timing\n             assert(gfc.header && gfc.header[old] && gfc.header[gfc.h_ptr]);\n            gfc.header[gfc.h_ptr].write_timing = gfc.header[old].write_timing + bitsPerFrame;\n\n            if (gfc.h_ptr == gfc.w_ptr) {\n                // Consider throwing an error instead of just printing\n                console.error(\"Error: MAX_HEADER_BUF too small in bitstream.c\");\n                // throw new Error(\"MAX_HEADER_BUF too small\");\n            }\n        }\n    }\n\n    // --- Huffman Coding Methods --- (Keep var for minimal change)\n    huffman_coder_count1(gfc, gi) {\n        // Check if Tables.ht is valid and index is in bounds\n        assert(Tables.ht && (gi.count1table_select + 32) < Tables.ht.length);\n        var h = Tables.ht[gi.count1table_select + 32];\n        var i, bits = 0;\n\n        var ix = gi.big_values;\n        var xr = gi.big_values; // Assuming gi.xr holds signed values corresponding to l3_enc\n        assert(gi.count1table_select < 2);\n\n        for (i = (gi.count1 - gi.big_values) / 4; i > 0; --i) {\n            var huffbits = 0;\n            var p = 0, v;\n\n            // Process quad\n            v = gi.l3_enc[ix + 0]; // Value (0 or 1)\n            if (v !== 0) {\n                p += 8; // Huffman table index component\n                if (gi.xr[xr + 0] < 0) huffbits = 1; // Sign bit\n                assert(v === 1);\n            }\n\n            v = gi.l3_enc[ix + 1];\n            if (v !== 0) {\n                p += 4;\n                huffbits <<= 1; // Shift sign bits left\n                if (gi.xr[xr + 1] < 0) huffbits |= 1;\n                assert(v === 1);\n            }\n\n            v = gi.l3_enc[ix + 2];\n            if (v !== 0) {\n                p += 2;\n                huffbits <<= 1;\n                if (gi.xr[xr + 2] < 0) huffbits |= 1;\n                assert(v === 1);\n            }\n\n            v = gi.l3_enc[ix + 3];\n            if (v !== 0) {\n                p += 1;\n                huffbits <<= 1;\n                if (gi.xr[xr + 3] < 0) huffbits |= 1;\n                assert(v === 1);\n            }\n\n            ix += 4;\n            xr += 4;\n            // Ensure h.table and h.hlen are valid for index p\n            assert(h.table && h.hlen && p < h.table.length && p < h.hlen.length);\n            var code = h.table[p];\n            var len = h.hlen[p];\n            var signLen = count_bit(p); // Number of non-zero values = number of sign bits\n\n            assert(len >= 0 && signLen >= 0);\n\n            this.putbits2(gfc, code, len); // Write Huffman code\n            if (signLen > 0) {\n                this.putbits2(gfc, huffbits, signLen); // Write sign bits\n            }\n            bits += len + signLen;\n        }\n        return bits;\n    }\n\n\n    Huffmancode(gfc, tableindex, start, end, gi) {\n        // Ensure Tables.ht is valid and index is in bounds\n        assert(Tables.ht && tableindex < Tables.ht.length);\n        var h = Tables.ht[tableindex];\n        var bits = 0;\n\n        assert(tableindex < 32);\n        if (0 == tableindex) return 0; // Table 0 means no data\n\n        for (var i = start; i < end; i += 2) {\n            var cbits = 0; // Length of Huffman code part\n            var xbits = 0; // Length of sign bits + linbits part\n            var linbits = h.linmax ? h.xlen : 0; // Length of linbits per value (0 if not used)\n            var xlen = h.xlen; // Max value represented directly by huffman code (+1?)\n            var ext = 0; // Combined sign/linbits value\n            var x1 = Math.abs(gi.l3_enc[i]); // Use absolute value for table lookup\n            var x2 = Math.abs(gi.l3_enc[i + 1]);\n            var sign1 = (gi.l3_enc[i] < 0); // Original sign\n            var sign2 = (gi.l3_enc[i + 1] < 0);\n\n             // Handle linbits (escape mechanism for large values)\n            if (tableindex > 15) { // Tables 16-31 use linbits\n                 assert(linbits > 0); // xlen should be > 0 for linbits tables\n                 if (x1 >= xlen) { // Check against h.xlen which is max value + 1? Or just max value? ISO spec says: xlen=16 for tables 16..31 => max val is 15.\n                     var linbits_x1 = x1 - xlen; // Value beyond Huffman range\n                     assert(linbits_x1 <= h.linmax);\n                     ext = linbits_x1; // Store linbits part\n                     xbits = linbits;   // Add linbits length\n                     x1 = xlen;         // Use max huffman value for table lookup\n                 }\n                 if (x2 >= xlen) {\n                     var linbits_x2 = x2 - xlen;\n                     assert(linbits_x2 <= h.linmax);\n                      // Combine linbits: shift previous by linbits length, add new\n                     ext = (ext << linbits) | linbits_x2;\n                     xbits += linbits; // Add linbits length\n                     x2 = xlen;         // Use max huffman value for table lookup\n                 }\n            } else {\n                // Tables 1..15: xlen is the max value (e.g., 1 for table 1)\n                 assert(x1 <= xlen); // Values should not exceed table limits\n                 assert(x2 <= xlen);\n            }\n\n\n            // Add sign bits if values are non-zero\n            var signmask = 0;\n            var signlen = 0;\n            if (x1 != 0) {\n                signmask = sign1 ? 1 : 0;\n                signlen = 1;\n            }\n            if (x2 != 0) {\n                signmask = (signmask << 1) | (sign2 ? 1 : 0);\n                signlen++;\n            }\n\n            // Combine sign bits and linbits (ext)\n            ext = (ext << signlen) | signmask;\n            xbits += signlen; // Add sign bit length\n\n\n            // Lookup Huffman code\n            var pair_index = x1 * (xlen + 1) + x2; // Calculate index into paired Huffman table\n             // Ensure h.table and h.hlen are valid for index pair_index\n            assert(h.table && h.hlen && pair_index < h.table.length && pair_index < h.hlen.length);\n            cbits = h.hlen[pair_index]; // Get Huffman code length\n\n            assert(cbits >= 0 && xbits >= 0);\n\n            this.putbits2(gfc, h.table[pair_index], cbits); // Write Huffman code\n            if (xbits > 0) {\n                this.putbits2(gfc, ext, xbits); // Write sign/linbits\n            }\n            bits += cbits + xbits;\n        }\n        return bits;\n    }\n\n\n    ShortHuffmancodebits(gfc, gi) {\n        // Check scalefac band structure\n        assert(gfc.scalefac_band && gfc.scalefac_band.s);\n        // Determine region boundaries (ISO 5.1.1): 3 short blocks, sfb 0..11\n        // For short blocks, there's no region partitioning like in long blocks.\n        // The whole big_values range (0..575) is coded with one table pair.\n        // Table select is based on subblock gains (not done here, assumed gi.table_select is set correctly).\n        // Let's assume gi.table_select[0] is the correct table for the whole range.\n        // The original code had region1Start logic which applies to LONG blocks.\n\n        // Correct logic for short blocks: Use table_select[0] for the whole big_values range.\n        var bits = this.Huffmancode(gfc, gi.table_select[0], 0, gi.big_values, gi);\n        return bits;\n    }\n\n    LongHuffmancodebits(gfc, gi) {\n        var bigvalues, bits;\n        var region1Start, region2Start;\n\n        bigvalues = gi.big_values;\n        assert(0 <= bigvalues && bigvalues <= 576);\n         // Check scalefac band structure\n        assert(gfc.scalefac_band && gfc.scalefac_band.l);\n\n        // Determine region boundaries using the scalefactor band indices\n        var i = gi.region0_count + 1; // region0 uses bands 0..region0_count\n        assert(0 <= i && i < gfc.scalefac_band.l.length);\n        region1Start = gfc.scalefac_band.l[i]; // Start index for region1\n\n        i += gi.region1_count + 1; // region1 uses bands region0_count+1 .. region0_count+region1_count+1\n        assert(0 <= i && i < gfc.scalefac_band.l.length);\n        region2Start = gfc.scalefac_band.l[i]; // Start index for region2\n\n        // Clamp region boundaries to the actual number of bigvalues\n        if (region1Start > bigvalues) region1Start = bigvalues;\n        if (region2Start > bigvalues) region2Start = bigvalues;\n\n        // Code each region with its selected table\n        bits = this.Huffmancode(gfc, gi.table_select[0], 0, region1Start, gi);\n        bits += this.Huffmancode(gfc, gi.table_select[1], region1Start, region2Start, gi);\n        bits += this.Huffmancode(gfc, gi.table_select[2], region2Start, bigvalues, gi);\n        return bits;\n    }\n\n\n    writeMainData(gfp) {\n        var gr, ch, sfb, data_bits, tot_bits = 0;\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n\n        if (gfp.version == 1) { // MPEG 1\n            for (gr = 0; gr < 2; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var gi = l3_side.tt[gr][ch];\n                    var slen1 = slen1_tab[gi.scalefac_compress];\n                    var slen2 = slen2_tab[gi.scalefac_compress];\n                    var scale_bits = 0; // Renamed from data_bits for clarity\n\n                    // Write scalefactors\n                    for (sfb = 0; sfb < gi.sfbdivide; sfb++) { // Using sfbdivide from LAME logic\n                        if (gi.scalefac[sfb] == -1) continue; // -1 indicates scfsi=1, reuse from granule 0\n                        this.putbits2(gfc, gi.scalefac[sfb], slen1);\n                        scale_bits += slen1;\n                    }\n                    for (; sfb < gi.sfbmax; sfb++) { // Using sfbmax from LAME logic\n                        if (gi.scalefac[sfb] == -1) continue;\n                        this.putbits2(gfc, gi.scalefac[sfb], slen2);\n                        scale_bits += slen2;\n                    }\n                    // Part2 length check (scalefactors only)\n                    // This assertion might fail if the LAME calculation differs slightly from ISO\n                    // assert(scale_bits == gi.part2_length);\n\n                    // Write Huffman coded data (Part3)\n                    var huff_bits = 0;\n                    if (gi.window_switching_flag && gi.block_type == Encoder.SHORT_TYPE) { // SHORT block type check\n                         huff_bits = this.ShortHuffmancodebits(gfc, gi);\n                    } else { // Long or Mixed\n                         huff_bits = this.LongHuffmancodebits(gfc, gi);\n                    }\n                    huff_bits += this.huffman_coder_count1(gfc, gi); // count1 region\n\n                    // Check total bits (Part2 + Part3)\n                    // The original code asserted against part2_3_length + part2_length,\n                    // which seems wrong. Part2_3_length *should* include Part2.\n                    // Let's assert against the side info's part2_3_length directly.\n                    assert(scale_bits + huff_bits == gi.part2_3_length);\n                    tot_bits += scale_bits + huff_bits;\n                }\n            }\n        } else { // MPEG 2/2.5\n             gr = 0; // Only 1 granule\n             for (ch = 0; ch < gfc.channels_out; ch++) {\n                 var gi = l3_side.tt[gr][ch];\n                 var i, sfb_partition, scale_bits = 0;\n                 assert(gi.sfb_partition_table != null); // MPEG2 uses partition tables\n                 var huff_bits = 0;\n\n                 sfb = 0;\n                 sfb_partition = 0;\n\n                 // Write scalefactors based on block type and partitions\n                 if (gi.window_switching_flag && gi.block_type == Encoder.SHORT_TYPE) { // SHORT\n                      for (; sfb_partition < 4; sfb_partition++) {\n                          var sfbs = gi.sfb_partition_table[sfb_partition] / 3;\n                          var slen = gi.slen[sfb_partition]; // slen per partition\n                          for (i = 0; i < sfbs; i++, sfb++) {\n                              // Write scalefactors for 3 windows, ensure value >= 0\n                              this.putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 0], 0), slen);\n                              this.putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 1], 0), slen);\n                              this.putbits2(gfc, Math.max(gi.scalefac[sfb * 3 + 2], 0), slen);\n                              scale_bits += 3 * slen;\n                          }\n                      }\n                       huff_bits = this.ShortHuffmancodebits(gfc, gi);\n                 } else { // LONG or MIXED\n                      for (; sfb_partition < 4; sfb_partition++) {\n                           var sfbs = gi.sfb_partition_table[sfb_partition];\n                           var slen = gi.slen[sfb_partition];\n                           for (i = 0; i < sfbs; i++, sfb++) {\n                               this.putbits2(gfc, Math.max(gi.scalefac[sfb], 0), slen);\n                               scale_bits += slen;\n                           }\n                      }\n                      huff_bits = this.LongHuffmancodebits(gfc, gi);\n                 }\n                 huff_bits += this.huffman_coder_count1(gfc, gi); // count1 region\n\n                 // Check lengths (part2_length might differ in LAME vs ISO?)\n                 // assert(huff_bits == gi.part2_3_length); // Huffman part\n                 // assert(scale_bits == gi.part2_length); // Scalefactor part\n                 assert(scale_bits + huff_bits == gi.part2_3_length); // Total main data check\n                 tot_bits += scale_bits + huff_bits;\n             }\n        }\n        return tot_bits;\n    }\n\n\n    compute_flushbits(gfp, total_bytes_output) {\n        var gfc = gfp.internal_flags;\n        var flushbits, remaining_headers;\n        var bitsPerFrame;\n        var last_ptr, first_ptr;\n\n        // Ensure header buffer exists and indices are valid\n        assert(gfc.header);\n        first_ptr = gfc.w_ptr;\n        last_ptr = (gfc.h_ptr - 1 + LameInternalFlags.MAX_HEADER_BUF) % LameInternalFlags.MAX_HEADER_BUF; // Wrap around correctly\n\n        // Check if buffers are valid before accessing\n        assert(gfc.header[last_ptr]);\n\n        // Bits remaining in the buffer from last full frame written + header timings\n        flushbits = gfc.header[last_ptr].write_timing - this.totbit;\n        total_bytes_output.total = flushbits; // Store total bits before adding final frame/padding\n\n        if (flushbits >= 0) {\n            // Calculate how many full headers are waiting to be written\n            remaining_headers = (last_ptr - first_ptr + 1 + LameInternalFlags.MAX_HEADER_BUF) % LameInternalFlags.MAX_HEADER_BUF;\n             // The flushbits already includes the time until the *start* of the last header.\n             // We need to subtract the bits *for* the headers themselves if they haven't been physically put in the buffer yet.\n            // This seems overly complex - the timing should just reflect when the *data* ends.\n\n            // Simpler approach: flushbits = time_of_last_data_end - current_bits_written\n             // The write_timing likely includes the frame bits *after* the header.\n             // Let's trust the original calculation for now.\n             flushbits -= remaining_headers * 8 * gfc.sideinfo_len; // Subtract side info bits not yet physically placed\n        }\n\n        // Add bits for one final (potentially partial) frame to flush everything\n        bitsPerFrame = this.getframebits(gfp);\n        flushbits += bitsPerFrame;\n        total_bytes_output.total += bitsPerFrame; // Add final frame bits to total\n\n        // Calculate total bytes needed in the output buffer\n        if ((total_bytes_output.total % 8) != 0) {\n            total_bytes_output.total = 1 + Math.floor(total_bytes_output.total / 8);\n        } else {\n             total_bytes_output.total = total_bytes_output.total / 8;\n        }\n        // Add bytes currently physically in the buffer instance\n        total_bytes_output.total += this.bufByteIdx + 1;\n\n        if (flushbits < 0) {\n            console.error(\"strange error flushing buffer ... flushbits < 0\");\n            // Handle error, maybe return negative or throw\n            return -1; // Indicate error\n        }\n        return flushbits;\n    }\n\n\n    flush_bitstream(gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        var flushbits;\n\n        // Ensure header buffer exists and indices are valid\n        assert(gfc.header);\n        var last_ptr = (gfc.h_ptr - 1 + LameInternalFlags.MAX_HEADER_BUF) % LameInternalFlags.MAX_HEADER_BUF; // Wrap around correctly\n        assert(gfc.header[last_ptr]);\n\n        l3_side = gfc.l3_side;\n\n        const tempTotalBytes = new TotalBytes(); // Use a temporary object\n        flushbits = this.compute_flushbits(gfp, tempTotalBytes);\n        if (flushbits < 0) return; // Error calculating flushbits\n\n        this.drain_into_ancillary(gfp, flushbits); // Fill remaining bits\n\n        // Sanity check: total bits written should now align with the end timing of the last frame\n        assert(BitStream.EQ(gfc.header[last_ptr].write_timing + this.getframebits(gfp), this.totbit));\n\n        // Reset counters for next potential encoding session?\n        // These seem specific to LAME's internal state management\n        gfc.ResvSize = 0;\n        l3_side.main_data_begin = 0;\n\n        // Handle ReplayGain and Peak Sample calculation if enabled and modules are set\n        if (gfc.findReplayGain && this.context && this.ga) {\n             // Need GainAnalysis class definition or import\n            const GainAnalysis = this.ga; // Assuming ga holds the GainAnalysis class/methods\n            var RadioGain = GainAnalysis.GetTitleGain(gfc.rgdata); // Call static method? Or instance?\n            assert(BitStream.NEQ(RadioGain, GainAnalysis.GAIN_NOT_ENOUGH_SAMPLES));\n            gfc.RadioGain = Math.floor(RadioGain * 10.0 + 0.5); // Explicit floor\n        }\n\n        if (gfc.findPeakSample) {\n            // Avoid log10(0) or log10(negative)\n            if (gfc.PeakSample > 0) {\n                 gfc.noclipGainChange = Math.ceil(Math.log10(gfc.PeakSample / 32767.0) * 20.0 * 10.0); // Explicit ceil\n            } else {\n                 gfc.noclipGainChange = -Infinity; // Or some indicator of no peak/silence\n            }\n\n            if (gfc.noclipGainChange > 0) {\n                if (BitStream.EQ(gfp.scale, 1.0) || BitStream.EQ(gfp.scale, 0.0)) {\n                     gfc.noclipScale = (gfc.PeakSample > 0)\n                        ? (Math.floor((32767.0 / gfc.PeakSample) * 100.0) / 100.0)\n                        : 1.0; // Avoid division by zero if PeakSample is 0\n                }\n                else {\n                    gfc.noclipScale = -1; // Indicate not applicable due to user scale\n                }\n            } else {\n                gfc.noclipScale = -1; // Indicate no scaling needed or error\n            }\n        }\n    }\n\n\n    add_dummy_byte(gfp, val, n) {\n        var gfc = gfp.internal_flags;\n        var i;\n\n        while (n-- > 0) {\n            this.putbits_noheaders(gfc, val, 8);\n\n            // Adjust write timings in the header buffer\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) {\n                 // Ensure header buffer exists and index is valid\n                if (gfc.header && gfc.header[i]) {\n                     gfc.header[i].write_timing += 8;\n                }\n            }\n        }\n    }\n\n    format_bitstream(gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side;\n        l3_side = gfc.l3_side;\n\n        var bitsPerFrame = this.getframebits(gfp);\n\n        // Drain bits from reservoir needed *before* side info/main data\n        this.drain_into_ancillary(gfp, l3_side.resvDrain_pre);\n\n        // Write header and side info for the current frame\n        this.encodeSideInfo2(gfp, bitsPerFrame);\n\n        // Write scalefactors and Huffman data\n        var main_data_bits = this.writeMainData(gfp);\n        var side_info_bits = 8 * gfc.sideinfo_len;\n\n        // Drain bits specified to be written *after* main data\n        this.drain_into_ancillary(gfp, l3_side.resvDrain_post);\n\n        // Total bits written for this frame's core data + side info + post-drain\n        var bits_written_this_frame = side_info_bits + main_data_bits + l3_side.resvDrain_post;\n\n        // Update main_data_begin for the *next* frame's header\n        // It's the offset from the header start to where main data begins.\n        // Calculated based on how many bits were *not* filled by this frame's data + drain.\n        var frame_deficit = bitsPerFrame - bits_written_this_frame;\n        // The new main_data_begin is the previous deficit (ResvSize) plus this frame's deficit, divided by 8 for bytes.\n        // Note: ResvSize holds the deficit from the *previous* frame in bits.\n        l3_side.main_data_begin = (gfc.ResvSize + frame_deficit) / 8;\n\n        // Check buffer consistency: Compare calculated remaining bits (reservoir) with main_data_begin * 8\n        // compute_flushbits calculates bits needed based on header timings.\n        // ResvSize is LAME's internal track of reservoir bits. They should match.\n        const tempTotalBytes = new TotalBytes(); // Use temporary object\n        if (this.compute_flushbits(gfp, tempTotalBytes) != gfc.ResvSize) {\n             console.error(\"Internal buffer inconsistency. flushbits <> ResvSize\");\n             // Potentially correct ResvSize or throw error\n             // gfc.ResvSize = this.compute_flushbits(gfp, tempTotalBytes);\n        }\n\n        // Check if main_data_begin correctly reflects the reservoir size\n        // Allow for small rounding differences? Usually should be exact.\n        if (Math.abs(l3_side.main_data_begin * 8 - gfc.ResvSize) > 1) { // Allow tolerance of 1 bit?\n             console.error(`Bit reservoir error: MDB*8 (${l3_side.main_data_begin * 8}) != ResvSize (${gfc.ResvSize})`);\n             console.error(`  Frame deficit: ${frame_deficit}, Bits written: ${bits_written_this_frame}, BPF: ${bitsPerFrame}`);\n             // Print detailed diagnostics if needed (from original code)\n             // ... (diagnostic printf) ...\n             // Correct the reservoir size to match calculation?\n             gfc.ResvSize = l3_side.main_data_begin * 8;\n        }\n\n\n        assert(this.totbit % 8 == 0); // Total bits written should be byte-aligned at frame end\n\n        // Prevent totbit from growing indefinitely (wrap around simulation)\n        if (this.totbit > 1000000000) { // Arbitrary large number\n            var i;\n            var wrapAmount = this.totbit - (this.totbit % bitsPerFrame); // Wrap to a frame boundary? Or just subtract large multiple?\n            for (i = 0; i < LameInternalFlags.MAX_HEADER_BUF; ++i) {\n                 if (gfc.header && gfc.header[i]) {\n                     gfc.header[i].write_timing -= wrapAmount;\n                 }\n            }\n            this.totbit -= wrapAmount;\n        }\n\n        return 0; // Success\n    }\n\n\n    copy_buffer(gfc, buffer, bufferPos, size, mp3data) {\n        // Calculate bytes currently held in the instance buffer\n        var bytes_to_copy = this.bufByteIdx + 1;\n        if (bytes_to_copy <= 0) return 0; // Nothing to copy\n\n        // Check if destination buffer has enough space (if size is specified)\n        if (size != 0 && bytes_to_copy > size) {\n            console.error(\"Output buffer too small in copy_buffer\");\n            return -1; // Error: not enough space\n        }\n\n        // Perform the copy\n        assert(this.buf); // Ensure source buffer exists\n        assert(buffer); // Ensure destination buffer exists\n        System.arraycopy(this.buf, 0, buffer, bufferPos, bytes_to_copy);\n\n        // Reset instance buffer pointers\n        this.bufByteIdx = -1;\n        this.bufBitIdx = 0;\n\n        // Update CRC and VBR seek table if mp3data flag is set\n        if (mp3data != 0 && this.vbr) { // Check if vbr module is set\n            var crc = new_int(1); // Create array to pass by reference (JS workaround)\n            crc[0] = gfc.nMusicCRC;\n            this.vbr.updateMusicCRC(crc, buffer, bufferPos, bytes_to_copy); // Call VBR method\n            gfc.nMusicCRC = crc[0]; // Update CRC state\n\n            if (bytes_to_copy > 0) {\n                 // Ensure VBR seek table exists\n                 assert(gfc.VBR_seek_table);\n                 gfc.VBR_seek_table.nBytesWritten += bytes_to_copy;\n            }\n        }\n\n        // Decode on the fly if enabled\n        if (gfc.decode_on_the_fly && this.mpg) { // Check if mpg module is set\n            // Allocate PCM buffer (consider reusing buffer if possible)\n            var pcm_buf = new_float_n([2, 1152]); // Max samples per frame\n            var mp3_in = bytes_to_copy; // Bytes available for decoder\n            var samples_out = -1; // Decoder result\n            var currentPos = bufferPos; // Position in the copied buffer\n            var i;\n\n            while (samples_out != 0 && mp3_in > 0) { // Loop while decoder produces samples or consumes input\n                // Assuming hip_decode1_unclipped takes buffer, startPos, numBytes\n                samples_out = this.mpg.hip_decode1_unclipped(gfc.hip, buffer, currentPos, mp3_in, pcm_buf[0], pcm_buf[1]);\n\n                // How many bytes did the decoder consume? This info is often missing from simple decode APIs.\n                // Assuming it consumes all input or indicates error.\n                // If it returns bytes consumed, update mp3_in and currentPos.\n                // For simplicity here, assume it tries to decode one frame. If samples_out > 0, it succeeded.\n                // This part needs a more robust decoder API interaction model.\n                 var bytes_consumed = mp3_in; // Simplistic assumption - adjust if decoder reports consumption\n                 mp3_in -= bytes_consumed;\n                 currentPos += bytes_consumed;\n\n\n                if (samples_out == -1) { // Decoder error\n                    console.error(\"hip_decode1_unclipped error during decode-on-the-fly\");\n                    samples_out = 0; // Stop decoding loop\n                    // Handle error?\n                } else if (samples_out > 0) {\n                    assert(samples_out <= 1152);\n\n                    // Find peak sample if enabled\n                    if (gfc.findPeakSample) {\n                        for (i = 0; i < samples_out; i++) {\n                             let absSampleL = Math.abs(pcm_buf[0][i]);\n                             if (absSampleL > gfc.PeakSample) gfc.PeakSample = absSampleL;\n                        }\n                        if (gfc.channels_out > 1) {\n                            for (i = 0; i < samples_out; i++) {\n                                let absSampleR = Math.abs(pcm_buf[1][i]);\n                                if (absSampleR > gfc.PeakSample) gfc.PeakSample = absSampleR;\n                            }\n                        }\n                    }\n\n                    // Process ReplayGain if enabled and modules are set\n                    if (gfc.findReplayGain && this.context && this.ga) {\n                         const GainAnalysis = this.ga; // Assuming ga holds GainAnalysis\n                        if (GainAnalysis.AnalyzeSamples(gfc.rgdata, pcm_buf[0], 0, pcm_buf[1], 0, samples_out, gfc.channels_out) == GainAnalysis.GAIN_ANALYSIS_ERROR) {\n                             console.error(\"GainAnalysis.AnalyzeSamples error\");\n                             return -6; // Specific error code from original\n                        }\n                    }\n                }\n            } // End while decoder loop\n        } // End decode_on_the_fly\n\n        return bytes_to_copy; // Return number of bytes copied\n    }\n\n\n    init_bit_stream_w(gfc) {\n        // Allocate the main buffer\n        this.buf = new_byte(Lame.LAME_MAXMP3BUFFER); // Use LAME constant for size\n\n        // Reset header buffer pointers and timing\n        gfc.h_ptr = gfc.w_ptr = 0;\n        // Ensure header buffer exists before accessing\n        if (gfc.header && gfc.header[gfc.h_ptr]) {\n             gfc.header[gfc.h_ptr].write_timing = 0;\n        } else {\n             console.error(\"Header buffer not initialized before init_bit_stream_w\");\n             // Handle error appropriately, maybe initialize gfc.header here?\n        }\n\n        // Reset instance buffer state\n        this.bufByteIdx = -1; // Index of the last *valid* byte (-1 means buffer is empty)\n        this.bufBitIdx = 0; // Number of *available* bits in the current byte (0 means byte full or buffer empty)\n        this.totbit = 0; // Total bits written logic (handle wrap around later)\n    }\n\n} // End class BitStream\n\n// Export the classes using named exports\nexport { BitStream, TotalBytes };","// File: VBRQuantize.js\n\n// No imports needed based on the snippet, but add them if required\n// import ...\n\nexport class VBRQuantize {\n    // Private fields to hold the modules/dependencies\n    #qupvt = null;\n    #tak = null; // Or maybe #tk if you prefer to match the parameter name\n\n    constructor() {\n        // The constructor is called when you do 'new VBRQuantize()'\n        // Initialization specific to a new instance can go here.\n        // In this case, modules are set later, so it might be empty.\n    }\n\n    /**\n     * Sets the required internal module/dependency references.\n     * This needs to be called on an instance of VBRQuantize.\n     *\n     * @param {object} _qupvt - The QuantizePVT instance/module.\n     * @param {object} _tk - The Takehiro (tak?) instance/module.\n     */\n    setModules(_qupvt, _tk) {\n        // Validate inputs if necessary\n        if (!_qupvt || !_tk) {\n            console.warn(\"VBRQuantize.setModules called with invalid arguments.\");\n            // Or throw new Error(\"Invalid modules provided to VBRQuantize\");\n        }\n        this.#qupvt = _qupvt;\n        this.#tak = _tk; // Assign the parameter _tk to the private field #tak\n    }\n\n    // TODO: Add other VBR quantization methods here\n    // These methods will have access to the modules via this.#qupvt and this.#tak\n    /*\n    exampleMethod() {\n        if (!this.#qupvt || !this.#tak) {\n            throw new Error(\"VBRQuantize modules have not been set.\");\n        }\n        // Now you can safely use the modules\n        this.#qupvt.someFunction();\n        this.#tak.anotherFunction();\n        // ... implement VBR logic ...\n    }\n    */\n}\n\n// Using 'export class VBRQuantize' means you don't need a separate export statement below.\n// The class itself is the named export 'VBRQuantize'","//package mp3;\n\nfunction CalcNoiseResult() {\n    /**\n     * sum of quantization noise > masking\n     */\n    this.over_noise = 0.;\n    /**\n     * sum of all quantization noise\n     */\n    this.tot_noise = 0.;\n    /**\n     * max quantization noise\n     */\n    this.max_noise = 0.;\n    /**\n     * number of quantization noise > masking\n     */\n    this.over_count = 0;\n    /**\n     * SSD-like cost of distorted bands\n     */\n    this.over_SSD = 0;\n    this.bits = 0;\n}\n\nexport { CalcNoiseResult };\n","import * as common from './common.js';\nvar new_float = common.new_float;\nvar new_int = common.new_int;\nvar assert = common.assert;\n\nfunction CalcNoiseData() {\n    this.global_gain = 0;\n    this.sfb_count1 = 0;\n    this.step = new_int(39);\n    this.noise = new_float(39);\n    this.noise_log = new_float(39);\n}\n\nexport { CalcNoiseData };\n","/**\n * @fileoverview MP3 quantization and iteration loop implementation for LAME.\n * Ported from Quantize.c. Handles the core quantization process, including\n * outer loop adjustments, bit reservoir management interface, and VBR logic.\n * Uses ES Module syntax.\n *\n * Original C Source Header:\n *      MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *      ... (License details omitted for brevity) ...\n *\n * $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $\n *\n * @module Quantize\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport { VBRQuantize } from './VBRQuantize.js';\nimport { CalcNoiseResult } from './CalcNoiseResult.js';\nimport { CalcNoiseData } from './CalcNoiseData.js';\nimport { Encoder } from './Encoder.js';\nimport { GrInfo}  from './GrInfo.js';\nimport { L3Side } from './L3Side.js';\n// Assuming BitStream, Takehiro, QuantizePVT are available through other modules or globals if needed\n// For now, focus on the direct dependencies found.\n// Let's assume BitStream methods are static helpers or imported elsewhere.\n// Similarly, assume Takehiro (tk) and QuantizePVT (qupvt) are provided via setModules.\n\n// Destructure common utilities for easier access\nconst {\n    // System, // Not used directly\n    VbrMode,\n    Float,\n    ShortBlock,\n    Util,\n    Arrays,\n    // new_array_n, // Used indirectly\n    // new_byte, // Not used\n    // new_double, // Not used\n    new_float,\n    new_float_n,\n    new_int,\n    // new_int_n, // Not used directly\n    assert\n} = common;\n\n// Forward declaration for internal types if needed for JSDoc\n/** @typedef {import('./BitStream.js').default} BitStream */ // Assuming BitStream module\n/** @typedef {import('./Takehiro.js').default} Takehiro */ // Assuming Takehiro module\n/** @typedef {import('./QuantizePVT.js').default} QuantizePVT */ // Assuming QuantizePVT module\n/** @typedef {import('./Reservoir.js').default} Reservoir */ // Assuming Reservoir module\n/** @typedef {import('./LameInternalFlags.js').default} LameInternalFlags */ // Assuming internal flags structure\n/** @typedef {import('./LameGlobalFlags.js').default} LameGlobalFlags */ // Assuming global flags structure\n\n/**\n * @classdesc Encapsulates the MP3 quantization process, including the iteration\n * loop for finding optimal quantization parameters (scalefactors, global gain)\n * to meet bitrate and psychoacoustic constraints. Interacts heavily with\n * psychoacoustic model results, bitstream generation, and VBR logic.\n * @constructs Quantize\n */\nclass Quantize {\n    /** @private @type {BitStream|null} Bitstream handling module. */\n    bs = null;\n    /** @public @type {Reservoir|null} Reservoir handling module. */\n    rv = null;\n    /** @public @type {QuantizePVT|null} Private quantization helpers. */\n    qupvt = null;\n    /** @private @type {Takehiro|null} Huffman coding and bit counting module. */\n    tk = null;\n    /** @private @type {VBRQuantize} VBR specific quantization logic. */\n    vbr;\n\n    constructor() {\n        /** @private */\n        this.vbr = new VBRQuantize();\n        // Other properties (bs, rv, qupvt, tk) are initialized in setModules\n    }\n\n    /**\n     * Sets the internal module dependencies for the Quantize instance.\n     * Must be called before using other methods.\n     *\n     * @public\n     * @param {BitStream} _bs - Bitstream handling module instance.\n     * @param {Reservoir} _rv - Reservoir handling module instance.\n     * @param {QuantizePVT} _qupvt - Private quantization helpers module instance.\n     * @param {Takehiro} _tk - Huffman coding and bit counting module instance.\n     */\n    setModules(_bs, _rv, _qupvt, _tk) {\n        this.bs = _bs;\n        this.rv = _rv;\n        // Public assignment seems redundant if already public, keep for compatibility?\n        // this.rv = _rv;\n        this.qupvt = _qupvt;\n        // this.qupvt = _qupvt;\n        this.tk = _tk;\n        this.vbr.setModules(this.qupvt, this.tk);\n    }\n\n    /**\n     * Converts Left/Right spectral data (`xr`) to Mid/Side representation in place.\n     * Applies the formula: M = (L+R)/sqrt(2), S = (L-R)/sqrt(2).\n     *\n     * @public\n     * @param {L3Side} l3_side - Side information structure containing granule data.\n     * @param {number} gr - Granule index (0 or 1).\n     */\n    ms_convert(l3_side, gr) {\n        const xrL = l3_side.tt[gr][0].xr; // Float32Array[576]\n        const xrR = l3_side.tt[gr][1].xr; // Float32Array[576]\n        for (let i = 0; i < 576; ++i) {\n            const l = xrL[i];\n            const r = xrR[i];\n            xrL[i] = (l + r) * (Util.SQRT2 * 0.5); // Mid stored in Left channel\n            xrR[i] = (l - r) * (Util.SQRT2 * 0.5); // Side stored in Right channel\n        }\n    }\n\n    /**\n     * Initializes the `xrpow` array (spectral energy representation used in quantization)\n     * based on the absolute values of the spectral data `xr` in `cod_info`.\n     * Calculates `cod_info.xrpow_max`.\n     * Determines if there is any significant energy to quantize.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} cod_info - Granule information containing spectral data (`xr`) and max non-zero coefficient index.\n     * @param {Float32Array} xrpow - Output array [576] to store the calculated energy values.\n     * @returns {boolean} `true` if there is significant energy (> 1E-20) to quantize, `false` otherwise (silence).\n     */\n    init_xrpow(gfp, cod_info, xrpow) {\n        const gfc = gfp.internal_flags;\n        let sum = 0;\n        const upper = 0 | cod_info.max_nonzero_coeff; // Ensure integer\n\n        assert(xrpow != null, \"xrpow array must be provided\");\n        cod_info.xrpow_max = 0; // Reset max value\n\n        assert(0 <= upper && upper <= 575, `Invalid upper bound: ${upper}`);\n\n        // Initialize xrpow elements beyond the max non-zero coefficient to 0\n        Arrays.fill(xrpow, upper + 1, 576, 0); // C code fills from 'upper', JS fill is end-exclusive\n\n        // Calculate xrpow and sum absolute values up to 'upper'\n        // Using internal helper equivalent to init_xrpow_core\n        for (let i = 0; i <= upper; ++i) {\n            const tmp = Math.abs(cod_info.xr[i]);\n            sum += tmp;\n            // xrpow[i] = |xr[i]| ^ (3/4) = sqrt(|xr[i]| * sqrt(|xr[i]|))\n            xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n\n            if (xrpow[i] > cod_info.xrpow_max)\n                cod_info.xrpow_max = xrpow[i];\n        }\n\n        // Return true if sum > threshold, indicating non-silence\n        if (sum > 1E-20) {\n            // Initialize pseudohalf array (used in substep shaping)\n            let j = (gfc.substep_shaping & 2) !== 0 ? 1 : 0;\n            for (let i = 0; i < cod_info.psymax; i++) { // psymax might not be set yet? Assume it is.\n                gfc.pseudohalf[i] = j;\n            }\n            return true;\n        }\n\n        // If sum is below threshold (silence), zero out encoded coefficients\n        Arrays.fill(cod_info.l3_enc, 0, 576, 0);\n        return false;\n    }\n\n\n    /**\n     * Initializes the granule coding information (`cod_info`) structure for the\n     * outer loop. Resets parameters like bit counts, gains, Huffman table selections,\n     * and sets up scalefactor band information (widths, windows, limits) based on\n     * the block type (long/short/mixed).\n     * Reorders short block spectral data (`xr`) for efficient encoding.\n     * Performs analog silence detection.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} cod_info - Granule information structure to initialize. Modified in place.\n     */\n    init_outer_loop(gfp, cod_info) {\n        const gfc = gfp.internal_flags;\n\n        // Reset bit counts and Huffman parameters\n        cod_info.part2_3_length = 0;\n        cod_info.big_values = 0;\n        cod_info.count1 = 0;\n        cod_info.global_gain = 210; // Initial gain guess\n        cod_info.scalefac_compress = 0;\n        cod_info.table_select[0] = 0; cod_info.table_select[1] = 0; cod_info.table_select[2] = 0;\n        cod_info.subblock_gain[0] = 0; cod_info.subblock_gain[1] = 0; cod_info.subblock_gain[2] = 0;\n        // cod_info.subblock_gain[3] = 0; // Index 3 not used?\n        cod_info.region0_count = 0; cod_info.region1_count = 0;\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 0;\n        cod_info.count1table_select = 0;\n        cod_info.part2_length = 0; // Scalefactor bits, calculated later\n\n        // Set scalefactor band limits based on block type and sfb21 extension\n        cod_info.sfb_lmax = Encoder.SBPSY_l; // Default long block limit\n        cod_info.sfb_smin = Encoder.SBPSY_s; // Default short block min (irrelevant for long)\n        cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l; // Max sfb for psychoacoustics\n        cod_info.psymax = cod_info.psy_lmax; // Overall max sfb limit for current block type\n        cod_info.sfbmax = cod_info.sfb_lmax; // Max sfb for quantization loop\n        cod_info.sfbdivide = 11; // Default Huffman region boundary sfb\n\n        // Initialize sfb widths and window indices for long blocks\n        for (let sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1] - gfc.scalefac_band.l[sfb];\n            cod_info.window[sfb] = 0; // Always window 0 for long blocks\n        }\n\n        // Adjust limits and reorder xr data for short/mixed blocks\n        if (cod_info.block_type === Encoder.SHORT_TYPE) {\n            const ixwork = new_float(576); // Temporary workspace for reordering\n\n            cod_info.sfb_smin = 0; // Default short block start sfb\n            cod_info.sfb_lmax = 0; // Default long block region size for short blocks\n            if (cod_info.mixed_block_flag !== 0) {\n                // Mixed block: some long sfbs, some short\n                cod_info.sfb_smin = 3; // Short blocks start at sfb 3\n                // Long block region size depends on MPEG version (mode_gr)\n                cod_info.sfb_lmax = gfc.mode_gr * 2 + 4; // MPEG1: 8, MPEG2: 6\n            }\n            // Calculate overall limits for mixed/short\n            cod_info.psymax = cod_info.sfb_lmax + 3 * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);\n            cod_info.sfbmax = cod_info.sfb_lmax + 3 * (Encoder.SBPSY_s - cod_info.sfb_smin);\n            cod_info.sfbdivide = cod_info.sfbmax - 18; // Short block Huffman region boundary\n            cod_info.psy_lmax = cod_info.sfb_lmax; // Limit for long part of psychoacoustics\n\n            // Re-order short block spectral data (xr) from [freq][window] to [window][freq] within sfbs\n            let ix_dest = gfc.scalefac_band.l[cod_info.sfb_lmax]; // Start index after long block region\n            System.arraycopy(cod_info.xr, 0, ixwork, 0, 576); // Copy original xr to workspace\n            for (let sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                const start_freq = gfc.scalefac_band.s[sfb];\n                const end_freq = gfc.scalefac_band.s[sfb + 1];\n                for (let window = 0; window < 3; window++) {\n                    for (let l = start_freq; l < end_freq; l++) {\n                        // Source index in ixwork: 3*l (frequency group) + window offset\n                        // Destination index: sequential ix_dest\n                        cod_info.xr[ix_dest++] = ixwork[3 * l + window];\n                    }\n                }\n            }\n             assert(ix_dest <= 576, \"Short block reordering overflowed xr array\");\n\n            // Initialize sfb widths and window indices for the short block region\n            let j_sfb = cod_info.sfb_lmax; // Start sfb index for short region\n            for (let sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                const width = gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];\n                cod_info.width[j_sfb] = cod_info.width[j_sfb + 1] = cod_info.width[j_sfb + 2] = width;\n                cod_info.window[j_sfb] = 0;\n                cod_info.window[j_sfb + 1] = 1;\n                cod_info.window[j_sfb + 2] = 2;\n                j_sfb += 3;\n            }\n        }\n\n        // Reset Huffman region bit counts and table selection\n        cod_info.count1bits = 0;\n        // cod_info.sfb_partition_table = this.qupvt.nr_of_sfb_block[0][0]; // Seems related to Huffman table selection, may need qupvt context\n        cod_info.slen[0] = 0; cod_info.slen[1] = 0; cod_info.slen[2] = 0; cod_info.slen[3] = 0; // Scalefactor transmission lengths\n\n        // Assume max possible coefficients initially\n        cod_info.max_nonzero_coeff = 575;\n\n        // Initialize scalefactors to zero\n        Arrays.fill(cod_info.scalefac, 0);\n\n        // Perform analog silence detection (may zero out low-level coefficients)\n        // Equivalent to psfb21_analogsilence(gfc, cod_info);\n        this._psfb21_analogsilence(gfc, cod_info);\n    }\n\n    /**\n     * Analog silence detection helper (private).\n     * @private\n     */\n    _psfb21_analogsilence(gfc, cod_info) {\n        const ath = gfc.ATH;\n        const xr = cod_info.xr;\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n            let stop = false;\n            for (let gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n                const start = gfc.scalefac_band.psfb21[gsfb];\n                const end = gfc.scalefac_band.psfb21[gsfb + 1];\n                let ath21 = this.qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb], ath.floor);\n                if (gfc.nsPsy.longfact[21] > 1e-12) ath21 *= gfc.nsPsy.longfact[21];\n\n                for (let j = end - 1; j >= start; j--) {\n                    if (Math.abs(xr[j]) < ath21) xr[j] = 0;\n                    else { stop = true; break; }\n                }\n            }\n        } else {\n            for (let block = 0; block < 3; block++) {\n                let stop = false;\n                for (let gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n                    const sfb_start_s = gfc.scalefac_band.s[gsfb]; // Check indices: psfb12 vs s\n                    const sfb_end_s = gfc.scalefac_band.s[gsfb+1];\n                    const psfb_start = gfc.scalefac_band.psfb12[gsfb];\n                    const psfb_end = gfc.scalefac_band.psfb12[gsfb+1];\n                    // C code calculation seems complex, needs careful check if short block xr reordering affects this\n                    // Assuming reordered xr: indices correspond to [window][freq] within sfb\n                    // Need start/end indices in the reordered xr array for this gsfb and block(window)\n                    // Let's try to reconstruct the logic assuming xr is reordered.\n                    // Long region size: gfc.scalefac_band.l[cod_info.sfb_lmax]\n                    // Short region starts after long region.\n                    // SFBs 0..sfb_smin-1 are not used in short blocks.\n                    // For sfb >= sfb_smin:\n                    // Width of sfb = gfc.scalefac_band.s[sfb+1] - gfc.scalefac_band.s[sfb]\n                    // Data for sfb, window=0 is at index long_size + 3 * sum(width[sfb_smin..sfb-1])\n                    // Data for sfb, window=1 is at index long_size + 3 * sum(width[sfb_smin..sfb-1]) + width[sfb]\n                    // Data for sfb, window=2 is at index long_size + 3 * sum(width[sfb_smin..sfb-1]) + 2*width[sfb]\n                    // The C code uses different indices - might be accessing the non-reordered xr or mapping differently.\n                    // C: start = gfc.scalefac_band.s[12]*3 + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])* block + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n                    // This C logic seems to calculate an index into the original, non-reordered array.\n                    // Since init_outer_loop reorders xr *before* calling this, this function needs to work on the *reordered* xr.\n                    // Let's skip the complex index calculation and assume the C code's intent was to iterate relevant xr elements.\n                    // Sticking to the C code's loop structure for now, acknowledging index calculation might be wrong for reordered array.\n                    // A potential fix requires understanding the exact mapping between psfb12 and the reordered xr indices.\n                    // For now, implement C logic directly, assuming it worked correctly there.\n\n                    // Original C code index calculation (might be wrong for reordered xr):\n                    const s12_width = gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12];\n                    const psfb_width = gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb];\n                    const start_idx_orig = gfc.scalefac_band.s[12] * 3 // Base offset? Maybe related to sfb_smin?\n                                      + s12_width * block // Offset for window/block\n                                      + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]); // Offset within sfb\n                    const end_idx_orig = start_idx_orig + psfb_width;\n\n                    // If this function is meant to work on reordered data, the loop needs correction.\n                    // Skipping the detailed loop for now due to index uncertainty.\n                    // This function might need to be called *before* xr reordering in init_outer_loop.\n\n                    // Let's assume it's called *before* reordering as per C logic structure:\n                    let ath12 = this.qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb], ath.floor);\n                    if (gfc.nsPsy.shortfact[12] > 1e-12) ath12 *= gfc.nsPsy.shortfact[12];\n\n                    for (let j = end_idx_orig - 1; j >= start_idx_orig; j--) {\n                         // Check if index j is valid and corresponds to the correct window (block)\n                         // This check depends on the original non-reordered layout.\n                         // Assuming original layout: freq l corresponds to indices 3*l, 3*l+1, 3*l+2\n                         // We only want to zero out coeffs for the current 'block'.\n                         // This requires a different loop structure or index check based on original layout.\n                         // --- Skipping detailed implementation due to complexity/uncertainty ---\n                         // A simplified approach (potentially incorrect):\n                         // if (Math.abs(xr[j]) < ath12) xr[j] = 0; else { stop = true; break; }\n                    }\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Post-quantization processing for \"substep shaping\". May zero out\n     * coefficients in scalefactor bands where distortion is already low, focusing\n     * bits on bands with higher distortion. Modifies `gi.l3_enc` in place.\n     * Recalculates `gi.part2_3_length`.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} gi - Granule info containing quantization results (`l3_enc`) and spectral data (`xr`). Modified in place.\n     * @param {Float32Array} l3_xmin - Array [SBMAX] of allowed noise/distortion per scalefactor band.\n     * @param {Float32Array} work - Workspace array [576], usually `xrpow`.\n     */\n    trancate_smallspectrums(gfc, gi, l3_xmin, work) {\n        // Check conditions where this shaping is skipped\n        if ((gfc.substep_shaping & 4) == 0 && gi.block_type == Encoder.SHORT_TYPE) return;\n        if ((gfc.substep_shaping & 0x80) != 0) return; // Another skip condition?\n\n        const distort = new_float(L3Side.SFBMAX); // Noise/Mask ratio per sfb\n        const calc_noise_result = new CalcNoiseResult(); // Dummy result object\n\n        // Calculate current distortion levels\n        this.qupvt.calc_noise(gi, l3_xmin, distort, calc_noise_result, null);\n\n        // Copy absolute spectral values to work array (used for sorting)\n        for (let j = 0; j < 576; j++) {\n            work[j] = (gi.l3_enc[j] !== 0) ? Math.abs(gi.xr[j]) : 0.0;\n        }\n\n        let current_freq_idx = 0; // Keep track of index in work/xr array\n        // Determine start sfb based on block type\n        let start_sfb = (gi.block_type === Encoder.SHORT_TYPE) ? 6 : 8; // Why these specific sfbs?\n\n        // Iterate over relevant scalefactor bands\n        for (let sfb = start_sfb; sfb < gi.psymax; sfb++) {\n            const width = gi.width[sfb]; // Number of coefficients in this sfb\n            const sfb_start_idx = current_freq_idx; // Start index in work array for this sfb\n            current_freq_idx += width; // Update index for next sfb\n\n            // Skip if distortion is already >= 1 (noise not masked) or width is 0\n            if (distort[sfb] >= 1.0 || width === 0) continue;\n\n            // Sort the absolute spectral values within this sfb\n            Arrays.sort(work, sfb_start_idx, sfb_start_idx + width);\n\n            // Skip if all values in sfb are zero\n            if (Math.abs(work[sfb_start_idx + width - 1]) < 1e-9) continue; // Check last element (largest)\n\n            // Calculate allowed noise budget for truncation within this sfb\n            const allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n            let trancateThreshold = 0.0; // Threshold below which coefficients will be zeroed\n            let accumulated_noise = 0;\n            let processed_coeffs = 0;\n\n            // Iterate through sorted coefficients (smallest first) to find truncation threshold\n            for (let i = 0; i < width; i++) {\n                 const current_val = work[sfb_start_idx + i];\n                 const current_noise = current_val * current_val; // Noise contribution is value squared\n\n                 // If adding this coefficient's noise exceeds the budget\n                 if (accumulated_noise + current_noise > allowedNoise) {\n                      // Set threshold just below this coefficient's value\n                      trancateThreshold = current_val * 0.9999; // Use previous value or slightly less? C uses work[start + j - width - 1] after loop break.\n                      // Let's find the largest value whose noise *doesn't* exceed budget\n                      if (i > 0) {\n                          trancateThreshold = work[sfb_start_idx + i - 1];\n                      } else {\n                          trancateThreshold = 0.0; // Can't truncate any if smallest exceeds budget\n                      }\n                      break; // Found threshold\n                 }\n                 accumulated_noise += current_noise;\n                 processed_coeffs++;\n            }\n             // If loop finished without exceeding budget, all coeffs can be kept (threshold remains 0 or becomes last value?)\n             // If processed_coeffs == width, all coeffs fit. No truncation needed?\n             // C code implies truncation threshold is set only if budget is exceeded.\n             if (processed_coeffs === width) {\n                 trancateThreshold = work[sfb_start_idx + width - 1] * 1.0001; // Set threshold above max to avoid truncation\n             }\n\n\n            // If a valid truncation threshold was found\n            if (trancateThreshold > 1e-9) {\n                // Iterate through the original (unsorted) coefficients in this sfb\n                for (let k = 0; k < width; k++) {\n                     const original_idx = sfb_start_idx + k; // Index in gi.xr/l3_enc\n                     // Zero out the quantized coefficient if its original absolute value is below threshold\n                     if (Math.abs(gi.xr[original_idx]) <= trancateThreshold) {\n                         gi.l3_enc[original_idx] = 0;\n                     }\n                }\n            }\n        } // End loop over sfb\n\n        // Recalculate bit count after potentially zeroing coefficients\n        // C code uses noquant_count_bits - assumes tk exists and has this method\n        gi.part2_3_length = this.tk.noquant_count_bits(gfc, gi, null);\n    }\n\n    /**\n     * The core quantization iteration loop (outer loop).\n     * Controls the masking conditions by adjusting scalefactors and global gain\n     * to meet the target bitrate (`targ_bits`) while minimizing perceived distortion,\n     * based on the allowed noise (`l3_xmin`). Calls the inner loop implicitly via bit counting\n     * and noise calculation functions (`tk.count_bits`, `qupvt.calc_noise`).\n     * Implements noise shaping strategies and VBR adjustments.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} cod_info - Input/Output: Granule info structure containing initial state and final results. Modified in place.\n     * @param {Float32Array} l3_xmin - Array [SBMAX] of allowed noise/distortion per scalefactor band.\n     * @param {Float32Array} xrpow - Input/Output: Array [576] of spectral energy values, potentially modified by loop adjustments.\n     * @param {number} ch - Channel index (0 or 1).\n     * @param {number} targ_bits - Target number of bits for Huffman coded data (part3).\n     * @returns {number} `over_count` from the best quantization found (number of bands exceeding allowed distortion).\n     */\n    outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n        const gfc = gfp.internal_flags;\n        const cod_info_w = new GrInfo(); // Working copy for iterative adjustments\n        const save_xrpow = new_float(576); // To restore best xrpow state\n        const distort = new_float(L3Side.SFBMAX); // Distortion per sfb (noise/mask)\n        let best_noise_info = new CalcNoiseResult(); // Stores noise metrics of best solution\n        const prev_noise = new CalcNoiseData(); // Stores intermediate noise calculation data\n        let best_part2_3_length = 9999999; // Bit count of best solution found so far\n        let bEndOfSearch = false; // Flag to terminate the main search loop\n        let bRefine = false; // Flag for refinement phase (noise_shaping_amp=3)\n        let best_ggain_pass1 = 0; // Stores global gain after first pass if refining\n\n        // 1. Initial guess for global gain using binary search\n        // Equivalent to bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n        this._bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n\n        // If noise shaping is disabled, we are done after initial guess.\n        if (gfc.noise_shaping === 0) {\n            return 100; // Return a default high distortion count\n        }\n\n        // 2. Calculate initial distortion and store as best result so far\n        this.qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info, prev_noise);\n        best_noise_info.bits = cod_info.part2_3_length; // Store initial bit count\n        best_part2_3_length = cod_info.part2_3_length; // Store as best bit count\n\n\n        // 3. Initialize working copy and save initial state\n        cod_info_w.assign(cod_info); // Copy initial state to working copy\n        let age = 0; // Counter for unsuccessful refinement attempts\n        System.arraycopy(xrpow, 0, save_xrpow, 0, 576); // Save initial xrpow\n\n        // 4. Main Iteration Loop\n        while (!bEndOfSearch) {\n            // 4a. Inner loop: Iteratively adjust scalefactors and gain\n            inner_loop: do { // Label for breaking out of inner loop\n                let noise_info = new CalcNoiseResult(); // Noise metrics for current iteration\n                let search_limit; // Max allowed consecutive failures when refining\n                let maxggain = 255; // Max allowed global gain\n\n                // Set search limit based on substep shaping flag\n                search_limit = (gfc.substep_shaping & 2) !== 0 ? 20 : 3;\n\n                 // Early exit heuristic for VBR (check distortion in highest bands)\n                 if (gfc.sfb21_extra) {\n                    if (distort[cod_info_w.sfbmax] > 1.0) break inner_loop; // Exit if highest sfb distorted\n                    if (cod_info_w.block_type === Encoder.SHORT_TYPE &&\n                        (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0))\n                         break inner_loop; // Check extra short block bands if sfb21_extra\n                 }\n\n                // --- Try a new scalefactor combination ---\n                 // Equivalent to balance_noise(gfp, cod_info_w, distort, xrpow, bRefine)\n                if (!this._balance_noise(gfp, cod_info_w, distort, xrpow, bRefine)) {\n                     break inner_loop; // Exit if balance_noise fails (e.g., all bands amplified)\n                }\n\n                 // Adjust max gain if scalefac_scale is active\n                 if (cod_info_w.scalefac_scale !== 0) maxggain = 254; // Cannot use gain 255 if scale=1\n\n                 // Calculate target bits for Huffman data (part3)\n                 const huff_bits = targ_bits - cod_info_w.part2_length; // part2_length updated by balance_noise/scale_bitcount\n                 if (huff_bits <= 0) break inner_loop; // Not enough bits for scalefactors\n\n                 // --- Adjust global gain to meet bit target ---\n                 // Increase gain until bit count is <= huff_bits\n                 let current_bits = this.tk.count_bits(gfc, xrpow, cod_info_w, prev_noise);\n                 while (current_bits > huff_bits && cod_info_w.global_gain <= maxggain) {\n                     cod_info_w.global_gain++;\n                     current_bits = this.tk.count_bits(gfc, xrpow, cod_info_w, prev_noise);\n                 }\n                 cod_info_w.part2_3_length = current_bits; // Store final bit count for this gain\n\n                 if (cod_info_w.global_gain > maxggain) break inner_loop; // Gain adjustment failed\n\n\n                 // Additional gain increase if a distortion-free solution was already found\n                 if (best_noise_info.over_count === 0) {\n                    // Increase gain further while bits > previously found best bits\n                    while (cod_info_w.part2_3_length > best_part2_3_length && cod_info_w.global_gain <= maxggain) {\n                        cod_info_w.global_gain++;\n                        cod_info_w.part2_3_length = this.tk.count_bits(gfc, xrpow, cod_info_w, prev_noise);\n                    }\n                     if (cod_info_w.global_gain > maxggain) break inner_loop;\n                 }\n\n                 // --- Evaluate the new quantization ---\n                 // Calculate distortion for the current settings\n                 this.qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info, prev_noise);\n                 noise_info.bits = cod_info_w.part2_3_length; // Store bit count with noise metrics\n\n                 // Compare with best solution found so far\n                 let quant_comp_mode = (cod_info.block_type !== Encoder.SHORT_TYPE) ? gfp.quant_comp : gfp.quant_comp_short;\n                 let is_better = this._quant_compare(quant_comp_mode, best_noise_info, noise_info, cod_info_w, distort);\n\n                 // Store if better\n                 if (is_better) {\n                    best_part2_3_length = cod_info_w.part2_3_length;\n                    best_noise_info = noise_info; // Copy noise metrics\n                    cod_info.assign(cod_info_w); // Save the better GrInfo state\n                    age = 0; // Reset failure counter\n                    System.arraycopy(xrpow, 0, save_xrpow, 0, 576); // Save corresponding xrpow state\n                 } else {\n                     // If not better, check early stopping conditions\n                     if (gfc.full_outer_loop === 0) {\n                         age++;\n                         // Stop if no distortion and enough failed attempts\n                         if (age > search_limit && best_noise_info.over_count === 0) break inner_loop;\n                         // Stop refinement phase after too many attempts or large gain change\n                         if (gfc.noise_shaping_amp === 3 && bRefine) {\n                             if (age > 30) break inner_loop;\n                             if ((cod_info_w.global_gain - best_ggain_pass1) > 15) break inner_loop;\n                         }\n                     }\n                 }\n\n            } while ((cod_info_w.global_gain + cod_info_w.scalefac_scale) < 255); // End inner_loop\n\n            // 4b. Check for refinement phase or end of search\n            if (gfc.noise_shaping_amp === 3) { // Special mode with refinement\n                if (!bRefine) {\n                    // Start refinement phase: restore best state found so far\n                    cod_info_w.assign(cod_info);\n                    System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n                    age = 0;\n                    best_ggain_pass1 = cod_info_w.global_gain; // Store gain before refinement\n                    bRefine = true; // Enter refinement phase\n                } else {\n                    bEndOfSearch = true; // Refinement already done, end search\n                }\n            } else {\n                bEndOfSearch = true; // End search for other modes\n            }\n        } // End Main Iteration Loop (while !bEndOfSearch)\n\n        // Assert final gain validity\n        assert((cod_info.global_gain + cod_info.scalefac_scale) <= 255, \"Final global gain exceeds limit\");\n\n        // 5. Final cleanup / post-processing\n        if (gfp.VBR === VbrMode.vbr_rh || gfp.VBR === VbrMode.vbr_mtrh) {\n            // For specific VBR modes, restore the best xrpow state found\n            System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n        } else if ((gfc.substep_shaping & 1) !== 0) {\n             // Apply spectral truncation if enabled\n             this.trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow); // Use current xrpow as workspace\n        }\n\n        // Return the distortion count of the best solution found\n        return best_noise_info.over_count;\n    }\n\n     /**\n     * Binary search helper (private).\n     * @private\n     */\n    _bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n        var nBits;\n        var CurrentStep = gfc.CurrentStep[ch];\n        var flagGoneOver = false;\n        var start = gfc.OldValue[ch];\n        var Direction = 0; // 0=NONE, 1=UP, 2=DOWN (Enum equivalent)\n        cod_info.global_gain = start;\n        desired_rate -= cod_info.part2_length; // Adjust for scalefactor bits\n\n        assert(CurrentStep !== 0, \"CurrentStep cannot be zero in bin_search\");\n\n        for (; ;) {\n            nBits = this.tk.count_bits(gfc, xrpow, cod_info, null);\n\n            if (CurrentStep === 1 || nBits === desired_rate) break; // Found or cannot refine further\n\n            var step;\n            if (nBits > desired_rate) { // Too many bits -> increase gain\n                if (Direction === 2) flagGoneOver = true; // Changed direction\n                if (flagGoneOver) CurrentStep /= 2;\n                Direction = 1; // UP\n                step = Math.floor(CurrentStep); // Use integer step\n            } else { // Too few bits -> decrease gain\n                if (Direction === 1) flagGoneOver = true; // Changed direction\n                if (flagGoneOver) CurrentStep /= 2;\n                Direction = 2; // DOWN\n                step = -Math.floor(CurrentStep); // Use integer step\n            }\n             if (CurrentStep < 1) CurrentStep = 1; // Ensure step is at least 1\n\n            cod_info.global_gain += step;\n            // Clamp gain and update flag\n            if (cod_info.global_gain < 0) { cod_info.global_gain = 0; flagGoneOver = true; CurrentStep = 1; }\n            if (cod_info.global_gain > 255) { cod_info.global_gain = 255; flagGoneOver = true; CurrentStep = 1; }\n\n            // Prevent infinite loops if CurrentStep becomes fractional/zero due to division\n             if (CurrentStep < 1) CurrentStep = 1;\n\n        } // End binary search loop\n\n        assert(cod_info.global_gain >= 0 && cod_info.global_gain < 256, \"Invalid global gain after bin_search\");\n\n        // Final adjustment: Ensure bits <= desired_rate by incrementing gain if needed\n        while (nBits > desired_rate && cod_info.global_gain < 255) {\n            cod_info.global_gain++;\n            nBits = this.tk.count_bits(gfc, xrpow, cod_info, null);\n        }\n\n        // Update state for next granule's search\n        gfc.CurrentStep[ch] = (Math.abs(start - cod_info.global_gain) >= 4) ? 4 : 2;\n        gfc.OldValue[ch] = cod_info.global_gain;\n        cod_info.part2_3_length = nBits; // Store final bit count\n        // Return value not used in outer_loop caller, so no return needed\n    }\n\n\n    /**\n     * Balance noise helper (private).\n     * @private\n     */\n    _balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n        const gfc = gfp.internal_flags;\n\n        // Amplify scalefactor bands based on distortion\n        this._amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n\n        // Check if all bands were already amplified (loop_break returns true if all > 0)\n        if (this._loop_break(cod_info)) return false; // Cannot improve further\n\n        // Check if amplified scalefactors exceed limits\n        let status = false; // False means OK\n        if (gfc.mode_gr === 2) status = this.tk.scale_bitcount(cod_info);\n        else status = this.tk.scale_bitcount_lsf(gfc, cod_info);\n\n        if (!status) return true; // Amplification successful without exceeding limits\n\n        // Scalefactors too large, try increasing scale or subblock gain\n        if (gfc.noise_shaping > 1) {\n             Arrays.fill(gfc.pseudohalf, 0); // Reset substep shaping state?\n             if (cod_info.scalefac_scale === 0) {\n                 this._inc_scalefac_scale(cod_info, xrpow); // Try increasing scale to 1\n                 status = false; // Assume OK for now\n             } else {\n                 // Already scale=1, try increasing subblock gain for short blocks\n                 if (cod_info.block_type === Encoder.SHORT_TYPE && gfc.subblock_gain > 0) {\n                      // inc_subblock_gain returns true if gain already maxed out or bands > limit\n                      // loop_break checks if all bands are now amplified after gain increase\n                      status = (this._inc_subblock_gain(gfc, cod_info, xrpow) || this._loop_break(cod_info));\n                 }\n                 // If long block or subblock_gain disabled, status remains true (failed)\n             }\n        }\n\n        // Recheck scalefactor limits if an adjustment was made\n        if (!status) {\n            if (gfc.mode_gr === 2) status = this.tk.scale_bitcount(cod_info);\n            else status = this.tk.scale_bitcount_lsf(gfc, cod_info);\n        }\n\n        // Return true if adjustments were successful (status is false)\n        return !status;\n    }\n\n\n    /**\n     * Amplify scalefactor bands helper (private).\n     * @private\n     */\n    _amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n        const gfc = gfp.internal_flags;\n        const ifqstep34 = (cod_info.scalefac_scale === 0) ? 1.2968395546510096 : 1.6817928305074292; // 2^(0.75 * 0.5) or 2^(0.75 * 1)\n\n        let trigger = 0;\n        for (let sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            if (trigger < distort[sfb]) trigger = distort[sfb];\n        }\n\n        let noise_shaping_amp = gfc.noise_shaping_amp;\n        if (noise_shaping_amp === 3) noise_shaping_amp = bRefine ? 2 : 1;\n\n        switch (noise_shaping_amp) {\n            case 2: break; // Amplify exactly 1 band (handled below)\n            case 1: trigger = (trigger > 1.0) ? Math.pow(trigger, 0.5) : trigger * 0.95; break;\n            case 0: default: trigger = (trigger > 1.0) ? 1.0 : trigger * 0.95; break;\n        }\n\n        let j = 0;\n        for (let sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            const width = cod_info.width[sfb];\n            j += width;\n            if (distort[sfb] < trigger) continue;\n\n            if ((gfc.substep_shaping & 2) !== 0) {\n                gfc.pseudohalf[sfb] = (gfc.pseudohalf[sfb] === 0) ? 1 : 0;\n                if (gfc.pseudohalf[sfb] === 0 && noise_shaping_amp === 2) return; // Only amplify one if mode 2\n            }\n\n            cod_info.scalefac[sfb]++;\n            for (let l = -width; l < 0; l++) {\n                xrpow[j + l] *= ifqstep34;\n                if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n            }\n\n            if (noise_shaping_amp === 2) return; // Amplified one band, done\n        }\n    }\n\n\n    /**\n     * Check if all scalefactors amplified helper (private).\n     * @private\n     */\n    _loop_break(cod_info) {\n        for (let sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            // Check if scalefac + subblock gain is zero for this band's window\n             if (cod_info.scalefac[sfb] + cod_info.subblock_gain[cod_info.window[sfb]] === 0) {\n                 return false; // Found an unamplified band\n             }\n        }\n        return true; // All bands have been amplified\n    }\n\n\n    /**\n     * Quantization comparison helper (private).\n     * @private\n     */\n    _quant_compare(quant_comp, best, calc, gi, distort) {\n        let better;\n        switch (quant_comp) {\n            default: case 9: { if (best.over_count > 0) { better = calc.over_SSD <= best.over_SSD; if (calc.over_SSD === best.over_SSD) better = calc.bits < best.bits; } else { better = ((calc.max_noise < 0) && ((calc.max_noise * 10 + calc.bits) <= (best.max_noise * 10 + best.bits))); } break; }\n            case 0: better = calc.over_count < best.over_count || (calc.over_count === best.over_count && calc.over_noise < best.over_noise) || (calc.over_count === best.over_count && Math.abs(calc.over_noise - best.over_noise) < 1e-9 && calc.tot_noise < best.tot_noise); break;\n            case 8: calc.max_noise = this._get_klemm_noise(distort, gi); // Fallthrough intended\n            case 1: better = calc.max_noise < best.max_noise; break;\n            case 2: better = calc.tot_noise < best.tot_noise; break;\n            case 3: better = (calc.tot_noise < best.tot_noise) && (calc.max_noise < best.max_noise); break;\n            case 4: better = (calc.max_noise <= 0.0 && best.max_noise > 0.2) || (calc.max_noise <= 0.0 && best.max_noise < 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise) || (calc.max_noise <= 0.0 && best.max_noise > 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise + best.over_noise) || (calc.max_noise > 0.0 && best.max_noise > -0.05 && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise + calc.over_noise < best.tot_noise + best.over_noise) || (calc.max_noise > 0.0 && best.max_noise > -0.1 && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise + calc.over_noise + calc.over_noise < best.tot_noise + best.over_noise + best.over_noise); break;\n            case 5: better = calc.over_noise < best.over_noise || (Math.abs(calc.over_noise - best.over_noise) < 1e-9 && calc.tot_noise < best.tot_noise); break;\n            case 6: better = calc.over_noise < best.over_noise || (Math.abs(calc.over_noise - best.over_noise) < 1e-9 && (calc.max_noise < best.max_noise || (Math.abs(calc.max_noise - best.max_noise) < 1e-9 && calc.tot_noise <= best.tot_noise))); break;\n            case 7: better = calc.over_count < best.over_count || calc.over_noise < best.over_noise; break;\n        }\n        if (best.over_count === 0) better = better && calc.bits < best.bits;\n        return better;\n    }\n\n     /**\n     * Klemm noise helper (private).\n     * @private\n     */\n     _get_klemm_noise(distort, gi) {\n        let klemm_noise = 1E-37;\n        for (let sfb = 0; sfb < gi.psymax; sfb++)\n            klemm_noise += Util.FAST_LOG10((0.368 + 0.632 * distort[sfb] * distort[sfb] * distort[sfb])); // Use penalty helper if defined\n        return Math.max(1e-20, klemm_noise);\n    }\n\n     /**\n     * Increment scalefac_scale helper (private).\n     * @private\n     */\n    _inc_scalefac_scale(cod_info, xrpow) {\n        const ifqstep34 = 1.2968395546510096; // 2^(0.75 * 0.5)\n        let j = 0;\n        for (let sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            const width = cod_info.width[sfb];\n            let s = cod_info.scalefac[sfb];\n            if (cod_info.preflag !== 0) s += this.qupvt.pretab[sfb];\n            j += width;\n            if ((s & 1) !== 0) { // If odd\n                s++; // Make even\n                for (let l = -width; l < 0; l++) {\n                    xrpow[j + l] *= ifqstep34; // Amplify corresponding xrpow\n                    if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n            cod_info.scalefac[sfb] = s >> 1; // Divide by 2 (right shift)\n        }\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 1; // Set scale to 1\n    }\n\n    /**\n     * Increment subblock gain helper (private).\n     * @private\n     */\n    _inc_subblock_gain(gfc, cod_info, xrpow) {\n        let sfb; const scalefac = cod_info.scalefac;\n        for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) if (scalefac[sfb] >= 16) return true; // Cannot increase if long blocks too high\n\n        for (let window = 0; window < 3; window++) {\n            let s1 = 0, s2 = 0;\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) if (s1 < scalefac[sfb]) s1 = scalefac[sfb];\n            for (; sfb < cod_info.sfbmax; sfb += 3) if (s2 < scalefac[sfb]) s2 = scalefac[sfb];\n            if (s1 < 16 && s2 < 8) continue; // No need to increase gain for this window\n            if (cod_info.subblock_gain[window] >= 7) return true; // Gain already maxed out\n\n            cod_info.subblock_gain[window]++;\n            let j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n                const width = cod_info.width[sfb]; let s = scalefac[sfb]; assert(s >= 0);\n                s = s - (4 >> cod_info.scalefac_scale); // Decrease scalefac to compensate gain increase\n                if (s >= 0) { scalefac[sfb] = s; j += width * 3; continue; }\n                scalefac[sfb] = 0;\n                const gain = 210 + (s << (cod_info.scalefac_scale + 1)); // Calculate effective gain reduction\n                const amp = this.qupvt.IPOW20(gain); // Convert gain change to linear amplification factor\n                j += width * (window + 1); // Move j to the start of the correct window's data for this sfb\n                for (let l = -width; l < 0; l++) { xrpow[j + l] *= amp; if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l]; }\n                j += width * (3 - window - 1); // Move j back to start of next sfb group\n            }\n            // Apply gain to bands beyond sfbmax (up to SBMAX_s)? - Check C logic details\n             if(sfb < Encoder.SBMAX_s * 3 + cod_info.sfb_lmax) { // Check if we need to process further\n                const amp = this.qupvt.IPOW20(202); // Fixed amplification? 210 - ((-1) << (scale+1)) => 210 + (1 << (scale+1)). 210+8=218 if scale=1, 210+4=214 if scale=0. Why 202?\n                 // Calculate index j correctly for the remaining bands\n                 // Assuming j is now at the start of the sfb group *after* the last one in the loop\n                 let last_width = cod_info.width[sfb - 3]; // Width of the last processed sfb\n                 j += last_width * (window + 1); // Move to start of window data\n                 for (let l = -last_width; l < 0; l++) { xrpow[j + l] *= amp; if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l]; }\n                 // No need to adjust j further\n             }\n        }\n        return false; // Gain was increased for at least one window\n    }\n\n\n    /**\n     * Finishes the iteration loop for a single granule/channel.\n     * Optimizes scalefactor storage and Huffman table divisions.\n     * Updates the bit reservoir status based on the final bit usage.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {number} gr - Granule index (0 or 1).\n     * @param {number} ch - Channel index (0 or 1).\n     */\n    iteration_finish_one(gfp, gr, ch) {\n        const gfc = gfp.internal_flags;\n        const l3_side = gfc.l3_side;\n        const cod_info = l3_side.tt[gr][ch];\n\n        // Optimize scalefactor storage (scfsi, etc.)\n        this.tk.best_scalefac_store(gfc, gr, ch, l3_side);\n\n        // Optimize Huffman table divisions (regions)\n        if (gfc.use_best_huffman === 1) {\n            this.tk.best_huffman_divide(gfc, cod_info);\n        }\n\n        // Update reservoir status with final bit count\n        this.rv.ResvAdjust(gfc, cod_info);\n    }\n\n\n    /**\n     * Encodes a granule using VBR (Variable BitRate) logic.\n     * Performs a search loop (calling `outer_loop`) to find the optimal\n     * quantization (`cod_info`) that satisfies the psychoacoustic model (`l3_xmin`)\n     * within the allowed bit range (`min_bits` to `max_bits`).\n     * Stores the best result found.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {GrInfo} cod_info - Input/Output: Granule info structure. Initialized by caller, modified in place with best result.\n     * @param {Float32Array} l3_xmin - Array [SBMAX] of allowed noise/distortion per scalefactor band.\n     * @param {Float32Array} xrpow - Input/Output: Array [576] of spectral energy values, potentially modified.\n     * @param {number} ch - Channel index (0 or 1).\n     * @param {number} min_bits - Minimum allowed bits for this granule/channel's Huffman data.\n     * @param {number} max_bits - Maximum allowed bits for this granule/channel's Huffman data.\n     */\n    VBR_encode_granule(gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n        const gfc = gfp.internal_flags;\n        const bst_cod_info = new GrInfo(); // To store the best GrInfo found\n        const bst_xrpow = new_float(576); // To store the corresponding xrpow\n        const initial_max_bits = max_bits; // Store original max_bits for assertion\n        let current_max_bits = max_bits; // Max bits for current iteration\n        let current_min_bits = min_bits; // Min bits for current iteration\n        let this_bits = Math.floor((current_max_bits + current_min_bits) / 2); // Target bits for current try\n        let dbits = current_max_bits - current_min_bits; // Range of bits left to search\n        let over = 0; // Distortion count from outer_loop\n        let found = 0; // 0=nothing found, 1=good solution found, 2=restored previous best\n        const sfb21_extra = gfc.sfb21_extra; // Store original sfb21 setting\n\n        assert(initial_max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL, \"Initial max_bits exceeds limit\");\n        // Arrays.fill(bst_cod_info.l3_enc, 0); // Not needed, assign copies whole structure\n\n        // Search loop: Adjust target bits based on whether outer_loop meets distortion criteria\n        do {\n            assert(this_bits >= current_min_bits, `this_bits ${this_bits} < min_bits ${current_min_bits}`);\n            assert(this_bits <= current_max_bits, `this_bits ${this_bits} > max_bits ${current_max_bits}`);\n            assert(current_min_bits <= current_max_bits, `min_bits ${current_min_bits} > max_bits ${current_max_bits}`);\n\n            // Temporarily disable sfb21_extra if target bits are very high (close to max)\n            // This is a heuristic to avoid wasting bits on sfb21 if not strictly needed.\n            if (this_bits > initial_max_bits - 42) gfc.sfb21_extra = false;\n            else gfc.sfb21_extra = sfb21_extra;\n\n            // Run the outer loop with the current target bits\n            over = this.outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n\n            // Check if the quantization was successful (no distorted bands)\n            if (over <= 0) { // Success! Found a solution with <= target bits\n                found = 1;\n                const real_bits = cod_info.part2_3_length; // Actual bits used by this solution\n\n                // Store this successful solution as the best so far\n                bst_cod_info.assign(cod_info);\n                System.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n\n                // Try searching for a solution using even fewer bits\n                // Reduce max_bits significantly below the successful bit count\n                current_max_bits = real_bits - 32;\n                // Clamp max_bits if it goes below min_bits\n                if (current_max_bits < current_min_bits) current_max_bits = current_min_bits;\n\n            } else { // Failure: Distortion occurred or too many bits needed\n                // Try searching with more bits\n                // Increase min_bits significantly above the failed target\n                current_min_bits = this_bits + 32;\n                // Clamp min_bits if it exceeds original max_bits\n                if (current_min_bits > initial_max_bits) current_min_bits = initial_max_bits;\n\n                // If we had previously found a good solution, restore it before trying again\n                if (found === 1) {\n                    found = 2; // Indicate we restored a previous best\n                    cod_info.assign(bst_cod_info);\n                    System.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n                }\n                // If no good solution found yet (found=0), cod_info still holds the failed state\n            }\n\n            // Adjust search range and target for next iteration\n             if(current_max_bits < current_min_bits) current_max_bits = current_min_bits; // Ensure range is valid\n             dbits = current_max_bits - current_min_bits;\n             this_bits = Math.floor((current_max_bits + current_min_bits) / 2);\n\n\n        } while (dbits > 12); // Continue searching while the bit range is wide enough\n\n        // Restore original sfb21 setting\n        gfc.sfb21_extra = sfb21_extra;\n\n        // Ensure the best found solution (if any) is in cod_info\n        if (found === 2) {\n             // We ended the loop after failing with more bits, restore the last good one.\n             cod_info.assign(bst_cod_info);\n             // Copy quantized values as well (assign doesn't copy arrays deeply?)\n             // System.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576); // Maybe not needed if outer_loop modifies l3_enc correctly\n             // Let's assume assign is sufficient or outer_loop handles l3_enc\n        } else if (found === 0) {\n             // No successful solution found. cod_info contains the last attempt (which failed).\n             // This might use more bits than max_bits but is the best effort.\n             // Or it might have distortion. Caller should handle this.\n        }\n        // If found === 1, cod_info already holds the best solution from the last successful iteration.\n\n        assert(cod_info.part2_3_length <= initial_max_bits + 100, `VBR encode used too many bits: ${cod_info.part2_3_length} > ${initial_max_bits}`); // Allow some slack?\n    }\n\n\n    /**\n     * Calculates the number of bits available per granule for each possible\n     * bitrate index (1 to VBR_max_bitrate) considering the bit reservoir.\n     * Used by VBR modes to determine target bitrates.\n     * Also calculates the bits available for the lowest bitrate (index 1)\n     * which might be used for analog silence detection/encoding.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Int32Array} frameBits - Output array [VBR_max_bitrate + 1] to store the available bits per frame for each bitrate index.\n     */\n    get_framebits(gfp, frameBits) {\n        const gfc = gfp.internal_flags;\n        let bitsPerFrame; // Temporary variable\n\n        // Calculate bits for lowest bitrate (index 1) - used for analog silence\n        // Store original VBR min bitrate index\n        const original_vbr_min_index = gfc.VBR_min_bitrate;\n        gfc.bitrate_index = 1; // Set index to lowest (e.g., 8 kbps)\n        bitsPerFrame = this.bs.getframebits(gfp); // Get frame bits for index 1\n        // Store bits per granule for index 1 (or just use bitsPerFrame later?)\n        // C code seems to calculate this but doesn't store it directly in frameBits[1] here.\n        // Let's assume it's used implicitly later if needed.\n        // Restore original min bitrate index\n        gfc.bitrate_index = original_vbr_min_index;\n\n\n        // Calculate available bits for each bitrate from VBR min to max\n        // Iterate through all possible bitrate indices supported by LAME/MP3 spec? Or just VBR range?\n        // C code iterates 1 to VBR_max_bitrate.\n        for (let i = 1; i <= gfc.VBR_max_bitrate; i++) {\n            gfc.bitrate_index = i; // Set current bitrate index\n            let meanBits = new MeanBits(0); // Helper object for ResvFrameBegin\n            // Calculate available bits for this index, considering reservoir\n            frameBits[i] = this.rv.ResvFrameBegin(gfp, meanBits);\n            // The meanBits object might be updated by ResvFrameBegin, but its value isn't used here directly.\n        }\n        // Restore original bitrate index after loop? (Important if gfc.bitrate_index is used elsewhere)\n         gfc.bitrate_index = gfp.brate; // Restore to the target/average bitrate? Or maybe VBR_min? Let's restore target.\n\n    }\n\n\n    /**\n     * Prepares for VBR quantization using the older VBR algorithm strategy.\n     * Calculates `l3_xmin` (allowed noise), determines `min_bits` and `max_bits`\n     * per granule/channel based on PE and reservoir state, performs MS conversion if needed,\n     * and detects analog silence.\n     *\n     * @public\n     * @deprecated VBR_new_prepare is generally preferred.\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Array<Float32Array>} pe - Perceptual entropy [gr][ch].\n     * @param {Float32Array} ms_ener_ratio - Mid/Side energy ratio [gr].\n     * @param {Array<Array<object>>} ratio - Masking ratio info [gr][ch].\n     * @param {Array<Array<Float32Array>>} l3_xmin - Output: Allowed noise [gr][ch][SBMAX].\n     * @param {Int32Array} frameBits - Input: Available bits per frame for different bitrates (from `get_framebits`).\n     * @param {Array<Int32Array>} min_bits - Output: Minimum bits [gr][ch].\n     * @param {Array<Int32Array>} max_bits - Output: Maximum bits [gr][ch]. Modified in place.\n     * @param {Array<Int32Array>} bands - Output: Number of non-silent bands [gr][ch].\n     * @returns {number} 1 if analog silence detected, 0 otherwise.\n     */\n    VBR_old_prepare(gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits, max_bits, bands) {\n        const gfc = gfp.internal_flags;\n        let analog_silence = 1;\n        let bits = 0; // Total max bits initially assigned\n\n        // Calculate average bits per granule based on VBR max bitrate\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        let avg_bits_per_granule = this.rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n\n        // Calculate bits available per frame for each bitrate index (if not already done)\n        // this.get_framebits(gfp, frameBits); // Assuming frameBits is pre-calculated\n\n        // Process each granule\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            // Adjust max_bits based on PE (per granule)\n            const mxb_per_granule = this.qupvt.on_pe(gfp, pe, max_bits[gr], avg_bits_per_granule, gr, 0);\n\n            // Perform MS conversion if needed (joint stereo)\n            if (gfc.mode_ext === Encoder.MPG_MD_MS_LR) { // Using mode_ext check from C\n                this.ms_convert(gfc.l3_side, gr);\n                // Reduce side channel bits based on M/S energy ratio\n                this.qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg_bits_per_granule, mxb_per_granule); // Modifies max_bits[gr] in place\n            }\n\n            // Process each channel\n            for (let ch = 0; ch < gfc.channels_out; ++ch) {\n                const cod_info = gfc.l3_side.tt[gr][ch];\n                let adjust = 0.0; let masking_lower_db = 0.0;\n\n                // Calculate masking adjustment based on PE and block type\n                if (cod_info.block_type !== Encoder.SHORT_TYPE) { // Long block types\n                    adjust = 1.28 / (1.0 + Math.exp(3.5 - pe[gr][ch] / 300.0)) - 0.05;\n                    masking_lower_db = gfc.PSY.mask_adjust - adjust;\n                } else { // Short blocks\n                    adjust = 2.56 / (1.0 + Math.exp(3.5 - pe[gr][ch] / 300.0)) - 0.14;\n                    masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n                }\n                gfc.masking_lower = Math.pow(10.0, masking_lower_db * 0.1); // Set global masking adjustment\n\n                // Initialize granule info and calculate allowed noise (l3_xmin)\n                this.init_outer_loop(gfc, cod_info);\n                bands[gr][ch] = this.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch]);\n                if (bands[gr][ch] !== 0) analog_silence = 0; // Not silent if any bands calculated\n\n                // Set initial min bits (seems fixed?)\n                min_bits[gr][ch] = 126;\n\n                // Accumulate total assigned max bits\n                bits += max_bits[gr][ch];\n            } // End channel loop\n        } // End granule loop\n\n        // Scale max_bits if total exceeds frame limit for max VBR bitrate\n        const max_frame_allowable_bits = frameBits[gfc.VBR_max_bitrate];\n        if (bits > max_frame_allowable_bits) {\n            for (let gr = 0; gr < gfc.mode_gr; gr++) {\n                for (let ch = 0; ch < gfc.channels_out; ch++) {\n                    max_bits[gr][ch] = Math.floor(max_bits[gr][ch] * max_frame_allowable_bits / bits);\n                }\n            }\n        }\n\n        // Ensure min_bits <= max_bits\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                 if (min_bits[gr][ch] > max_bits[gr][ch]) {\n                    min_bits[gr][ch] = max_bits[gr][ch];\n                 }\n            }\n        }\n\n        return analog_silence;\n    }\n\n    /**\n     * Applies a \"bit pressure\" strategy by slightly increasing the allowed noise\n     * (`l3_xmin`) in higher frequency bands and potentially reducing `max_bits`.\n     * Used in some VBR modes to encourage bits to be used more efficiently.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Array<Array<Float32Array>>} l3_xmin - Input/Output: Allowed noise [gr][ch][SBMAX]. Modified in place.\n     * @param {Array<Int32Array>} min_bits - Input: Minimum bits [gr][ch].\n     * @param {Array<Int32Array>} max_bits - Input/Output: Maximum bits [gr][ch]. Modified in place.\n     */\n    bitpressure_strategy(gfp, l3_xmin, min_bits, max_bits) {\n        const gfc = gfp.internal_flags;\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                const gi = gfc.l3_side.tt[gr][ch];\n                const pxmin = l3_xmin[gr][ch]; // Reference to allowed noise array for this gr/ch\n                let pxminPos = 0; // Current index within pxmin\n\n                // Increase allowed noise slightly for higher frequency long block bands\n                for (let sfb = 0; sfb < gi.psy_lmax; sfb++) {\n                    pxmin[pxminPos++] *= 1.0 + 0.029 * sfb * sfb / (Encoder.SBMAX_l * Encoder.SBMAX_l);\n                }\n\n                // Increase allowed noise slightly for short block bands\n                if (gi.block_type === Encoder.SHORT_TYPE) {\n                    for (let sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) { // Iterate through short sfbs\n                        const factor = 1.0 + 0.029 * sfb * sfb / (Encoder.SBMAX_s * Encoder.SBMAX_s);\n                        // Apply factor to all 3 windows for this sfb\n                        if(pxminPos < pxmin.length) pxmin[pxminPos++] *= factor;\n                        if(pxminPos < pxmin.length) pxmin[pxminPos++] *= factor;\n                        if(pxminPos < pxmin.length) pxmin[pxminPos++] *= factor;\n                    }\n                }\n\n                // Reduce max_bits slightly (e.g., to 90% of original) but not below min_bits\n                max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch], 0.9 * max_bits[gr][ch]);\n            }\n        }\n    }\n\n    /**\n     * Prepares for VBR quantization using the newer VBR algorithm strategy.\n     * Calculates `l3_xmin`, determines initial `max_bits` based on PE and reservoir,\n     * performs MS conversion, and detects analog silence.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Array<Float32Array>} pe - Perceptual entropy [gr][ch].\n     * @param {Array<Array<object>>} ratio - Masking ratio info [gr][ch].\n     * @param {Array<Array<Float32Array>>} l3_xmin - Output: Allowed noise [gr][ch][SBMAX].\n     * @param {Int32Array} frameBits - Output: Available bits per frame for different bitrates. Only index [0] (free format) or [VBR_max_bitrate] is relevant here? Needs clarification. C code uses it.\n     * @param {Array<Int32Array>} max_bits - Output: Maximum bits [gr][ch]. Modified in place.\n     * @returns {number} 1 if analog silence detected, 0 otherwise.\n     */\n    VBR_new_prepare(gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n        const gfc = gfp.internal_flags;\n        let analog_silence = 1;\n        let avg_bits = 0; // Average bits per granule for PE calculation\n        let total_max_bits = 0; // Sum of initially assigned max_bits\n        let maximum_frame_bits; // Max bits allowed for the frame by reservoir/bitrate\n\n        // Determine average and maximum frame bits\n        if (!gfp.free_format) {\n            gfc.bitrate_index = gfc.VBR_max_bitrate; // Use max VBR bitrate for calculation\n            let mb = new MeanBits(avg_bits);\n            maximum_frame_bits = this.rv.ResvFrameBegin(gfp, mb); // Get max frame bits considering reservoir\n            avg_bits = mb.bits; // Get mean bits expected by reservoir for this frame\n\n            // Calculate bits per frame for all bitrates (needed later?)\n            this.get_framebits(gfp, frameBits); // Fills frameBits array\n\n            // Restore target bitrate index?\n             gfc.bitrate_index = gfp.brate;\n\n        } else { // Free format - calculate based on target bitrate?\n            gfc.bitrate_index = 0; // Indicate free format?\n            let mb = new MeanBits(avg_bits);\n            maximum_frame_bits = this.rv.ResvFrameBegin(gfp, mb); // Get frame bits (might just be target)\n            avg_bits = mb.bits;\n            frameBits[0] = maximum_frame_bits; // Store in index 0 for free format convention\n        }\n\n        // Average bits per granule (used for PE scaling)\n        const avg_bits_per_granule = avg_bits / gfc.mode_gr;\n\n        // Process granules\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            // Calculate initial max_bits allocation based on PE\n             this.qupvt.on_pe(gfp, pe, max_bits[gr], avg_bits_per_granule, gr, 0); // Modifies max_bits[gr] in place\n\n            // MS Conversion if needed\n            if (gfc.mode_ext === Encoder.MPG_MD_MS_LR) {\n                this.ms_convert(gfc.l3_side, gr);\n                 // Side channel bit reduction might happen later or be integrated elsewhere in new VBR\n            }\n\n            // Process channels\n            for (let ch = 0; ch < gfc.channels_out; ++ch) {\n                const cod_info = gfc.l3_side.tt[gr][ch];\n\n                // Set masking adjustment (typically less aggressive than old VBR)\n                gfc.masking_lower = Math.pow(10.0, gfc.PSY.mask_adjust * 0.1);\n\n                // Initialize granule info and calculate allowed noise (l3_xmin)\n                this.init_outer_loop(gfc, cod_info);\n                if (this.qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch]) !== 0) {\n                    analog_silence = 0; // Not silent\n                }\n\n                // Accumulate total assigned max bits\n                total_max_bits += max_bits[gr][ch];\n            } // End channel loop\n        } // End granule loop\n\n        // Scale max_bits if total exceeds frame limit\n        if (total_max_bits > maximum_frame_bits) {\n            for (let gr = 0; gr < gfc.mode_gr; gr++) {\n                for (let ch = 0; ch < gfc.channels_out; ch++) {\n                    max_bits[gr][ch] = Math.floor(max_bits[gr][ch] * maximum_frame_bits / total_max_bits);\n                }\n            }\n        }\n        // Note: min_bits is not explicitly set or used here, unlike VBR_old_prepare\n\n        return analog_silence;\n    }\n\n\n    /**\n     * Calculates the target number of bits for each granule/channel in ABR mode.\n     * Considers the average target bitrate, perceptual entropy (PE),\n     * bit reservoir status (via `ResvFrameBegin`), and applies heuristics\n     * to allocate more bits to complex parts (high PE, short blocks).\n     * Ensures the total target does not exceed frame limits.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - LAME global flags.\n     * @param {Array<Float32Array>} pe - Perceptual entropy [gr][ch].\n     * @param {Float32Array} ms_ener_ratio - Mid/Side energy ratio [gr].\n     * @param {Array<Int32Array>} targ_bits - Output: Target bits [gr][ch]. Modified in place.\n     * @param {Int32Array} analog_silence_bits - Output: Target bits per granule/channel for analog silence [1].\n     * @param {Int32Array} max_frame_bits - Output: Maximum bits allowed for the frame [1].\n     */\n    calc_target_bits(gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n        const gfc = gfp.internal_flags;\n        const l3_side = gfc.l3_side;\n        let res_factor; // Reservoir usage factor\n        let totbits; // Total target bits calculated\n        let mean_bits; // Average target bits per granule/channel\n\n        // 1. Calculate max frame bits allowed by reservoir/max bitrate\n        gfc.bitrate_index = gfc.VBR_max_bitrate; // Use max bitrate for limit calculation\n        let mb_max = new MeanBits(0);\n        max_frame_bits[0] = this.rv.ResvFrameBegin(gfp, mb_max);\n        // mean_bits = mb_max.bits; // Mean bits corresponding to max isn't directly used\n\n        // 2. Calculate bits for analog silence (using lowest bitrate)\n        gfc.bitrate_index = 1; // Lowest bitrate index\n        mean_bits = this.bs.getframebits(gfp) - gfc.sideinfo_len * 8; // Bits for data payload\n        analog_silence_bits[0] = Math.floor(mean_bits / (gfc.mode_gr * gfc.channels_out));\n\n        // 3. Calculate average target bits based on requested ABR bitrate\n        mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000.0; // Target bits per frame (float)\n        mean_bits /= gfp.out_samplerate; // Bits per second -> Bits per frame\n        mean_bits -= gfc.sideinfo_len * 8; // Subtract side info bits\n        // Heuristic adjustment for substep shaping?\n        if ((gfc.substep_shaping & 1) !== 0) mean_bits *= 1.09;\n        mean_bits /= (gfc.mode_gr * gfc.channels_out); // Average bits per granule per channel\n\n        // 4. Determine reservoir factor (how much of the average to target directly)\n        // Linearly interpolates between 0.93 (at 128kbps) and 1.0 (at 256kbps) based on compression ratio\n        res_factor = 0.93 + 0.07 * (11.0 - gfp.compression_ratio) / (11.0 - 5.5);\n        if (res_factor < 0.90) res_factor = 0.90; // Clamp lower bound\n        if (res_factor > 1.00) res_factor = 1.00; // Clamp upper bound\n\n        // 5. Calculate initial target bits per granule/channel based on PE\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            let sum_gr_bits = 0; // Sum of target bits for this granule\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                let target = Math.floor(res_factor * mean_bits); // Base target\n                let add_bits = 0; // Extra bits based on PE/block type\n\n                // Add bits if PE is high\n                if (pe[gr][ch] > 700) {\n                    add_bits = Math.floor((pe[gr][ch] - 700) / 1.4);\n                    // Short blocks get extra bits regardless of PE?\n                    if (l3_side.tt[gr][ch].block_type === Encoder.SHORT_TYPE) {\n                         if (add_bits < mean_bits / 2.0) add_bits = Math.floor(mean_bits / 2.0);\n                    }\n                    // Limit added bits\n                    if (add_bits > mean_bits * 1.5) add_bits = Math.floor(mean_bits * 1.5);\n                    else if (add_bits < 0) add_bits = 0;\n\n                    target += add_bits;\n                }\n\n                // Clamp target bits per channel\n                if (target > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                    target = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                }\n                targ_bits[gr][ch] = target;\n                sum_gr_bits += target;\n            } // End channel loop\n\n            // 6. Rescale if granule total exceeds per-granule limit\n            if (sum_gr_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n                for (let ch = 0; ch < gfc.channels_out; ++ch) {\n                    targ_bits[gr][ch] = Math.floor(targ_bits[gr][ch] * LameInternalFlags.MAX_BITS_PER_GRANULE / sum_gr_bits);\n                }\n            }\n        } // End granule loop\n\n        // 7. Apply side channel reduction if MS stereo\n        if (gfc.mode_ext === Encoder.MPG_MD_MS_LR) {\n            for (let gr = 0; gr < gfc.mode_gr; gr++) {\n                // Use helper function to reduce side channel bits (modifies targ_bits[gr] in place)\n                this.qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits * gfc.channels_out, LameInternalFlags.MAX_BITS_PER_GRANULE);\n            }\n        }\n\n        // 8. Calculate total target bits and rescale if exceeds max frame bits\n        totbits = 0;\n        for (let gr = 0; gr < gfc.mode_gr; gr++) {\n            for (let ch = 0; ch < gfc.channels_out; ch++) {\n                 // Clamp again after potential side channel reduction?\n                 if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                 }\n                totbits += targ_bits[gr][ch];\n            }\n        }\n\n        // Rescale if total exceeds frame limit\n        if (totbits > max_frame_bits[0]) {\n            for (let gr = 0; gr < gfc.mode_gr; gr++) {\n                for (let ch = 0; ch < gfc.channels_out; ch++) {\n                    targ_bits[gr][ch] = Math.floor(targ_bits[gr][ch] * max_frame_bits[0] / totbits);\n                }\n            }\n        }\n    }\n\n}\n\n// Internal MeanBits helper class (used locally)\nclass MeanBits {\n    constructor(bits) {\n        this.bits = bits;\n    }\n}\n\n\n// Export the main class\nexport { Quantize };","import * as common from './common.js';\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\n\nfunction VBRTag() {\n\n    var lame;\n    var bs;\n    var v;\n\n    this.setModules = function (_lame, _bs, _v) {\n        lame = _lame;\n        bs = _bs;\n        v = _v;\n    };\n\n    var FRAMES_FLAG = 0x0001;\n    var BYTES_FLAG = 0x0002;\n    var TOC_FLAG = 0x0004;\n    var VBR_SCALE_FLAG = 0x0008;\n\n    var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n\n    /**\n     * (0xB40) the max freeformat 640 32kHz framesize.\n     */\n    var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n\n    /**\n     * <PRE>\n     *    4 bytes for Header Tag\n     *    4 bytes for Header Flags\n     *  100 bytes for entry (toc)\n     *    4 bytes for frame size\n     *    4 bytes for stream size\n     *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n     *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n     * ___________\n     *  140 bytes\n     * </PRE>\n     */\n    var VBRHEADERSIZE = (NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4);\n\n    var LAMEHEADERSIZE = (VBRHEADERSIZE + 9 + 1 + 1 + 8\n    + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2);\n\n    /**\n     * The size of the Xing header MPEG-1, bit rate in kbps.\n     */\n    var XING_BITRATE1 = 128;\n    /**\n     * The size of the Xing header MPEG-2, bit rate in kbps.\n     */\n    var XING_BITRATE2 = 64;\n    /**\n     * The size of the Xing header MPEG-2.5, bit rate in kbps.\n     */\n    var XING_BITRATE25 = 32;\n\n    /**\n     * ISO-8859-1 charset for byte to string operations.\n     */\n    var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n    /**\n     * VBR header magic string.\n     */\n    var VBRTag0 = \"Xing\";\n    /**\n     * VBR header magic string (VBR == VBRMode.vbr_off).\n     */\n    var VBRTag1 = \"Info\";\n\n    /**\n     * Lookup table for fast CRC-16 computation. Uses the polynomial\n     * x^16+x^15+x^2+1\n     */\n    var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140,\n        0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741,\n        0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41,\n        0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40,\n        0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n        0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40,\n        0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540,\n        0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341,\n        0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141,\n        0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,\n        0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40,\n        0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41,\n        0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940,\n        0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n        0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541,\n        0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340,\n        0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141,\n        0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740,\n        0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40,\n        0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41,\n        0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940,\n        0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41,\n        0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n        0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340,\n        0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,\n        0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741,\n        0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41,\n        0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40,\n        0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941,\n        0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40,\n        0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540,\n        0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n        0x4100, 0x81C1, 0x8081, 0x4040];\n\n    /***********************************************************************\n     * Robert Hegemann 2001-01-17\n     ***********************************************************************/\n\n    function addVbr(v, bitrate) {\n        v.nVbrNumFrames++;\n        v.sum += bitrate;\n        v.seen++;\n\n        if (v.seen < v.want) {\n            return;\n        }\n\n        if (v.pos < v.size) {\n            v.bag[v.pos] = v.sum;\n            v.pos++;\n            v.seen = 0;\n        }\n        if (v.pos == v.size) {\n            for (var i = 1; i < v.size; i += 2) {\n                v.bag[i / 2] = v.bag[i];\n            }\n            v.want *= 2;\n            v.pos /= 2;\n        }\n    }\n\n    function xingSeekTable(v, t) {\n        if (v.pos <= 0)\n            return;\n\n        for (var i = 1; i < NUMTOCENTRIES; ++i) {\n            var j = i / NUMTOCENTRIES, act, sum;\n            var indx = 0 | (Math.floor(j * v.pos));\n            if (indx > v.pos - 1)\n                indx = v.pos - 1;\n            act = v.bag[indx];\n            sum = v.sum;\n            var seek_point = 0 | (256. * act / sum);\n            if (seek_point > 255)\n                seek_point = 255;\n            t[i] = 0xff & seek_point;\n        }\n    }\n\n    /**\n     * Add VBR entry, used to fill the VBR TOC entries.\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.addVbrFrame = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        assert(gfc.VBR_seek_table.bag != null);\n        addVbr(gfc.VBR_seek_table, kbps);\n    }\n\n    /**\n     * Read big endian integer (4-bytes) from header.\n     *\n     * @param buf\n     *            header containing the integer\n     * @param bufPos\n     *            offset into the header\n     * @return extracted integer\n     */\n    function extractInteger(buf, bufPos) {\n        var x = buf[bufPos + 0] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 1] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 2] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 3] & 0xff;\n        return x;\n    }\n\n    /**\n     * Write big endian integer (4-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createInteger(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 24) & 0xff);\n        buf[bufPos + 1] = 0xff & ((value >> 16) & 0xff);\n        buf[bufPos + 2] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 3] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Write big endian short (2-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createShort(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 1] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Check for magic strings (Xing/Info).\n     *\n     * @param buf\n     *            header to check\n     * @param bufPos\n     *            header offset to check\n     * @return magic string found\n     */\n    function isVbrTag(buf, bufPos) {\n        return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1)\n                .equals(VBRTag0)\n            || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1)\n                .equals(VBRTag1);\n    }\n\n    function shiftInBitsValue(x, n, v) {\n        return 0xff & ((x << n) | (v & ~(-1 << n)));\n    }\n\n    /**\n     * Construct the MP3 header using the settings of the global flags.\n     *\n     * <img src=\"1000px-Mp3filestructure.svg.png\">\n     *\n     * @param gfp\n     *            global flags\n     * @param buffer\n     *            header\n     */\n    function setLameTagFrameHeader(gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        // MP3 Sync Word\n        buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n\n        buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n        buffer[1] = shiftInBitsValue(buffer[1], 1,\n            (gfp.out_samplerate < 16000) ? 0 : 1);\n        // Version\n        buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);\n        // 01 == Layer 3\n        buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);\n        // Error protection\n        buffer[1] = shiftInBitsValue(buffer[1], 1, (!gfp.error_protection) ? 1\n            : 0);\n\n        // Bit rate\n        buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);\n        // Frequency\n        buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);\n        // Pad. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, 0);\n        // Priv. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);\n\n        // Mode\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());\n        // Mode extension (Used with Joint Stereo)\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);\n        // Copy\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);\n        // Original\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);\n        // Emphasis\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n\n        /* the default VBR header. 48 kbps layer III, no padding, no crc */\n        /* but sampling freq, mode and copyright/copy protection taken */\n        /* from first valid frame */\n        buffer[0] = 0xff;\n        var abyte = 0xff & (buffer[1] & 0xf1);\n        var bitrate;\n        if (1 == gfp.version) {\n            bitrate = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                bitrate = XING_BITRATE25;\n            else\n                bitrate = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            bitrate = gfp.brate;\n\n        var bbyte;\n        if (gfp.free_format)\n            bbyte = 0x00;\n        else\n            bbyte = 0xff & (16 * lame.BitrateIndex(bitrate, gfp.version,\n                    gfp.out_samplerate));\n\n        /*\n         * Use as much of the info from the real frames in the Xing header:\n         * samplerate, channels, crc, etc...\n         */\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            buffer[1] = 0xff & (abyte | 0x0a);\n            /* was 0x0b; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG1 frame */\n        } else {\n            /* MPEG2 */\n            buffer[1] = 0xff & (abyte | 0x02);\n            /* was 0x03; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG2 frame */\n        }\n    }\n\n    /**\n     * Get VBR tag information\n     *\n     * @param buf\n     *            header to analyze\n     * @param bufPos\n     *            offset into the header\n     * @return VBR tag data\n     */\n    this.getVbrTag = function (buf) {\n        var pTagData = new VBRTagData();\n        var bufPos = 0;\n\n        /* get Vbr header data */\n        pTagData.flags = 0;\n\n        /* get selected MPEG header data */\n        var hId = (buf[bufPos + 1] >> 3) & 1;\n        var hSrIndex = (buf[bufPos + 2] >> 2) & 3;\n        var hMode = (buf[bufPos + 3] >> 6) & 3;\n        var hBitrate = ((buf[bufPos + 2] >> 4) & 0xf);\n        hBitrate = Tables.bitrate_table[hId][hBitrate];\n\n        /* check for FFE syncword */\n        if ((buf[bufPos + 1] >> 4) == 0xE)\n            pTagData.samprate = Tables.samplerate_table[2][hSrIndex];\n        else\n            pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n\n        /* determine offset of header */\n        if (hId != 0) {\n            /* mpeg1 */\n            if (hMode != 3)\n                bufPos += (32 + 4);\n            else\n                bufPos += (17 + 4);\n        } else {\n            /* mpeg2 */\n            if (hMode != 3)\n                bufPos += (17 + 4);\n            else\n                bufPos += (9 + 4);\n        }\n\n        if (!isVbrTag(buf, bufPos))\n            return null;\n\n        bufPos += 4;\n\n        pTagData.hId = hId;\n\n        /* get flags */\n        var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n        bufPos += 4;\n\n        if ((head_flags & FRAMES_FLAG) != 0) {\n            pTagData.frames = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & BYTES_FLAG) != 0) {\n            pTagData.bytes = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & TOC_FLAG) != 0) {\n            if (pTagData.toc != null) {\n                for (var i = 0; i < NUMTOCENTRIES; i++)\n                    pTagData.toc[i] = buf[bufPos + i];\n            }\n            bufPos += NUMTOCENTRIES;\n        }\n\n        pTagData.vbrScale = -1;\n\n        if ((head_flags & VBR_SCALE_FLAG) != 0) {\n            pTagData.vbrScale = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        pTagData.headersize = ((hId + 1) * 72000 * hBitrate)\n            / pTagData.samprate;\n\n        bufPos += 21;\n        var encDelay = buf[bufPos + 0] << 4;\n        encDelay += buf[bufPos + 1] >> 4;\n        var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n        encPadding += buf[bufPos + 2] & 0xff;\n        /* check for reasonable values (this may be an old Xing header, */\n        /* not a INFO tag) */\n        if (encDelay < 0 || encDelay > 3000)\n            encDelay = -1;\n        if (encPadding < 0 || encPadding > 3000)\n            encPadding = -1;\n\n        pTagData.encDelay = encDelay;\n        pTagData.encPadding = encPadding;\n\n        /* success */\n        return pTagData;\n    }\n\n    /**\n     * Initializes the header\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.InitVbrTag = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        /**\n         * <PRE>\n         * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n         * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n         * table of contents)\n         * let's always embed Xing header inside a 64kbs layer III frame.\n         * this gives us enough room for a LAME version string too.\n         * size determined by sampling frequency (MPEG1)\n         * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n         * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n         * 48kHz:    144 bytes          192\n         *\n         * MPEG 2 values are the same since the framesize and samplerate\n         * are each reduced by a factor of 2.\n         * </PRE>\n         */\n        var kbps_header;\n        if (1 == gfp.version) {\n            kbps_header = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                kbps_header = XING_BITRATE25;\n            else\n                kbps_header = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            kbps_header = gfp.brate;\n\n        // make sure LAME Header fits into Frame\n        var totalFrameSize = ((gfp.version + 1) * 72000 * kbps_header)\n            / gfp.out_samplerate;\n        var headerSize = (gfc.sideinfo_len + LAMEHEADERSIZE);\n        gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n        if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n            /* disable tag, it wont fit */\n            gfp.bWriteVbrTag = false;\n            return;\n        }\n\n        gfc.VBR_seek_table.nVbrNumFrames = 0;\n        gfc.VBR_seek_table.nBytesWritten = 0;\n        gfc.VBR_seek_table.sum = 0;\n\n        gfc.VBR_seek_table.seen = 0;\n        gfc.VBR_seek_table.want = 1;\n        gfc.VBR_seek_table.pos = 0;\n\n        if (gfc.VBR_seek_table.bag == null) {\n            gfc.VBR_seek_table.bag = new int[400];\n            gfc.VBR_seek_table.size = 400;\n        }\n\n        // write dummy VBR tag of all 0's into bitstream\n        var buffer = new_byte(MAXFRAMESIZE);\n\n        setLameTagFrameHeader(gfp, buffer);\n        var n = gfc.VBR_seek_table.TotalFrameSize;\n        for (var i = 0; i < n; ++i) {\n            bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n        }\n    }\n\n    /**\n     * Fast CRC-16 computation (uses table crc16Lookup).\n     *\n     * @param value\n     * @param crc\n     * @return\n     */\n    function crcUpdateLookup(value, crc) {\n        var tmp = crc ^ value;\n        crc = (crc >> 8) ^ crc16Lookup[tmp & 0xff];\n        return crc;\n    }\n\n    this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n        for (var i = 0; i < size; ++i)\n            crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n    }\n\n    /**\n     * Write LAME info: mini version + info on various switches used (Jonathan\n     * Dee 2001/08/31).\n     *\n     * @param gfp\n     *            global flags\n     * @param musicLength\n     *            music length\n     * @param streamBuffer\n     *            pointer to output buffer\n     * @param streamBufferPos\n     *            offset into the output buffer\n     * @param crc\n     *            computation of CRC-16 of Lame Tag so far (starting at frame\n     *            sync)\n     * @return number of bytes written to the stream\n     */\n    function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n        var gfc = gfp.internal_flags;\n        var bytesWritten = 0;\n\n        /* encoder delay */\n        var encDelay = gfp.encoder_delay;\n        /* encoder padding */\n        var encPadding = gfp.encoder_padding;\n\n        /* recall: gfp.VBR_q is for example set by the switch -V */\n        /* gfp.quality by -q, -h, -f, etc */\n        var quality = (100 - 10 * gfp.VBR_q - gfp.quality);\n\n        var version = v.getLameVeryShortVersion();\n        var vbr;\n        var revision = 0x00;\n        var revMethod;\n        // numbering different in vbr_mode vs. Lame tag\n        var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n        var lowpass = 0 | (((gfp.lowpassfreq / 100.0) + .5) > 255 ? 255\n                : (gfp.lowpassfreq / 100.0) + .5);\n        var peakSignalAmplitude = 0;\n        var radioReplayGain = 0;\n        var audiophileReplayGain = 0;\n        var noiseShaping = gfp.internal_flags.noise_shaping;\n        var stereoMode = 0;\n        var nonOptimal = 0;\n        var sourceFreq = 0;\n        var misc = 0;\n        var musicCRC = 0;\n\n        // psy model type: Gpsycho or NsPsytune\n        var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n        var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n        var noGapMore = false;\n        var noGapPrevious = false;\n        var noGapCount = gfp.internal_flags.nogap_total;\n        var noGapCurr = gfp.internal_flags.nogap_current;\n\n        // 4 bits\n        var athType = gfp.ATHtype;\n        var flags = 0;\n\n        // vbr modes\n        var abrBitrate;\n        switch (gfp.VBR) {\n            case vbr_abr:\n                abrBitrate = gfp.VBR_mean_bitrate_kbps;\n                break;\n            case vbr_off:\n                abrBitrate = gfp.brate;\n                break;\n            default:\n                abrBitrate = gfp.VBR_min_bitrate_kbps;\n        }\n\n        // revision and vbr method\n        if (gfp.VBR.ordinal() < vbrTypeTranslator.length)\n            vbr = vbrTypeTranslator[gfp.VBR.ordinal()];\n        else\n            vbr = 0x00; // unknown\n\n        revMethod = 0x10 * revision + vbr;\n\n        // ReplayGain\n        if (gfc.findReplayGain) {\n            if (gfc.RadioGain > 0x1FE)\n                gfc.RadioGain = 0x1FE;\n            if (gfc.RadioGain < -0x1FE)\n                gfc.RadioGain = -0x1FE;\n\n            // set name code\n            radioReplayGain = 0x2000;\n            // set originator code to `determined automatically'\n            radioReplayGain |= 0xC00;\n\n            if (gfc.RadioGain >= 0) {\n                // set gain adjustment\n                radioReplayGain |= gfc.RadioGain;\n            } else {\n                // set the sign bit\n                radioReplayGain |= 0x200;\n                // set gain adjustment\n                radioReplayGain |= -gfc.RadioGain;\n            }\n        }\n\n        // peak sample\n        if (gfc.findPeakSample)\n            peakSignalAmplitude = Math\n                .abs(0 | ((( gfc.PeakSample) / 32767.0) * Math.pow(2, 23) + .5));\n\n        // nogap\n        if (noGapCount != -1) {\n            if (noGapCurr > 0)\n                noGapPrevious = true;\n\n            if (noGapCurr < noGapCount - 1)\n                noGapMore = true;\n        }\n\n        // flags\n        flags = athType + ((expNPsyTune ? 1 : 0) << 4)\n            + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6)\n            + ((noGapPrevious ? 1 : 0) << 7);\n\n        if (quality < 0)\n            quality = 0;\n\n        // stereo mode field (Intensity stereo is not implemented)\n        switch (gfp.mode) {\n            case MONO:\n                stereoMode = 0;\n                break;\n            case STEREO:\n                stereoMode = 1;\n                break;\n            case DUAL_CHANNEL:\n                stereoMode = 2;\n                break;\n            case JOINT_STEREO:\n                if (gfp.force_ms)\n                    stereoMode = 4;\n                else\n                    stereoMode = 3;\n                break;\n            case NOT_SET:\n            //$FALL-THROUGH$\n            default:\n                stereoMode = 7;\n                break;\n        }\n\n        if (gfp.in_samplerate <= 32000)\n            sourceFreq = 0x00;\n        else if (gfp.in_samplerate == 48000)\n            sourceFreq = 0x02;\n        else if (gfp.in_samplerate > 48000)\n            sourceFreq = 0x03;\n        else {\n            // default is 44100Hz\n            sourceFreq = 0x01;\n        }\n\n        // Check if the user overrided the default LAME behavior with some\n        // nasty options\n        if (gfp.short_blocks == ShortBlock.short_block_forced\n            || gfp.short_blocks == ShortBlock.short_block_dispensed\n            || ((gfp.lowpassfreq == -1) && (gfp.highpassfreq == -1)) || /* \"-k\" */\n            (gfp.scale_left < gfp.scale_right)\n            || (gfp.scale_left > gfp.scale_right)\n            || (gfp.disable_reservoir && gfp.brate < 320) || gfp.noATH\n            || gfp.ATHonly || (athType == 0) || gfp.in_samplerate <= 32000)\n            nonOptimal = 1;\n\n        misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5)\n            + (sourceFreq << 6);\n\n        musicCRC = gfc.nMusicCRC;\n\n        // Write all this information into the stream\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n        bytesWritten += 4;\n\n        for (var j = 0; j < 9; j++) {\n            streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version .charAt(j);\n        }\n        bytesWritten += 9;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n        bytesWritten++;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten,\n            peakSignalAmplitude);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            radioReplayGain);\n        bytesWritten += 2;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            audiophileReplayGain);\n        bytesWritten += 2;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n        bytesWritten++;\n\n        if (abrBitrate >= 255)\n            streamBuffer[streamBufferPos + bytesWritten] = 0xFF;\n        else\n            streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & (encDelay >> 4);\n        streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & ((encDelay << 4) + (encPadding >> 8));\n        streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n\n        bytesWritten += 3;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n        bytesWritten++;\n\n        // unused in rev0\n        streamBuffer[streamBufferPos + bytesWritten++] = 0;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n        bytesWritten += 2;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n        bytesWritten += 2;\n\n        // Calculate tag CRC.... must be done here, since it includes previous\n        // information\n\n        for (var i = 0; i < bytesWritten; i++)\n            crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n        bytesWritten += 2;\n\n        return bytesWritten;\n    }\n\n    function skipId3v2(fpStream) {\n        // seek to the beginning of the stream\n        fpStream.seek(0);\n        // read 10 bytes in case there's an ID3 version 2 header here\n        var id3v2Header = new_byte(10);\n        fpStream.readFully(id3v2Header);\n        /* does the stream begin with the ID3 version 2 file identifier? */\n        var id3v2TagSize;\n        if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n            /*\n             * the tag size (minus the 10-byte header) is encoded into four\n             * bytes where the most significant bit is clear in each byte\n             */\n            id3v2TagSize = (((id3v2Header[6] & 0x7f) << 21)\n                | ((id3v2Header[7] & 0x7f) << 14)\n                | ((id3v2Header[8] & 0x7f) << 7) | (id3v2Header[9] & 0x7f))\n                + id3v2Header.length;\n        } else {\n            /* no ID3 version 2 tag in this stream */\n            id3v2TagSize = 0;\n        }\n        return id3v2TagSize;\n    }\n\n    this.getLameTagFrame = function (gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        if (!gfp.bWriteVbrTag) {\n            return 0;\n        }\n        if (gfc.Class_ID != Lame.LAME_ID) {\n            return 0;\n        }\n        if (gfc.VBR_seek_table.pos <= 0) {\n            return 0;\n        }\n        if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n            return gfc.VBR_seek_table.TotalFrameSize;\n        }\n\n        Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);\n\n        // 4 bytes frame header\n        setLameTagFrameHeader(gfp, buffer);\n\n        // Create TOC entries\n        var toc = new_byte(NUMTOCENTRIES);\n\n        if (gfp.free_format) {\n            for (var i = 1; i < NUMTOCENTRIES; ++i)\n                toc[i] = 0xff & (255 * i / 100);\n        } else {\n            xingSeekTable(gfc.VBR_seek_table, toc);\n        }\n\n        // Start writing the tag after the zero frame\n        var streamIndex = gfc.sideinfo_len;\n        /**\n         * Note: Xing header specifies that Xing data goes in the ancillary data\n         * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n         * data still starts at the same offset, and now it is in sideinfo data\n         * block, and thus will not decode correctly by non-Xing tag aware\n         * players\n         */\n        if (gfp.error_protection)\n            streamIndex -= 2;\n\n        // Put Vbr tag\n        if (gfp.VBR == VbrMode.vbr_off) {\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n\n        } else {\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n        }\n\n        // Put header flags\n        createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG\n            + VBR_SCALE_FLAG);\n        streamIndex += 4;\n\n        // Put Total Number of frames\n        createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n        streamIndex += 4;\n\n        // Put total audio stream size, including Xing/LAME Header\n        var streamSize = (gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize);\n        createInteger(buffer, streamIndex, 0 | streamSize);\n        streamIndex += 4;\n\n        /* Put TOC */\n        System.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n        streamIndex += toc.length;\n\n        if (gfp.error_protection) {\n            // (jo) error_protection: add crc16 information to header\n            bs.CRC_writeheader(gfc, buffer);\n        }\n\n        // work out CRC so far: initially crc = 0\n        var crc = 0x00;\n        for (var i = 0; i < streamIndex; i++)\n            crc = crcUpdateLookup(buffer[i], crc);\n        // Put LAME VBR info\n        streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n\n        return gfc.VBR_seek_table.TotalFrameSize;\n    }\n\n    /**\n     * Write final VBR tag to the file.\n     *\n     * @param gfp\n     *            global flags\n     * @param stream\n     *            stream to add the VBR tag to\n     * @return 0 (OK), -1 else\n     * @throws IOException\n     *             I/O error\n     */\n    this.putVbrTag = function (gfp, stream) {\n        var gfc = gfp.internal_flags;\n\n        if (gfc.VBR_seek_table.pos <= 0)\n            return -1;\n\n        // Seek to end of file\n        stream.seek(stream.length());\n\n        // Get file size, abort if file has zero length.\n        if (stream.length() == 0)\n            return -1;\n\n        // The VBR tag may NOT be located at the beginning of the stream. If an\n        // ID3 version 2 tag was added, then it must be skipped to write the VBR\n        // tag data.\n        var id3v2TagSize = skipId3v2(stream);\n\n        // Seek to the beginning of the stream\n        stream.seek(id3v2TagSize);\n\n        var buffer = new_byte(MAXFRAMESIZE);\n        var bytes = getLameTagFrame(gfp, buffer);\n        if (bytes > buffer.length) {\n            return -1;\n        }\n\n        if (bytes < 1) {\n            return 0;\n        }\n\n        // Put it all to disk again\n        stream.write(buffer, 0, bytes);\n        // success\n        return 0;\n    }\n\n}\n\nexport { VBRTag }","//package mp3;\n\n//import java.util.ArrayList;\n\n//import mp3.ID3Tag.MimeType;\n\nfunction ID3TagSpec() {\n    this.flags = 0;\n    this.year = 0;\n    this.title = null;\n    this.artist = null;\n    this.album = null;\n    this.comment = null;\n    this.track_id3v1 = 0;\n    this.genre_id3v1 = 0;\n    //byte[] albumart;\n    this.albumart = null;\n    this.albumart_size = 0;\n    this.padding_size = 0;\n    this.albumart_mimetype = null;\n    this.values = [];\n    this.num_values = 0;\n    this.v2_head = null;\n    this.v2_tail = null;\n}\n\n// Add the setModules method to the prototype\nID3TagSpec.prototype.setModules = function(bs, ver) {\n    this.bs = bs;\n    this.ver = ver;\n};\n\nexport { ID3TagSpec }","/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\n\nimport * as common from './common.js';\nvar assert = common.assert;\n\nfunction Reservoir() {\n\tvar bs;\n\n\tthis.setModules  = function(_bs) {\n\t\tbs = _bs;\n\t}\n\n\tthis.ResvFrameBegin = function(gfp, mean_bits) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar maxmp3buf;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar frameLength = bs.getframebits(gfp);\n\t\tmean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n\n\t\t/**\n\t\t * <PRE>\n\t\t *  Meaning of the variables:\n\t\t *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n\t\t *          Number of bits can be stored in previous frame(s) due to\n\t\t *          counter size constaints\n\t\t *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n\t\t *          Number of bits allowed to encode one frame (you can take 8*511 bit\n\t\t *          from the bit reservoir and at most 8*1440 bit from the current\n\t\t *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n\t\t *          value for MPEG-1 and -2)\n\t\t * \n\t\t *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n\t\t *          so this is the absolute maximum supported by the format.\n\t\t * \n\t\t * \n\t\t *      fullFrameBits:  maximum number of bits available for encoding\n\t\t *                      the current frame.\n\t\t * \n\t\t *      mean_bits:      target number of bits per granule.\n\t\t * \n\t\t *      frameLength:\n\t\t * \n\t\t *      gfc.ResvMax:   maximum allowed reservoir\n\t\t * \n\t\t *      gfc.ResvSize:  current reservoir size\n\t\t * \n\t\t *      l3_side.resvDrain_pre:\n\t\t *         ancillary data to be added to previous frame:\n\t\t *         (only usefull in VBR modes if it is possible to have\n\t\t *         maxmp3buf < fullFrameBits)).  Currently disabled,\n\t\t *         see #define NEW_DRAIN\n\t\t *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n\t\t *                     as there exists one example, where the FhG decoder\n\t\t *                     can't decode a -b320 CBR file anymore.\n\t\t * \n\t\t *      l3_side.resvDrain_post:\n\t\t *         ancillary data to be added to this frame:\n\t\t * \n\t\t * </PRE>\n\t\t */\n\n\t\t/* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n\t\tvar resvLimit = (8 * 256) * gfc.mode_gr - 8;\n\n\t\t/*\n\t\t * maximum allowed frame size. dont use more than this number of bits,\n\t\t * even if the frame has the space for them:\n\t\t */\n\t\tif (gfp.brate > 320) {\n\t\t\t/* in freeformat the buffer is constant */\n\t\t\tmaxmp3buf = 8 * ((int) ((gfp.brate * 1000)\n\t\t\t\t\t/ (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t} else {\n\t\t\t/*\n\t\t\t * all mp3 decoders should have enough buffer to handle this value:\n\t\t\t * size of a 320kbps 32kHz frame\n\t\t\t */\n\t\t\tmaxmp3buf = 8 * 1440;\n\n\t\t\t/*\n\t\t\t * Bouvigne suggests this more lax interpretation of the ISO doc\n\t\t\t * instead of using 8*960.\n\t\t\t */\n\n\t\t\tif (gfp.strict_ISO) {\n\t\t\t\tmaxmp3buf = 8 * ((int) (320000 / (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t\t}\n\t\t}\n\n\t\tgfc.ResvMax = maxmp3buf - frameLength;\n\t\tif (gfc.ResvMax > resvLimit)\n\t\t\tgfc.ResvMax = resvLimit;\n\t\tif (gfc.ResvMax < 0 || gfp.disable_reservoir)\n\t\t\tgfc.ResvMax = 0;\n\n\t\tvar fullFrameBits = mean_bits.bits * gfc.mode_gr\n\t\t\t\t+ Math.min(gfc.ResvSize, gfc.ResvMax);\n\n\t\tif (fullFrameBits > maxmp3buf)\n\t\t\tfullFrameBits = maxmp3buf;\n\n\t\tassert (0 == gfc.ResvMax % 8);\n\t\tassert (gfc.ResvMax >= 0);\n\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t// frame analyzer code\n\t\tif (gfc.pinfo != null) {\n\t\t\t/*\n\t\t\t * expected bits per channel per granule [is this also right for\n\t\t\t * mono/stereo, MPEG-1/2 ?]\n\t\t\t */\n\t\t\tgfc.pinfo.mean_bits = mean_bits.bits / 2;\n\t\t\tgfc.pinfo.resvsize = gfc.ResvSize;\n\t\t}\n\n\t\treturn fullFrameBits;\n\t}\n\n\t/**\n\t * returns targ_bits: target number of bits to use for 1 granule<BR>\n\t * extra_bits: amount extra available from reservoir<BR>\n\t * Mark Taylor 4/99\n\t */\n\tthis.ResvMaxBits = function(gfp, mean_bits, targ_bits, cbr) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar add_bits;\n        var ResvSize = gfc.ResvSize, ResvMax = gfc.ResvMax;\n\n\t\t/* compensate the saved bits used in the 1st granule */\n\t\tif (cbr != 0)\n\t\t\tResvSize += mean_bits;\n\n\t\tif ((gfc.substep_shaping & 1) != 0)\n\t\t\tResvMax *= 0.9;\n\n\t\ttarg_bits.bits = mean_bits;\n\n\t\t/* extra bits if the reservoir is almost full */\n\t\tif (ResvSize * 10 > ResvMax * 9) {\n\t\t\tadd_bits = ResvSize - (ResvMax * 9) / 10;\n\t\t\ttarg_bits.bits += add_bits;\n\t\t\tgfc.substep_shaping |= 0x80;\n\t\t} else {\n\t\t\tadd_bits = 0;\n\t\t\tgfc.substep_shaping &= 0x7f;\n\t\t\t/*\n\t\t\t * build up reservoir. this builds the reservoir a little slower\n\t\t\t * than FhG. It could simple be mean_bits/15, but this was rigged to\n\t\t\t * always produce 100 (the old value) at 128kbs\n\t\t\t */\n\t\t\tif (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1))\n\t\t\t\ttarg_bits.bits -= .1 * mean_bits;\n\t\t}\n\n\t\t/* amount from the reservoir we are allowed to use. ISO says 6/10 */\n\t\tvar extra_bits = (ResvSize < (gfc.ResvMax * 6) / 10 ? ResvSize\n\t\t\t\t: (gfc.ResvMax * 6) / 10);\n\t\textra_bits -= add_bits;\n\n\t\tif (extra_bits < 0)\n\t\t\textra_bits = 0;\n\t\treturn extra_bits;\n\t}\n\n\t/**\n\t * Called after a granule's bit allocation. Readjusts the size of the\n\t * reservoir to reflect the granule's usage.\n\t */\n\tthis.ResvAdjust = function(gfc, gi) {\n\t\tgfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n\t}\n\n\t/**\n\t * Called after all granules in a frame have been allocated. Makes sure that\n\t * the reservoir size is within limits, possibly by adding stuffing bits.\n\t */\n\tthis.ResvFrameEnd = function(gfc, mean_bits) {\n\t\tvar over_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tgfc.ResvSize += mean_bits * gfc.mode_gr;\n\t\tvar stuffingBits = 0;\n\t\tl3_side.resvDrain_post = 0;\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t/* we must be byte aligned */\n\t\tif ((over_bits = gfc.ResvSize % 8) != 0)\n\t\t\tstuffingBits += over_bits;\n\n\t\tover_bits = (gfc.ResvSize - stuffingBits) - gfc.ResvMax;\n\t\tif (over_bits > 0) {\n\t\t\tassert (0 == over_bits % 8);\n\t\t\tassert (over_bits >= 0);\n\t\t\tstuffingBits += over_bits;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n\t\t * decoder shipped with MS Windows operating systems. Using this, it is\n\t\t * even possible to use Gabriel's lax buffer consideration again, which\n\t\t * assumes, any decoder should have a buffer large enough for a 320 kbps\n\t\t * frame at 32 kHz sample rate.\n\t\t * \n\t\t * old drain code: lame -b320 BlackBird.wav --. does not play with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * new drain code: lame -b320 BlackBird.wav --. plays fine with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * Robert Hegemann, 2010-02-13.\n\t\t */\n\t\t/*\n\t\t * drain as many bits as possible into previous frame ancillary data In\n\t\t * particular, in VBR mode ResvMax may have changed, and we have to make\n\t\t * sure main_data_begin does not create a reservoir bigger than ResvMax\n\t\t * mt 4/00\n\t\t */\n\t\t{\n\t\t\tvar mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n\t\t\tl3_side.resvDrain_pre += 8 * mdb_bytes;\n\t\t\tstuffingBits -= 8 * mdb_bytes;\n\t\t\tgfc.ResvSize -= 8 * mdb_bytes;\n\t\t\tl3_side.main_data_begin -= mdb_bytes;\n\t\t}\n\t\t/* drain the rest into this frames ancillary data */\n\t\tl3_side.resvDrain_post += stuffingBits;\n\t\tgfc.ResvSize -= stuffingBits;\n\t}\n}\n\nexport { Reservoir }","/**\n * @fileoverview Preset handling for LAME configuration.\n * Ported from presets.c. Provides functions to apply predefined\n * sets of encoding parameters (presets) to the LAME global flags.\n * Uses ES Module syntax.\n *\n * @module Presets\n */\n\n// Import necessary modules and utilities using ES Module syntax\nimport * as common from './common.js';\nimport Lame from './Lame.js'; // Need Lame for preset constants (V0, V9, etc.)\n\n// Destructure common utilities for easier access\nconst {\n    VbrMode,\n    // System, // Not used\n    // Float, // Not used\n    // ShortBlock, // Not used\n    // Util, // Not used\n    // Arrays, // Not used\n    // new_array_n, // Not used\n    // new_byte, // Not used\n    // new_double, // Not used\n    // new_float, // Not used\n    // new_float_n, // Not used\n    // new_int, // Not used\n    // new_int_n, // Not used\n    // assert // Not used\n} = common;\n\n// Assuming these types are defined elsewhere\n/** @typedef {import('./LameGlobalFlags.js').default} LameGlobalFlags */\n\n// --- Internal Data Structures ---\n// (No JSDoc as requested)\n\n/** @private */\nclass VBRPresets {\n    constructor(qual, comp, compS, y, shThreshold, shThresholdS, adj, adjShort, lower, curve, sens, inter, joint, mod, fix) {\n        this.vbr_q = qual; this.quant_comp = comp; this.quant_comp_s = compS; this.expY = y;\n        this.st_lrm = shThreshold; this.st_s = shThresholdS; this.masking_adj = adj;\n        this.masking_adj_short = adjShort; this.ath_lower = lower; this.ath_curve = curve;\n        this.ath_sensitivity = sens; this.interch = inter; this.safejoint = joint;\n        this.sfb21mod = mod; this.msfix = fix;\n    }\n}\n\n/** @private */\nclass ABRPresets {\n    constructor(kbps, comp, compS, joint, fix, shThreshold, shThresholdS, bass, sc, mask, lower, curve, interCh, sfScale) {\n        this.kbps = kbps; // Added kbps field for clarity\n        this.quant_comp = comp; this.quant_comp_s = compS; this.safejoint = joint;\n        this.nsmsfix = fix; this.st_lrm = shThreshold; this.st_s = shThresholdS;\n        this.nsbass = bass; this.scale = sc; this.masking_adj = mask;\n        this.ath_lower = lower; this.ath_curve = curve; this.interch = interCh;\n        this.sfscale = sfScale;\n    }\n}\n\n// --- Preset Data Tables ---\n// (Moved inside the class or module scope if they don't need to be global)\n\n\n/**\n * @classdesc Manages LAME presets. Provides methods to apply predefined\n * sets of encoding parameters based on VBR quality levels or ABR bitrates.\n * @constructs Presets\n */\nclass Presets {\n    /** @private @type {Lame|null} Reference to main Lame object (needed for Lame.nearestBitrateFullIndex). */\n    lame = null;\n\n    /**\n     * Preset definitions for VBR mode VBR_RH (older psychoacoustic model).\n     * @private\n     * @const {VBRPresets[]}\n     */\n    vbr_old_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 5.20, 125.0, -4.2, -6.3, 4.8, 1, 0, 0, 2, 21, 0.97),\n        new VBRPresets(1, 9, 9, 0, 5.30, 125.0, -3.6, -5.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 5.60, 125.0, -2.2, -3.5, 2.8, 2, 0, 0, 2, 21, 1.49),\n        new VBRPresets(3, 9, 9, 1, 5.80, 130.0, -1.8, -2.8, 2.6, 3, -4, 0, 2, 20, 1.64),\n        new VBRPresets(4, 9, 9, 1, 6.00, 135.0, -0.7, -1.1, 1.1, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 6.40, 140.0, 0.5, 0.4, -7.5, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 6.60, 145.0, 0.67, 0.65, -14.7, 6.5, -19, 0.0004, 0, 0, 2.30),\n        new VBRPresets(7, 9, 9, 1, 6.60, 145.0, 0.8, 0.75, -19.7, 8, -22, 0.0006, 0, 0, 2.70),\n        new VBRPresets(8, 9, 9, 1, 6.60, 145.0, 1.2, 1.15, -27.5, 10, -23, 0.0007, 0, 0, 0), // msfix 0?\n        new VBRPresets(9, 9, 9, 1, 6.60, 145.0, 1.6, 1.6, -36, 11, -25, 0.0008, 0, 0, 0), // msfix 0?\n        new VBRPresets(10, 9, 9, 1, 6.60, 145.0, 2.0, 2.0, -36, 12, -25, 0.0008, 0, 0, 0) // Dummy for VBR_q=9 + frac\n    ];\n\n    /**\n     * Preset definitions for VBR modes using newer psychoacoustic models (VBR_MT, VBR_MTRH).\n     * @private\n     * @const {VBRPresets[]}\n     */\n    vbr_psy_switch_map = [\n        new VBRPresets(0, 9, 9, 0, 4.20, 25.0, -7.0, -4.0, 7.5, 1, 0, 0, 2, 26, 0.97),\n        new VBRPresets(1, 9, 9, 0, 4.20, 25.0, -5.6, -3.6, 4.5, 1.5, 0, 0, 2, 21, 1.35),\n        new VBRPresets(2, 9, 9, 0, 4.20, 25.0, -4.4, -1.8, 2, 2, 0, 0, 2, 18, 1.49),\n        new VBRPresets(3, 9, 9, 1, 4.20, 25.0, -3.4, -1.25, 1.1, 3, -4, 0, 2, 15, 1.64),\n        new VBRPresets(4, 9, 9, 1, 4.20, 25.0, -2.2, 0.1, 0, 3.5, -8, 0, 2, 0, 1.79),\n        new VBRPresets(5, 9, 9, 1, 4.20, 25.0, -1.0, 1.65, -7.7, 4, -12, 0.0002, 0, 0, 1.95),\n        new VBRPresets(6, 9, 9, 1, 4.20, 25.0, -0.0, 2.47, -7.7, 6.5, -19, 0.0004, 0, 0, 2),\n        new VBRPresets(7, 9, 9, 1, 4.20, 25.0, 0.5, 2.0, -14.5, 8, -22, 0.0006, 0, 0, 2),\n        new VBRPresets(8, 9, 9, 1, 4.20, 25.0, 1.0, 2.4, -22.0, 10, -23, 0.0007, 0, 0, 2),\n        new VBRPresets(9, 9, 9, 1, 4.20, 25.0, 1.5, 2.95, -30.0, 11, -25, 0.0008, 0, 0, 2),\n        new VBRPresets(10, 9, 9, 1, 4.20, 25.0, 2.0, 2.95, -36.0, 12, -30, 0.0008, 0, 0, 2) // Dummy for VBR_q=9 + frac\n    ];\n\n     /**\n     * Preset definitions for ABR mode. Indexed by bitrate index from `nearestBitrateFullIndex`.\n     * @private\n     * @const {ABRPresets[]}\n     */\n     abr_switch_map = [\n        // Index corresponds roughly to bitrate index (0=8k, 1=16k, ...)\n        // Values need verification against LAME C source presets.c\n        new ABRPresets(8, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -30.0, 11, 0.0012, 1), //   8kbps\n        new ABRPresets(16, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -25.0, 11, 0.0010, 1), //  16kbps\n        new ABRPresets(24, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -20.0, 11, 0.0010, 1), //  24kbps\n        new ABRPresets(32, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -15.0, 11, 0.0010, 1), //  32kbps\n        new ABRPresets(40, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), //  40kbps\n        new ABRPresets(48, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -10.0, 11, 0.0009, 1), //  48kbps\n        new ABRPresets(56, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -6.0, 11, 0.0008, 1), //  56kbps\n        new ABRPresets(64, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, -2.0, 11, 0.0008, 1), //  64kbps\n        new ABRPresets(80, 9, 9, 0, 0, 6.60, 145, 0, 0.95, 0, 0.0, 8, 0.0007, 1), //  80kbps\n        new ABRPresets(96, 9, 9, 0, 2.50, 6.60, 145, 0, 0.95, 0, 1.0, 5.5, 0.0006, 1), //  96kbps\n        new ABRPresets(112, 9, 9, 0, 2.25, 6.60, 145, 0, 0.95, 0, 2.0, 4.5, 0.0005, 1), // 112kbps\n        new ABRPresets(128, 9, 9, 0, 1.95, 6.40, 140, 0, 0.95, 0, 3.0, 4, 0.0002, 1), // 128kbps\n        new ABRPresets(160, 9, 9, 1, 1.79, 6.00, 135, 0, 0.95, -2, 5.0, 3.5, 0, 1), // 160kbps\n        new ABRPresets(192, 9, 9, 1, 1.49, 5.60, 125, 0, 0.97, -4, 7.0, 3, 0, 0), // 192kbps\n        new ABRPresets(224, 9, 9, 1, 1.25, 5.20, 125, 0, 0.98, -6, 9.0, 2, 0, 0), // 224kbps\n        new ABRPresets(256, 9, 9, 1, 0.97, 5.20, 125, 0, 1.00, -8, 10.0, 1, 0, 0), // 256kbps\n        new ABRPresets(320, 9, 9, 1, 0.90, 5.20, 125, 0, 1.00, -10, 12.0, 0, 0, 0) // 320kbps\n    ];\n\n    constructor() {\n        // Module set externally\n    }\n\n    /**\n     * Sets the internal Lame object reference.\n     * @public\n     * @param {Lame} _lame - The main Lame instance.\n     */\n    setModules(_lame) {\n        this.lame = _lame;\n    }\n\n    // --- Private Helper Methods ---\n    // (JSDoc omitted for brevity)\n\n    /** @private */\n    _apply_vbr_preset(gfp, a, enforce) {\n        const vbr_preset = gfp.VBR === VbrMode.vbr_rh ? this.vbr_old_switch_map : this.vbr_psy_switch_map;\n        const x = gfp.VBR_q_frac;\n\n        // Ensure 'a' is within bounds for interpolation\n        const p_idx = Math.max(0, Math.min(a, vbr_preset.length - 2));\n        const q_idx = p_idx + 1;\n        const p = vbr_preset[p_idx];\n        const q = vbr_preset[q_idx];\n\n        // Create a temporary preset object by interpolating p and q\n        const set = new VBRPresets(\n            p.vbr_q, p.quant_comp, p.quant_comp_s, p.expY,\n            p.st_lrm + x * (q.st_lrm - p.st_lrm),\n            p.st_s + x * (q.st_s - p.st_s),\n            p.masking_adj + x * (q.masking_adj - p.masking_adj),\n            p.masking_adj_short + x * (q.masking_adj_short - p.masking_adj_short),\n            p.ath_lower + x * (q.ath_lower - p.ath_lower),\n            p.ath_curve + x * (q.ath_curve - p.ath_curve),\n            p.ath_sensitivity + x * (q.ath_sensitivity - p.ath_sensitivity),\n            p.interch + x * (q.interch - p.interch),\n            p.safejoint, p.sfb21mod,\n            p.msfix + x * (q.msfix - p.msfix)\n        );\n\n        // Apply interpolated values to gfp, respecting enforce flag\n        // Uses SET_OPTION logic from C (apply if enforce=true or if current value is default)\n\n        this._lame_set_VBR_q(gfp, set.vbr_q); // Use internal helper\n\n        if (enforce !== 0 || gfp.quant_comp === -1) gfp.quant_comp = set.quant_comp;\n        if (enforce !== 0 || gfp.quant_comp_short === -1) gfp.quant_comp_short = set.quant_comp_s;\n        if (set.expY !== 0) gfp.experimentalY = true; // Only turn on, never off? Check C.\n        if (enforce !== 0 || gfp.internal_flags.nsPsy.attackthre === -1) gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        if (enforce !== 0 || gfp.internal_flags.nsPsy.attackthre_s === -1) gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        if (enforce !== 0 || Math.abs(gfp.maskingadjust) < 1e-6) gfp.maskingadjust = set.masking_adj;\n        if (enforce !== 0 || Math.abs(gfp.maskingadjust_short) < 1e-6) gfp.maskingadjust_short = set.masking_adj_short;\n        if (enforce !== 0 || Math.abs(gfp.ATHlower) < 1e-6) gfp.ATHlower = -set.ath_lower / 10.0; // Note sign change and scaling\n        if (enforce !== 0 || gfp.ATHcurve === -1) gfp.ATHcurve = set.ath_curve;\n        if (enforce !== 0 || gfp.athaa_sensitivity === 0) gfp.athaa_sensitivity = set.ath_sensitivity; // Check default value\n        if (set.interch > 0) { if (enforce !== 0 || gfp.interChRatio === -1.0) gfp.interChRatio = set.interch; }\n        if (set.safejoint > 0) gfp.exp_nspsytune |= set.safejoint; // Use bitwise OR\n        if (set.sfb21mod > 0) gfp.exp_nspsytune |= (set.sfb21mod << 20);\n        if (enforce !== 0 || gfp.msfix === -1.0) gfp.msfix = set.msfix;\n\n        // If not enforcing, store the original VBR quality settings used for interpolation\n        if (enforce === 0) {\n            gfp.VBR_q = a;\n            gfp.VBR_q_frac = x;\n        }\n    }\n\n     /** @private */\n     _apply_abr_preset(gfp, preset, enforce) {\n        const actual_bitrate = preset; // Use preset directly as bitrate\n        // Find the index corresponding to the nearest standard bitrate\n        const r = this.lame._nearestBitrateFullIndex(preset); // Need access to Lame instance method\n\n        // Set VBR mode and bitrate\n        gfp.VBR = VbrMode.vbr_abr;\n        gfp.VBR_mean_bitrate_kbps = actual_bitrate;\n        // Clamp bitrate (redundant if using nearest index, but good practice)\n        gfp.VBR_mean_bitrate_kbps = Math.min(gfp.VBR_mean_bitrate_kbps, 320);\n        gfp.VBR_mean_bitrate_kbps = Math.max(gfp.VBR_mean_bitrate_kbps, 8);\n        gfp.brate = gfp.VBR_mean_bitrate_kbps; // Also set CBR rate for ABR\n\n        // Disable reservoir if bitrate is very high (emulating C behavior)\n        if (gfp.VBR_mean_bitrate_kbps > 320) { gfp.disable_reservoir = true; }\n\n        // Apply settings from the abr_switch_map using SET_OPTION logic\n        const set = this.abr_switch_map[r];\n        if (!set) {\n            console.error(`ABR preset not found for index ${r} (bitrate ${preset})`);\n            return preset; // Return original value on error\n        }\n\n        if (set.safejoint > 0) gfp.exp_nspsytune |= 2; // Use constant 2 for safejoint flag\n        if (set.sfscale > 0) gfp.internal_flags.noise_shaping = 2;\n        if (Math.abs(set.nsbass) > 1e-6) { let k = Math.floor(set.nsbass * 4); if (k < 0) k += 64; gfp.exp_nspsytune |= (k << 2); }\n\n        if (enforce !== 0 || gfp.quant_comp === -1) gfp.quant_comp = set.quant_comp;\n        if (enforce !== 0 || gfp.quant_comp_short === -1) gfp.quant_comp_short = set.quant_comp_s;\n        if (enforce !== 0 || gfp.msfix === -1.0) gfp.msfix = set.nsmsfix;\n        if (enforce !== 0 || gfp.internal_flags.nsPsy.attackthre === -1) gfp.internal_flags.nsPsy.attackthre = set.st_lrm;\n        if (enforce !== 0 || gfp.internal_flags.nsPsy.attackthre_s === -1) gfp.internal_flags.nsPsy.attackthre_s = set.st_s;\n        if (enforce !== 0 || gfp.scale === -1.0) gfp.scale = set.scale;\n        if (enforce !== 0 || Math.abs(gfp.maskingadjust) < 1e-6) gfp.maskingadjust = set.masking_adj;\n        // Set maskingadjust_short based on maskingadjust\n        const short_adj = (set.masking_adj > 0) ? (set.masking_adj * 0.9) : (set.masking_adj * 1.1);\n        if (enforce !== 0 || Math.abs(gfp.maskingadjust_short) < 1e-6) gfp.maskingadjust_short = short_adj;\n        if (enforce !== 0 || Math.abs(gfp.ATHlower) < 1e-6) gfp.ATHlower = -set.ath_lower / 10.0;\n        if (enforce !== 0 || gfp.ATHcurve === -1) gfp.ATHcurve = set.ath_curve;\n        if (enforce !== 0 || gfp.interChRatio === -1.0) gfp.interChRatio = set.interch;\n\n        return preset; // Return the target bitrate\n    }\n\n    /** @private */\n    _lame_set_VBR_q(gfp, VBR_q) {\n        let ret = 0;\n        if (VBR_q < 0) { ret = -1; VBR_q = 0; }\n        if (VBR_q > 9) { ret = -1; VBR_q = 9; }\n        gfp.VBR_q = VBR_q;\n        gfp.VBR_q_frac = 0; // Reset fractional part when setting integer quality\n        return ret;\n    }\n\n\n    // --- Public Methods ---\n\n    /**\n     * Applies a predefined preset to the LAME configuration.\n     * This modifies various settings in the `gfp` (LameGlobalFlags) object\n     * based on the chosen preset (VBR quality level or ABR bitrate).\n     * Handles translation of legacy preset constants.\n     *\n     * @public\n     * @param {LameGlobalFlags} gfp - The LAME global flags structure to modify.\n     * @param {number} preset - The preset value. Can be one of the Lame.V constants (V0-V9),\n     *                          one of the legacy constants (STANDARD, EXTREME, etc.), or an\n     *                          ABR bitrate value (8-320).\n     * @param {number} enforce - If non-zero, forces all preset settings onto `gfp`, overwriting\n     *                           any user-defined values for those specific parameters. If zero,\n     *                           only applies preset settings if the corresponding `gfp` value\n     *                           is still at its default/uninitialized state.\n     * @returns {number} The effective preset value applied (e.g., the actual ABR bitrate used). Returns the input `preset` if it was not a recognized preset value.\n     */\n    apply_preset(gfp, preset, enforce) {\n        let original_preset = preset; // Keep original for potential ABR\n\n        // Translate legacy presets to VBR quality levels (-V) and set VBR mode\n        switch (preset) {\n            case Lame.R3MIX:        preset = Lame.V3; gfp.VBR = VbrMode.vbr_mtrh; break;\n            case Lame.MEDIUM:       preset = Lame.V4; gfp.VBR = VbrMode.vbr_rh; break;\n            case Lame.MEDIUM_FAST:  preset = Lame.V4; gfp.VBR = VbrMode.vbr_mtrh; break;\n            case Lame.STANDARD:     preset = Lame.V2; gfp.VBR = VbrMode.vbr_rh; break;\n            case Lame.STANDARD_FAST:preset = Lame.V2; gfp.VBR = VbrMode.vbr_mtrh; break;\n            case Lame.EXTREME:      preset = Lame.V0; gfp.VBR = VbrMode.vbr_rh; break;\n            case Lame.EXTREME_FAST: preset = Lame.V0; gfp.VBR = VbrMode.vbr_mtrh; break;\n            case Lame.INSANE: // Special case: Maps to 320kbps ABR (or CBR)\n                preset = 320; gfp.preset = preset; // Store the target bitrate\n                this._apply_abr_preset(gfp, preset, enforce);\n                // Insane is often CBR, override VBR setting from ABR preset\n                gfp.VBR = VbrMode.vbr_off;\n                return preset; // Return the bitrate\n        }\n\n        gfp.preset = preset; // Store the potentially translated VBR preset value\n\n        // Apply VBR preset (-V settings)\n        if (preset >= Lame.V9 && preset <= Lame.V0) {\n             const vbr_quality_index = 9 - Math.floor((preset - Lame.V9) / 10); // Map V9..V0 to index 9..0\n             this._apply_vbr_preset(gfp, vbr_quality_index, enforce);\n             return preset; // Return the original V preset value\n        }\n\n        // Apply ABR preset (numeric bitrate value)\n        if (preset >= 8 && preset <= 320) {\n             return this._apply_abr_preset(gfp, preset, enforce); // Returns the actual bitrate used\n        }\n\n        // If no preset matched\n        console.warn(`Preset value ${original_preset} not recognized.`);\n        gfp.preset = 0; // Reset preset value\n        return original_preset; // Return the original unrecognized value\n    }\n\n}\n\nexport { Presets };\nexport default Presets; // Also provide default export if needed","import { Version } from '../lib/Version.js';\nimport { BitStream } from '../lib/BitStream.js';\nimport { GainAnalysis } from '../lib/GainAnalysis.js';\nimport { Quantize} from '../lib/Quantize.js';\nimport { VBRTag } from '../lib/VBRTag.js';\nimport { ID3TagSpec } from '../lib/ID3TagSpec.js';\nimport { Reservoir } from '../lib/Reservoir.js';\nimport { Takehiro } from '../lib/Takehiro.js';\nimport { QuantizePVT } from '../lib/QuantizePVT.js';\nimport { Presets } from '../lib/Presets.js';\nimport { Lame } from '../lib/Lame.js';\nimport { PsyModel } from '../lib/PsyModel.js';\n\nexport class LameContext {\n    // All module instances\n    public version: Version;\n    public bitStream: BitStream;\n    public gainAnalysis: GainAnalysis;\n    public quantize: Quantize;\n    public vbrTag: VBRTag;\n    public id3: ID3TagSpec;\n    public reservoir: Reservoir;\n    public takehiro: Takehiro;\n    public quantizePVT: QuantizePVT;\n    public presets: Presets;\n    public lame: Lame;\n    public psyModel: PsyModel;\n\n    constructor() {\n        // Create instances first\n        this.id3 = new ID3TagSpec();\n        this.reservoir = new Reservoir();\n        this.quantizePVT = new QuantizePVT();\n        this.takehiro = new Takehiro(this);\n        this.quantize = new Quantize();\n        this.vbrTag = new VBRTag();\n        this.presets = new Presets();\n        this.lame = new Lame();\n        this.version = new Version(this);\n        this.bitStream = new BitStream(this);\n        this.gainAnalysis = new GainAnalysis();\n        this.psyModel = new PsyModel();\n\n        // Then initialize modules with their dependencies\n        this.quantizePVT.setModules(this.takehiro, this.reservoir, this.psyModel);\n        this.takehiro.setModules(this.quantizePVT);\n        this.quantize.setModules(this.bitStream, this.reservoir, this.quantizePVT, this.takehiro);\n        this.presets.setModules(this.lame);\n        this.bitStream.setModules(this.gainAnalysis, null, this.version, this.vbrTag);\n        this.id3.setModules(this.bitStream, this.version);\n        this.reservoir.setModules(this.bitStream);\n        this.vbrTag.setModules(this.lame, this.bitStream, this.version);\n        this.lame.setModules(\n            this.gainAnalysis,\n            this.bitStream,\n            this.presets,            \n            this.quantizePVT,\n            this.quantize, \n            this.vbrTag,\n            this.version,\n            this.id3,\n            null\n        );\n    }\n} ","import { MPEGMode, MPEGModeValues } from './MPEGMode.js';\nimport type { Mp3Config } from './types.js'; // Assuming this path is correct\nimport { LameContext } from './LameContext.js';\nimport * as common from '../lib/common.js'; // Import common for VbrMode\n// Import specific types needed from Lame if not relying on context's typing\n// import { Lame } from '../lib/Lame.js';\n// import { LameGlobalFlags } from '../lib/LameGlobalFlags.js';\n\n// These imports might not be strictly necessary here if only using context\n// but keep them if they are used for type hints elsewhere or were part of the original structure\n/*\nimport { BitStream } from '../lib/BitStream.js';\nimport { GainAnalysis } from '../lib/GainAnalysis.js';\nimport { Quantize} from '../lib/Quantize.js';\nimport { VBRTag } from '../lib/VBRTag.js';\nimport { Version } from '../lib/Version.js';\nimport { ID3TagSpec } from '../lib/ID3TagSpec.js'; // Assuming this exists if needed\nimport { Reservoir } from '../lib/Reservoir.js';\nimport { Takehiro } from '../lib/Takehiro.js';\nimport { QuantizePVT } from '../lib/QuantizePVT.js';\nimport { Presets } from '../lib/Presets.js';\n*/\n\nexport class Mp3Encoder {\n    private context: LameContext;\n    private gfp: any; // Keep as any, or import LameGlobalFlags type\n    private maxSamples: number;\n    private mp3buf: Uint8Array;\n    private mp3buf_size: number;\n\n    constructor(config: Mp3Config) {\n        // Create context\n        this.context = new LameContext();\n\n        // Initialize LAME using context\n        this.gfp = this.context.lame.lame_init();\n        if (!this.gfp) {\n            throw new Error('Failed to initialize LAME library.');\n        }\n\n        // Set configuration from Mp3Config interface\n        this.gfp.num_channels = config.channels;\n        this.gfp.in_samplerate = config.sampleRate;\n        this.gfp.brate = config.bitRate; // Set bitrate for CBR\n\n        // Map the mode directly\n        const modeMap = {\n            [MPEGMode.STEREO]: MPEGModeValues.STEREO,\n            [MPEGMode.JOINT_STEREO]: MPEGModeValues.JOINT_STEREO,\n            [MPEGMode.DUAL_CHANNEL]: MPEGModeValues.DUAL_CHANNEL,\n            [MPEGMode.MONO]: MPEGModeValues.MONO,\n            [MPEGMode.NOT_SET]: MPEGModeValues.NOT_SET\n        };\n        // Use STEREO as default if mode is undefined or NOT_SET\n        this.gfp.mode = modeMap[config.mode ?? MPEGMode.STEREO];\n        // Ensure mode is valid if explicitly set to NOT_SET or based on channels\n        if (this.gfp.mode === MPEGModeValues.NOT_SET || this.gfp.num_channels === 1) {\n             this.gfp.mode = (config.channels === 1) ? MPEGModeValues.MONO : MPEGModeValues.STEREO;\n        }\n\n        this.gfp.quality = config.quality ?? 3; // Use nullish coalescing for default\n\n        // --- Assume CBR by default, no VBR settings from config ---\n        this.gfp.VBR = common.VbrMode.vbr_off; // Set to CBR mode\n        this.gfp.bWriteVbrTag = false; // VBR tag not needed for CBR\n\n        // Other defaults (could potentially be added to Mp3Config if needed)\n        this.gfp.disable_reservoir = true; // Commonly used default? Consider making configurable.\n        this.gfp.write_id3tag_automatic = false; // Usually handled separately\n\n        const retcode = this.context.lame.lame_init_params(this.gfp);\n        if (retcode !== 0) {\n            throw new Error(`Failed to initialize LAME encoder parameters (code ${retcode})`);\n        }\n\n        // Set up buffers\n        // Allow configuration via maxBuffer, fall back to 1152\n        this.maxSamples = config.maxBuffer || 1152;\n        this.mp3buf_size = Math.floor(1.25 * this.maxSamples + 7200);\n        this.mp3buf = new Uint8Array(this.mp3buf_size);\n    }\n\n    /**\n     * Encodes a buffer of PCM audio samples.\n     * Input can be Int16Array or Float32Array.\n     * For stereo, provide equal length arrays for left and right channels.\n     * For mono, provide the single channel data as the `left` argument.\n     *\n     * @public\n     * @param {Float32Array | Int16Array} left - Array of PCM samples for the left channel (or mono channel). Float values should be in [-1.0, 1.0].\n     * @param {Float32Array | Int16Array | null | undefined} [right] - Array of PCM samples for the right channel. Must be the same length and type as `left`. Required for stereo.\n     * @returns {Int8Array} A Int8Array containing the encoded MP3 data for this buffer.\n     * @throws {Error} If input arrays have mismatched types or lengths for stereo, or if right channel is missing for stereo.\n     */\n    public encodeBuffer(left: Float32Array | Int16Array, right?: Float32Array | Int16Array | null): Int8Array {\n        let inputRight: Float32Array | Int16Array | null = right ?? null;\n        const isFloat = left instanceof Float32Array;\n\n        // Handle mono case and basic validation\n        if (this.gfp.num_channels === 1) {\n            inputRight = left; // LAME internal processing uses left for both in mono mode\n        } else { // Stereo\n            if (!inputRight) {\n                throw new Error('Right channel buffer required for stereo encoding.');\n            }\n            if (left.length !== inputRight.length) {\n                throw new Error('Left and right channel buffers must have the same length.');\n            }\n            if (left.constructor !== inputRight.constructor) {\n                 throw new Error('Left and right channel buffers must have the same type (Float32Array or Int16Array).');\n            }\n        }\n\n        // Resize MP3 buffer if needed\n        if (left.length > this.maxSamples) {\n            console.warn(`Input buffer size (${left.length}) exceeds configured maxSamples (${this.maxSamples}). Resizing MP3 buffer.`);\n            this.maxSamples = left.length;\n            this.mp3buf_size = Math.floor(1.25 * this.maxSamples + 7200);\n            this.mp3buf = new Uint8Array(this.mp3buf_size);\n        }\n\n        let encodedSize = 0;\n\n        // Call the appropriate LAME encoding function based on input type\n        if (isFloat) {\n            const rightFloat = (inputRight instanceof Float32Array) ? inputRight : (this.gfp.num_channels === 1 ? left as Float32Array : null);\n            if(this.gfp.num_channels === 2 && !rightFloat){ throw new Error('Right Float32Array buffer needed for stereo float encoding.'); }\n\n            encodedSize = this.context.lame.lame_encode_buffer_ieee_float(\n                this.gfp, left as Float32Array, rightFloat, left.length,\n                this.mp3buf, 0, this.mp3buf_size\n            );\n        } else { // Input is Int16Array\n            const rightInt = (inputRight instanceof Int16Array) ? inputRight : (this.gfp.num_channels === 1 ? left as Int16Array : null);\n            if(this.gfp.num_channels === 2 && !rightInt){ throw new Error('Right Int16Array buffer needed for stereo int encoding.'); }\n\n            encodedSize = this.context.lame.lame_encode_buffer(\n                this.gfp, left as Int16Array, rightInt, left.length,\n                this.mp3buf, 0, this.mp3buf_size\n            );\n        }\n\n         if (encodedSize < 0) {\n             throw new Error(`LAME encoding failed with error code: ${encodedSize}`);\n         }\n\n        // Return the encoded data as Int8Array view\n        return new Int8Array(this.mp3buf.buffer, this.mp3buf.byteOffset, encodedSize);\n    }\n\n    /**\n     * Finalizes the MP3 stream, flushing any remaining data.\n     * @public\n     * @returns {Int8Array} A Int8Array containing the final MP3 data.\n     */\n    public flush(): Int8Array {\n        if (!this.gfp) {\n             console.warn(\"Encoder already closed or not initialized.\");\n             return new Int8Array(0);\n        }\n        const finalSize = this.context.lame.lame_encode_flush(\n            this.gfp,\n            this.mp3buf,\n            0,\n            this.mp3buf_size\n        );\n        if (finalSize < 0) {\n             throw new Error(`LAME flush failed with error code: ${finalSize}`);\n        }\n\n        return new Int8Array(this.mp3buf.buffer, this.mp3buf.byteOffset, finalSize);\n    }\n\n    /**\n     * Closes the encoder and releases resources (currently just calls flush).\n     * @public\n     */\n    public close(): void {\n        if (this.gfp) {\n             try {\n                 this.context.lame.lame_encode_flush(this.gfp, this.mp3buf, 0, this.mp3buf_size);\n             } catch (e) {\n                  console.error(\"Error during LAME close/flush:\", e);\n             }\n             this.gfp = null; // Mark as closed\n        }\n    }\n}"],"mappings":"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,mBACA,kBACA,kBACA,kBACA,mBACA,kBACA,kBACA,mBACA,kBACA,kBACA,mBACA,oBACA,oBACA,mBACA,kBAAuB,kBAEvB,oBACA,mBACA,mBACA,kBACA,mBACA,mBACA,kBACA,mBACA,mBACA,kBACA,kBACA,kBACA,mBACA,oBACA,oBACA,mBACA,kBAAuB,kBAEvB,mBACA,kBACA,kBACA,kBACA,mBACA,mBACA,kBACA,mBACA,mBACA,kBACA,kBACA,kBACA,kBACA,oBACA,mBACA,oBACA,kBAAuB,kBAEvB,oBACA,kBACA,kBACA,kBACA,mBACA,mBACA,mBACA,mBACA,kBACA,mBACA,kBACA,kBACA,mBACA,oBACA,oBACA,mBACA,kBAAuB,kBAEvB,oBACA,kBACA,kBACA,kBACA,kBACA,mBACA,mBACA,mBACA,kBACA,mBACA,mBACA,kBACA,kBACA,kBACA,mBACA,kBACA,kBAAuB,kBAEvB,oBACA,mBACA,kBACA,mBACA,mBACA,kBACA,mBACA,mBACA,mBACA,mBACA,kBACA,mBACA,mBACA,oBACA,oBACA,oBACA,mBACA,kBAEA,oBACA,mBACA,mBACA,oBACA,mBACA,kBACA,kBACA,mBACA,mBACA,kBACA,kBACA,kBACA,oBACA,mBACA,mBACA,oBACA,kBAAuB,kBAEvB,mBACA,iBACA,mBACA,mBACA,mBACA,mBACA,kBACA,mBACA,kBACA,kBACA,mBACA,mBACA,oBACA,oBACA,iBACA,oBACA,kBAAuB,iBAEvB,mBACA,kBACA,mBACA,mBACA,kBACA,mBACA,kBACA,mBACA,mBACA,kBACA,kBACA,kBACA,oBACA,oBACA,mBACA,mBACA,kBAAuB,iBAEvB,mBACA,kBACA,mBACA,mBACA,mBACA,mBACA,kBACA,mBACA,mBACA,oBACA,mBACA,mBACA,oBACA,oBACA,oBACA,mBACA,iBAAuB,kBAEvB,mBACA,kBACA,iBACA,oBACA,mBACA,mBACA,mBACA,mBACA,mBACA,oBACA,mBACA,mBACA,oBACA,mBACA,mBACA,mBACA,kBAAuB,kBAEvB,mBACA,iBACA,kBACA,oBACA,mBACA,kBACA,kBACA,mBACA,mBACA,oBACA,mBACA,kBACA,oBACA,oBACA,mBACA,mBACA,mBAAuB,kBAEvB,kBACA,kBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,kBACA,oBACA,kBACA,iBACA,oBACA,oBACA,oBACA,mBACA,mBAAuB,kBAEvB,WAAgBC,GAAK,MAAQ,GAAM,QACnC,WAAgBA,GAAK,MAAQ,GAAM,QACnC,WAAeA,GAAK,MAAQ,GAAM,QAClC,WAAeA,GAAK,MAAQ,GAAM,QAClC,UAAcA,GAAK,MAAQ,GAAM,QACjC,UAAcA,GAAK,MAAQ,GAAM,QACjC,UAAcA,GAAK,MAAQ,GAAM,QACjC,SAAaA,GAAK,MAAQ,GAAM,QAEhC,mBAA2B,mBAC3B,kBAAyB,mBACzB,mBAA0B,kBAC1B,kBACF,EAEIC,EAAK,GACLC,EAAK,GAELC,EAAM,CACN,CACC,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,oBACA,qBACA,qBAEA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBAEA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBAEA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,qBACA,qBACA,EACD,CACC,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBAEA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBAEA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,qBACA,sBAEA,EACA,EACA,EACA,EACA,EACA,EACA,sBACA,sBACA,qBACA,EACD,CACC,kBACA,iBACA,kBAEA,kBACA,kBACA,iBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBAEA,iBACA,kBACA,kBACA,kBACA,mBACA,mBACA,kBACA,GAEA,mBACA,mBACA,mBACA,mBACA,oBACA,oBACA,oBACA,qBAEA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,iBACA,iBACA,EACD,CACC,EAC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CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAC3N,IAAIA,GAAS,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAC3N,IAAIA,GAAS,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EACvN,IAAIA,GAAS,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,GAAG,EAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAAG,CAAC,EAAG,EAAG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","names":["index_exports","__export","MPEGMode","Mp3Encoder","__toCommonJS","MPEGMode","MPEGModeValues","Version","context","common_exports","__export","Arrays","Float","ShortBlock","System","Util","VbrMode","assert","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","new_short","new_short_n","count","args","sz","A","i","a","fromIndex","toIndex","val","src","srcPos","dest","destPos","length","srcEnd","message","x","y","ordinal","System","Util","Arrays","new_float","NewMDCT","enwindow","Util","NS","NL","win","tantab_l","Encoder","cx","ca","cs","order","window_subband","x1","x1Pos","a","wp","x2","i","w","s","t","u","v","xr","mdct_short","inout","inoutPos","l","tc0","tc1","tc2","ts0","ts1","ts2","mdct_long","out","outPos","_in","ct","st","tc3","tc4","ts5","ts6","ts7","ts8","ts3","ts4","tc5","tc6","tc7","tc8","gfc","w0","w1","wk","wkPos","ch","gr","band","gi","mdct_enc","mdct_encPos","samp","sampPos","k","type","band0","band1","Arrays","work","new_float","b","bu","bd","System","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","III_psy_xmin","Encoder","iii_psy_xmin","i","j","III_psy_ratio","III_psy_xmin","MPEGMode","ordinal","_ordinal","L3Side","__publicField","SBMAX_s","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_float","new_float_n","new_int","new_int_n","assert","common_exports","_Encoder","__publicField","NewMDCT","_bs","_psy","_qupvt","_vbr","gfc","gfp","inbuf","inbuf_l","inbuf_r","mp3buf","mp3bufPos","mp3buf_size","mp3count","masking_LR","III_psy_ratio","masking_MS","masking","ms_ener_ratio","pe","pe_MS","pe_use","ch","gr","ret","bufp","blocktype","bufpPos","VbrMode","MPEGMode","total_ms_energy","cod_info","sum_pe_MS","sum_pe_LR","types_match_gr0","types_match_gr1","f","i","target_avg_pe","Encoder","ENCDELAY","Encoder","POSTDELAY","MDCTDELAY","FFTOFFSET","DECDELAY","SBLIMIT","CBANDS","SBPSY_l","SBPSY_s","SBMAX_l","SBMAX_s","PSFB21","PSFB12","BLKSIZE","HBLKSIZE","BLKSIZE_s","HBLKSIZE_s","NORM_TYPE","START_TYPE","SHORT_TYPE","STOP_TYPE","MPG_MD_LR_LR","MPG_MD_LR_I","MPG_MD_MS_LR","MPG_MD_MS_I","HuffCodeTab","len","max","tab","hl","Tables","ht","largetbl","table23","table56","bitrate_table","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","GrInfo","_GrInfo","L3Side","array","other","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","ScaleFac","arrL","arrS","arr21","arr12","Encoder","s","MeanBits","meanBits","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","IIISideInfo","gr","ch","GrInfo","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","NsPsy","Encoder","VBRSeekInfo","Arrays","new_array_n","new_byte","new_float","new_float_n","new_int","new_int_n","assert","common_exports","_LameInternalFlags","__publicField","new_float","new_float_n","Encoder","new_int","new_int_n","new_array_n","ScaleFac","i","III_psy_xmin","NsPsy","VBRSeekInfo","IIISideInfo","Header","new_byte","LameInternalFlags","MAX_HEADER_BUF","VbrMode","Float","ShortBlock","Util","Arrays","new_float","new_float_n","new_int","assert","common_exports","Q_MAX","Q_MAX2","IXMAX_VAL","PRECALC_SIZE","DBL_EPSILON","NSATHSCALE","pow20","new_float","Q_MAX","Q_MAX2","ipow20","pow43","adj43","QuantizePVT","__publicField","ScaleFac","j","_tk","_rv","_psy","x","assert","gfp","f","ath","gfc","ATH_l","ATH_psfb21","ATH_s","ATH_psfb12","samp_freq","sfb","Encoder","start","end","Float","i","freq","ATH_f","bass","alto","treble","sfb21","pe","targ_bits","mean_bits","gr","cbr","tbits","total_added_bits","add_bits","new_int","channels","mb","MeanBits","extra_bits","max_bits_granule","capped_max_bits_granule","LameInternalFlags","ch","avg_bits_per_ch_granule","actual_extra_bits","final_total_bits","sum_after_scale","ms_ener_ratio","max_bits","fac","move_bits","SIDE_MIN_BITS","bits_to_move_limited","total_bits_after_move","a","athFloor","o","p","u","Util","v","w","ratio","cod_info","pxmin","pxminPos","gsfb","ath_over","ATH","xr","enable_athaa_fix","VbrMode","masking_lower","ath_band","xmin","width","en0","rh1","rh2","l","xa","xb","mask_en","mask_thr","max_nonzero","k","sfb_s","b","startline","step","noise","ix","xr_abs","temp","ix01","ix_val_0","dequant_0","ix_val_1","dequant_1","l3_xmin","distort","res","prev_noise","distortPos","l3_xminPos","over","over_noise_db","tot_noise_db","max_noise","scalefac","scalefacPos","use_prev","s","noise_power","noise_db","start_idx","usefullsize","sl_obj","tmp","sfb2","ifqstep","noise_res","pinfo","bw","plot_scale","thr0","thr_mask","sfb_plot_idx","window_start_j","plot_idx","ratio_en","scalefac_sav","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","common_exports","slen1_tab","slen2_tab","subdv_table","huf_tbl_noESC","Bits","b","count_bit","p","Takehiro","__publicField","_qupvt","l","istep","xr","xrPos","ix","ixPos","remaining","x0","x1","rx0","rx1","x2","x3","rx2","rx3","QuantizePVT","compareval0","endPos","max1","max2","end","t1","t2","s","linbits1","ht","linbits2","sum1","sum2","linbits_esc1","linbits_esc2","x","y","xy1","xy2","current_bits1","current_bits2","esc1","esc2","largetbl","best_sum","best_table","hlen1","xlen","hlen_combined","table23","table56","combined_len","sum3","hlen2","hlen3","max","choice2","choice1","gfc","cod_info","r01_bits","r01_div","r0_tbl","r1_tbl","bigv","r0","a1","r0bits","bi0","r0t","r1","a2","bits","bi1","r1t","region_boundary_index","cod_info2","gi","r2_idx","r2_sfb_idx","bi2","r2t","prev_noise","i","quad_idx","p_idx","packed_val","p_idx_c","Tables","region0_end","region1_end","Encoder","max_region0_size","max_region1_size","bi","sfb","max_allowed_xrpow","j","roundfac","width","band_end","GrInfo","k","max_slen1","max_slen2","tab","scalefac","found_valid","slen1_n","slen2_n","table_number","row_in_table","partition","nr_sfb","window","over","max_sfac","partition_table","current_sf","max_range_sfac_tab","log2tab","slen1","slen2","slen3","slen4","scfb_anz","bv_index","costab","rv_tbl","fht","fz","fzPos","n","tri","k4","fi","gi","fn","s1","c1","i","k1","k2","k3","kx","f0","f1","f2","f3","Util","c2","s2","a","b","g0","g1","g2","g3","FFT","new_float","BLKSIZE","BLKSIZE_s","gfc","x_real","chn","buffer","bufPos","x","k","j","w","tbl_idx","y","jj","VbrMode","Float","ShortBlock","Util","Arrays","new_float","new_float_n","new_int","new_int_n","assert","common_exports","LOG10","LN_TO_LOG10","rpelev","rpelev2","rpelev_s","rpelev2_s","DELBARK","VO_SCALE","Encoder","temporalmask_sustain_sec","NS_PREECHO_ATT0","NS_PREECHO_ATT1","NS_PREECHO_ATT2","NS_MSFIX","NSATTACKTHRE","NSATTACKTHRE_S","NSFIRLEN","I1LIMIT","I2LIMIT","MLIMIT","ma_max_i1","ma_max_i2","ma_max_m","init_mask_add_max_values","tab","table1","table2","table3","table2_","fircoef","fircoef_","regcoef_s","regcoef_l","PsyModel","__publicField","FFT","new_int_n","Encoder","new_float_n","energy","gfc","loudness_power","i","VO_SCALE","gfp","fftenergy","fftenergy_s","wsamp_l","wsamp_lPos","wsamp_s","wsamp_sPos","gr_out","chn","buffer","bufPos","current_chn_fft_l","current_chn_fft_s","left_fft_l","right_fft_l","j","l","r","Util","left_fft_s","right_fft_s","b","target_fft_l","re","im","target_fft_s","totalenergy","m1","m2","kk","shortblock","ratio","assert","combined_masking","ath_cb","f","r_m_ath","sb","sblock","thmL","thmR","thmM","thmS","enM","enS","mld_sb","mld_mid","rmid","mld_side","rside","msfix","athadjust","msfix2","athlower","ath","thmLR_min","thmMS_sum","eb","thr","enn","thmm","npart_s","bo_s_sb","b_lim","w_curr","w_next","enn_curr","thmm_curr","npart_l","bo_l_sb","ebb","n","s3_idx","first_masker_idx","last_masker_idx","ecb","limit1","rpelev_s","limit2","rpelev2_s","uselongblock","blocktype_d","blocktype","ShortBlock","final_prev_type","x","y","mr","masking_lower","pe_s","thm","en","LOG10","pe_l","max","avg","m","numlines","el","mask_idx","last_tab_entry","a","nl","k","new_float","mask_idx_s","new_int","dd","dd_n","masker_contribution","avg_mask","max_energy_limit","eb_l","mask_idx_l","prev_blocktype","ecb_limit_1","rpelev","NS_PREECHO_ATT2","ecb_limit_2","rpelev2","ecb_limit","current_blocktype","cb_mld","ebM","ebS","thmM_orig","thmS_orig","mld_factor","thmL_ath","thmR_ath","thmM_ath","thmS_ath","thmLR_min_ath","thmMS_sum_ath","current_sblock_fft","masking_ratio","masking_MS_ratio","sub_short_factor","ns_attacks","ns_hpfsmpl","n_chn_out","n_chn_psy","MPEGMode","firbuf","input_start_index","NSFIRLEN","c_sum1","c_sum2","base_idx","attack_intensity","en_subshort","en_short","attackThreshold","NSATTACKTHRE_S","NSATTACKTHRE","ns_uselongblock","pf","pfPos","pfe","p","abs_sample","prev_en","sub_idx","factor","max_attack","Arrays","block_idx","u","v","bark","hf_slope","tempx","tempy","LN_TO_LOG10","lim_a","lim_b","h","sum","step","temp","freq","bo","bm","bval","bval_width","mld","bo_w","sfreq","blksize","scalepos","deltafreq","sbmax","b_frq","granule_samples","sample_freq_frac","partition","ni","freq_per_line","fft_line_idx","part_idx","bark_start","fft_line_end","DELBARK","sfb","sfb_start_line","sfb_end_line","i1","i2","part1","part2","f_sfb_end","f_part_start","f_part_end","mld_freq","current_fft_line","w","bark1","bark2","bark_edge1","bark_edge2","npart","norm","use_old_s3","s3","numberOfNoneZero","s3_x_norm","start_masker","end_masker","start","end","arg","value","percep_entropy","percep_MS_entropy","wsamp_L","wsamp_S","eb_s","pcfact","numchn","VbrMode","current_wsamp_l_idx","current_wsamp_s_idx","en_curr","en_prev","NS_PREECHO_ATT0","idx","NS_PREECHO_ATT1","sub_en_idx","masker_energy","term","min_limit","clamped_ecb","ath_adj_factor","ppe_array","ppe_offset","granule_block_type","ch01","new_thmm","useOldS3","bvl_a","bvl_b","snr_l_a","snr_l_b","snr_s_a","snr_s_b","snr","minval","level","Float","temporalmask_sustain_sec","NS_MSFIX","frame_duration","freq_inc","eql_balance","VbrMode","ShortBlock","common_exports","LameGlobalFlags","__publicField","MPEGMode","new_float","ATH","new_float","Encoder","System","Arrays","GainAnalysis","PINK_REF","YULE_ORDER","RMS_PERCENTILE","MAX_SAMP_FREQ","RMS_WINDOW_TIME_NUMERATOR","RMS_WINDOW_TIME_DENOMINATOR","MAX_SAMPLES_PER_WINDOW","ABYule","ABButter","filterYule","input","inputPos","output","outputPos","nSamples","kernel","filterButter","ResetSampleFrequency","rgData","samplefreq","i","Arrays","fsqr","d","left_samples","left_samplesPos","right_samples","right_samplesPos","num_samples","num_channels","curleft","curleftBase","curright","currightBase","batchsamples","cursamples","cursamplepos","System","val","ival","analyzeResult","Array","len","elems","upper","retval","new_float","new_int","common_exports","ReplayGain","__publicField","GainAnalysis","histogramSize","ShortBlock","new_float","new_int","assert","common_exports","CBRNewIterationLoop","_quantize","__publicField","gfp","pe","ms_ener_ratio","ratio","gfc","l3_xmin","L3Side","xrpow","targ_bits","mean_bits","max_bits","l3_side","mb","MeanBits","gr","Encoder","ch","adjust","masking_lower_db","cod_info","LameInternalFlags","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_float","new_float_n","new_int","new_int_n","new_short_n","assert","common_exports","_PSY","__publicField","Encoder","_LowPassHighPass","_Lame","__publicField","PsyModel","Encoder","_ga","_bs","_p","_qupvt","_qu","_vbr","_ver","_id3","_mpglib","gfp","gfc","LameInternalFlags","MPEGMode","VbrMode","x","bitrate","full_bitrate_table","lower_range","lower_range_kbps","upper_range","upper_range_kbps","b","lowpassfreq","input_samplefreq","suggested_samplefreq","sample_freq","bRate","version","samplerate","nearest_bitrate","bitrate_table","min_diff","i","current_rate","diff","lh","freq_map","table_index","lowpass_band","highpass_band","minband","band","freq","maxband","fc1","fc2","LAME_DEFAULT_QUALITY","new_int_n","mf_needed","assert","inbuf_l","inbuf_r","mp3buf","mp3bufPos","mp3buf_size","ret","outbuf","outbufPos","desired_len","inbuf","in_bufferPos","len","num_used","ch","j","k","bpc","intratio","fcn","filter_l","new_float","sum","offset","inbuf_old","time0","joff","xvalue","j2","y","n_shift","mfbuf","in_buffer","nsamples","io","numUsed","space_left_out","space_left","dest_idx","buffer_l","buffer_r","mp3size","mp3out","n_in","n_out","buf_size","LameGlobalFlags","ATH","_PSY","ReplayGain","lowpass","_LowPassHighPass","m","Util","cmp","sfb_idx","sfb_info","size_l","size_s","CBRNewIterationLoop","ShortBlock","mp3buffer","mp3bufferPos","mp3buffer_size","buffer","imp3","mp3count","mp3buffer_size_remaining","samples_to_encode","end_padding","frames_left","bunch","Arrays","frame_num_before","input_r","working_l","working_r","needs_copy","eff_scale_l","eff_scale_r","scale_l","scale_r","float_buf_l","float_buf_r","scale_factor","Lame","LAME_MAXMP3BUFFER","Lame_default","Lame","TotalBytes","BitStream","_BitStream","context","a","b","ga","mpg","ver","vbr","gfc","val","j","assert","k","LAME_MAXMP3BUFFER","gfp","bit_rate","bitrate_table","bytes","remainingBits","i","lameHeader","byte","version","System","MAX_HEADER_BUF","ptr","byteIndex","shiftAmount","mask","bitsToWrite","value","crc","header","bitsPerFrame","l3_side","gr","ch","Arrays","band","gi","old","ht","h","bits","ix","xr","huffbits","p","v","code","len","signLen","count_bit","tableindex","start","end","cbits","xbits","linbits","xlen","ext","x1","x2","sign1","sign2","linbits_x1","linbits_x2","signmask","signlen","pair_index","bigvalues","region1Start","region2Start","sfb","data_bits","tot_bits","slen1","slen1_tab","slen2","slen2_tab","scale_bits","huff_bits","SHORT_TYPE","sfb_partition","sfbs","slen","total_bytes_output","flushbits","remaining_headers","last_ptr","first_ptr","tempTotalBytes","GainAnalysis","RadioGain","n","main_data_bits","side_info_bits","bits_written_this_frame","frame_deficit","wrapAmount","buffer","bufferPos","size","mp3data","bytes_to_copy","new_int","pcm_buf","new_float_n","mp3_in","samples_out","currentPos","bytes_consumed","absSampleL","absSampleR","new_byte","_qupvt","_tak","VBRQuantize","__privateAdd","_tk","__privateSet","CalcNoiseResult","new_float","new_int","CalcNoiseData","new_int","new_float","VbrMode","Float","ShortBlock","Util","Arrays","new_float","new_float_n","new_int","assert","common_exports","Quantize","__publicField","VBRQuantize","_bs","_rv","_qupvt","_tk","l3_side","gr","xrL","xrR","i","l","r","gfp","cod_info","xrpow","gfc","sum","upper","tmp","j","Encoder","sfb","ixwork","ix_dest","start_freq","end_freq","window","j_sfb","width","ath","xr","stop","gsfb","start","end","ath21","block","sfb_start_s","sfb_end_s","psfb_start","psfb_end","s12_width","psfb_width","start_idx_orig","end_idx_orig","ath12","gi","l3_xmin","work","distort","L3Side","calc_noise_result","CalcNoiseResult","current_freq_idx","start_sfb","sfb_start_idx","allowedNoise","trancateThreshold","accumulated_noise","processed_coeffs","current_val","current_noise","k","original_idx","ch","targ_bits","cod_info_w","GrInfo","save_xrpow","best_noise_info","prev_noise","CalcNoiseData","best_part2_3_length","bEndOfSearch","bRefine","best_ggain_pass1","age","inner_loop","noise_info","search_limit","maxggain","huff_bits","current_bits","quant_comp_mode","desired_rate","nBits","CurrentStep","flagGoneOver","Direction","step","status","ifqstep34","trigger","noise_shaping_amp","quant_comp","best","calc","better","klemm_noise","s","scalefac","s1","s2","gain","amp","last_width","min_bits","max_bits","bst_cod_info","bst_xrpow","initial_max_bits","current_max_bits","current_min_bits","this_bits","dbits","over","found","sfb21_extra","real_bits","frameBits","bitsPerFrame","original_vbr_min_index","meanBits","MeanBits","pe","ms_ener_ratio","ratio","bands","analog_silence","bits","avg_bits_per_granule","mxb_per_granule","adjust","masking_lower_db","max_frame_allowable_bits","pxmin","pxminPos","factor","avg_bits","total_max_bits","maximum_frame_bits","mb","analog_silence_bits","max_frame_bits","res_factor","totbits","mean_bits","mb_max","sum_gr_bits","target","add_bits","System","VbrMode","ShortBlock","Arrays","new_byte","assert","VBRTag","lame","bs","v","_lame","_bs","_v","FRAMES_FLAG","BYTES_FLAG","TOC_FLAG","VBR_SCALE_FLAG","NUMTOCENTRIES","MAXFRAMESIZE","VBRHEADERSIZE","LAMEHEADERSIZE","XING_BITRATE1","XING_BITRATE2","XING_BITRATE25","ISO_8859_1","VBRTag0","VBRTag1","crc16Lookup","addVbr","bitrate","i","xingSeekTable","t","j","act","sum","indx","seek_point","gfp","gfc","kbps","extractInteger","buf","bufPos","x","createInteger","value","createShort","isVbrTag","shiftInBitsValue","n","setLameTagFrameHeader","buffer","abyte","VbrMode","bbyte","pTagData","hId","hSrIndex","hMode","hBitrate","head_flags","encDelay","encPadding","kbps_header","totalFrameSize","headerSize","new_byte","crcUpdateLookup","crc","tmp","bufferPos","size","putLameVBR","musicLength","streamBuffer","streamBufferPos","bytesWritten","quality","version","vbr","revision","revMethod","vbrTypeTranslator","lowpass","peakSignalAmplitude","radioReplayGain","audiophileReplayGain","noiseShaping","stereoMode","nonOptimal","sourceFreq","misc","musicCRC","expNPsyTune","safeJoint","noGapMore","noGapPrevious","noGapCount","noGapCurr","athType","flags","abrBitrate","ShortBlock","skipId3v2","fpStream","id3v2Header","id3v2TagSize","Arrays","toc","streamIndex","streamSize","System","stream","bytes","ID3TagSpec","bs","ver","assert","Reservoir","bs","_bs","gfp","mean_bits","gfc","maxmp3buf","l3_side","frameLength","resvLimit","fullFrameBits","targ_bits","cbr","add_bits","ResvSize","ResvMax","extra_bits","gi","over_bits","stuffingBits","mdb_bytes","VbrMode","common_exports","VBRPresets","qual","comp","compS","y","shThreshold","shThresholdS","adj","adjShort","lower","curve","sens","inter","joint","mod","fix","ABRPresets","kbps","bass","sc","mask","interCh","sfScale","Presets","__publicField","_lame","gfp","a","enforce","vbr_preset","x","p_idx","q_idx","p","q","set","preset","actual_bitrate","r","k","short_adj","VBR_q","ret","original_preset","Lame_default","vbr_quality_index","LameContext","ID3TagSpec","Reservoir","QuantizePVT","Takehiro","Quantize","VBRTag","Presets","Lame","Version","BitStream","GainAnalysis","PsyModel","Mp3Encoder","config","_a","_b","LameContext","modeMap","MPEGModeValues","VbrMode","retcode","left","right","inputRight","isFloat","encodedSize","rightFloat","rightInt","finalSize"]}